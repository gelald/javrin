import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,a as r}from"./app-D62f3oGG.js";const l={},i=r('<h1 id="rocketmq-入门" tabindex="-1"><a class="header-anchor" href="#rocketmq-入门"><span>RocketMQ 入门</span></a></h1><h2 id="为什么使用消息中间件" tabindex="-1"><a class="header-anchor" href="#为什么使用消息中间件"><span>为什么使用消息中间件</span></a></h2><ul><li><p>异步：把非必要的业务逻辑以异步的方式运行，提高响应速度。</p></li><li><p>流量削峰：当并发量很大，比如每秒 5000，但是 MySQL 能处理的并发量可能只有 200，会导致系统崩溃。消费者系统按照数据库能处理的并发量从消息队列中拉取消息消费，这个短暂的高峰期积压是允许的。</p></li><li><p>解耦：如果 A 系统直接调用多个系统的接口，那修改其他系统需要修改 A 系统代码；如果 A 系统使用中间件来调用多个系统的接口，那么当其他系统修改时 A 系统不需要做任何修改。</p></li></ul><h2 id="为什么选择使用-rocketmq" tabindex="-1"><a class="header-anchor" href="#为什么选择使用-rocketmq"><span>为什么选择使用 RocketMQ</span></a></h2><p>选择消息中间件我一般会用以下几个指标来考虑：功能支持、可靠性、性能、伸缩性等</p><ul><li><p>ActiveMQ：目前社区活跃度较低，暂不考虑</p></li><li><p>RabbitMQ：虽然拥有灵活的路由配置，但是性能和吞吐量不是特别理想</p></li><li><p>Kafka：虽然拥有强大的性能以及吞吐量，但是批量发送，可能会导致延迟较高</p></li><li><p>RocketMQ：低延迟、吞吐量高、可靠性强，稳定性方面在阿里巴巴经历数次双十一考验，值得信赖。</p></li></ul><h3 id="什么情况下的异步操作需要使用消息队列而不是多线程" tabindex="-1"><a class="header-anchor" href="#什么情况下的异步操作需要使用消息队列而不是多线程"><span>什么情况下的异步操作需要使用消息队列而不是多线程</span></a></h3><ul><li><p>消息队列和多线程两者并不冲突，多线程可以作为队列的生产者和消费者。在使用外部的消息队列时，可以提高应用的稳定性，当程序宕机后，已经写入外部消息队列的数据依旧是保存下来的。</p></li><li><p>用线程的话，会占用主服务器资源；消息队列的话，可以放到其他机器上运行，让主服务器更纯粹地处理请求。如果用户不急着知道结果的操作，可以用消息队列，否则再考虑多线程。</p></li><li><p>消息队列是在架构层面解决问题；多线程是在编程语言层面解决问题；消息队列解耦更充分，架构更合理。</p></li></ul><h2 id="消息消费模型" tabindex="-1"><a class="header-anchor" href="#消息消费模型"><span>消息消费模型</span></a></h2><p>消息消费模型一般有两种：</p><ul><li><p>点对点模型：生产者往某个队列中发送消息，一个队列可以存储多个生产者的消息，一个队列也可以对应多个消费者，但是这些消费者是竞争关系，每条消息只能被一个消费者消费。</p></li><li><p>发布订阅模型：和队列模式最大的不同是，如果一个消息的主题被多个消费者同时订阅了，那么这些消费者都能收到这些消息的副本，不再是多个消费者竞争一个消息。</p></li></ul><p>RocketMQ 的消息模型是标准的发布-订阅模型，在 RocketMQ 的术语表中，生产者、消费者和主题，与发布-订阅模型中的概念是完全一样的。</p><h2 id="rocketmq-优缺点" tabindex="-1"><a class="header-anchor" href="#rocketmq-优缺点"><span>RocketMQ 优缺点</span></a></h2><p>RocketMQ 优点：</p><ul><li>可用性：搭建集群模式可以达到较高的可用性</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>性能方面：支持10亿级别的消息堆积，不会因为堆积导致性能下降</li><li>稳定性：RoketMQ在稳定性上可能更值得信赖，在阿里双11已经经历了多次考验</li></ul><p>RocketMQ缺点：</p><ul><li>没有在 MQ 核心逻辑中去实现 JMS 等接口，有些系统要迁移需要修改大量代码</li><li>目前只支持 Java 和 C++，其中 C++ 客户端也不成熟</li></ul><h2 id="rocketmq-角色介绍" tabindex="-1"><a class="header-anchor" href="#rocketmq-角色介绍"><span>RocketMQ 角色介绍</span></a></h2><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617221818.png" alt=""></p><h3 id="nameserver" tabindex="-1"><a class="header-anchor" href="#nameserver"><span>NameServer</span></a></h3><p>可以理解为是一个注册中心，支持 Broker 的动态注册与发现，提供给生产者和消费者查找 Broker 信息，从而进行消息的发送/消费。</p><h3 id="broker" tabindex="-1"><a class="header-anchor" href="#broker"><span>Broker</span></a></h3><p>主要负责消息的存储、投递以及服务高可用的保证，有以下子模块：</p><ul><li>Remoting Module：这是 Broker 的入口模块，负责处理所有来自客户端的请求。</li><li>Client Manager：负责管理所有的生产者消费者客户端，并维护消费者和 Topic 的订阅信息。</li><li>Store Service：提供把消息存储到物理磁盘和查询消息的功能。</li><li>HA Service：高可用服务，提供 master 节点和 slave 节点之间的关系。</li></ul><h3 id="producer" tabindex="-1"><a class="header-anchor" href="#producer"><span>Producer</span></a></h3><p>消息生产者，通过 NameServer 获取 Broker 的地址并发送消息。</p><h3 id="customer" tabindex="-1"><a class="header-anchor" href="#customer"><span>Customer</span></a></h3><p>消息消费者，支持 <code>push</code>、<code>pull</code> 两种模式对消息进行消费，同时也支持集群方式和广播形式的消费。</p><h2 id="rocketmq-术语介绍" tabindex="-1"><a class="header-anchor" href="#rocketmq-术语介绍"><span>RocketMQ 术语介绍</span></a></h2><h3 id="topic-主题" tabindex="-1"><a class="header-anchor" href="#topic-主题"><span>Topic（主题）</span></a></h3><p>用于标识一类消息。</p><h3 id="tag" tabindex="-1"><a class="header-anchor" href="#tag"><span>Tag</span></a></h3><p>同一类消息可以再细分二级分类，方便消费者进行消息的过滤。Topic：手机；Tag：苹果、小米、华为。</p><h3 id="group-分组" tabindex="-1"><a class="header-anchor" href="#group-分组"><span>Group（分组）</span></a></h3><p>一般生产者的分组<strong>主要作用于事务消息</strong>，因为 RocketMQ 有事务回查机制，当一个生产者挂了，事务回查的时候还可以找到同一个组内的其他生产者实例进行事务回查。体现了 RocketMQ 高可用的特性。</p><p><strong>一个消费者组中的多个消费者只能订阅一类消息</strong>，消费进度与消费者组关联，体现了 RocketMQ 具有负载均衡的特性。如果多个消费者组订阅同一类消息，那么两组的消费是互不影响的。</p><h3 id="message-queue-消息队列" tabindex="-1"><a class="header-anchor" href="#message-queue-消息队列"><span>Message Queue（消息队列）</span></a></h3><p>用于传递消息的组件，一个 Queue 只能被一个消费者消费，但是一个消费者可以消费多个 Queue 的消息。如果消费者组中的消费者数量与 Queue 数量相同，那么一般来说会一个消费者对应消费一个 Queue，因为消费者有自己的业务逻辑，往往没有生产者生产消息快，使用 Queue 后可以实现多个消费者消费一个生产者生产的消息，体现了 RocketMQ 高性能的特性。</p><h3 id="offset-偏移量" tabindex="-1"><a class="header-anchor" href="#offset-偏移量"><span>Offset（偏移量）</span></a></h3><p>一般是指某一个队列中消费者消费的偏移量，可以简单理解成消费者消费了多少个消息。</p><p>另外还有队列中消息的偏移量，可以简单理解成队列中存储了多少消息。</p><h2 id="rocketmq-消息消费模式" tabindex="-1"><a class="header-anchor" href="#rocketmq-消息消费模式"><span>RocketMQ 消息消费模式</span></a></h2><ul><li><p>clustering(集群)：集群消费模式是消息会被雨露均沾地投递到消费者组内的各个消费者实例，消费进度保存在 Queue 中。这是默认并且常用的消费模式，后续如果没有特地说明是广播消费模式都认为是集群消费模式。</p></li><li><p>broadcast(广播)：广播消费模式是消息会被投递到消费者组内的每一个消费者实例，相当于这些消费者实例都获取到这些消息的副本，所以消费进度由消费者自己维护。一般开发较为少数情况用到它，不太灵活。</p></li></ul>',43),o=[i];function c(n,s){return a(),t("div",null,o)}const d=e(l,[["render",c],["__file","RocketMQ-start.html.vue"]]),u=JSON.parse('{"path":"/writings/RocketMQ/RocketMQ-start.html","title":"RocketMQ 入门","lang":"zh-CN","frontmatter":{"title":"RocketMQ 入门","icon":"article","category":["干货","消息队列"],"tag":["基础","RocketMQ"],"description":"RocketMQ 入门 为什么使用消息中间件 异步：把非必要的业务逻辑以异步的方式运行，提高响应速度。 流量削峰：当并发量很大，比如每秒 5000，但是 MySQL 能处理的并发量可能只有 200，会导致系统崩溃。消费者系统按照数据库能处理的并发量从消息队列中拉取消息消费，这个短暂的高峰期积压是允许的。 解耦：如果 A 系统直接调用多个系统的接口，那修...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/RocketMQ/RocketMQ-start.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"RocketMQ 入门"}],["meta",{"property":"og:description","content":"RocketMQ 入门 为什么使用消息中间件 异步：把非必要的业务逻辑以异步的方式运行，提高响应速度。 流量削峰：当并发量很大，比如每秒 5000，但是 MySQL 能处理的并发量可能只有 200，会导致系统崩溃。消费者系统按照数据库能处理的并发量从消息队列中拉取消息消费，这个短暂的高峰期积压是允许的。 解耦：如果 A 系统直接调用多个系统的接口，那修..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617221818.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:49:34.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:49:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 入门\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617221818.png\\"],\\"dateModified\\":\\"2023-03-04T10:49:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"为什么使用消息中间件","slug":"为什么使用消息中间件","link":"#为什么使用消息中间件","children":[]},{"level":2,"title":"为什么选择使用 RocketMQ","slug":"为什么选择使用-rocketmq","link":"#为什么选择使用-rocketmq","children":[{"level":3,"title":"什么情况下的异步操作需要使用消息队列而不是多线程","slug":"什么情况下的异步操作需要使用消息队列而不是多线程","link":"#什么情况下的异步操作需要使用消息队列而不是多线程","children":[]}]},{"level":2,"title":"消息消费模型","slug":"消息消费模型","link":"#消息消费模型","children":[]},{"level":2,"title":"RocketMQ 优缺点","slug":"rocketmq-优缺点","link":"#rocketmq-优缺点","children":[]},{"level":2,"title":"RocketMQ 角色介绍","slug":"rocketmq-角色介绍","link":"#rocketmq-角色介绍","children":[{"level":3,"title":"NameServer","slug":"nameserver","link":"#nameserver","children":[]},{"level":3,"title":"Broker","slug":"broker","link":"#broker","children":[]},{"level":3,"title":"Producer","slug":"producer","link":"#producer","children":[]},{"level":3,"title":"Customer","slug":"customer","link":"#customer","children":[]}]},{"level":2,"title":"RocketMQ 术语介绍","slug":"rocketmq-术语介绍","link":"#rocketmq-术语介绍","children":[{"level":3,"title":"Topic（主题）","slug":"topic-主题","link":"#topic-主题","children":[]},{"level":3,"title":"Tag","slug":"tag","link":"#tag","children":[]},{"level":3,"title":"Group（分组）","slug":"group-分组","link":"#group-分组","children":[]},{"level":3,"title":"Message Queue（消息队列）","slug":"message-queue-消息队列","link":"#message-queue-消息队列","children":[]},{"level":3,"title":"Offset（偏移量）","slug":"offset-偏移量","link":"#offset-偏移量","children":[]}]},{"level":2,"title":"RocketMQ 消息消费模式","slug":"rocketmq-消息消费模式","link":"#rocketmq-消息消费模式","children":[]}],"git":{"createdTime":1659693985000,"updatedTime":1677926974000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":5.94,"words":1781},"filePathRelative":"writings/RocketMQ/RocketMQ-start.md","localizedDate":"2022年8月5日","autoDesc":true}');export{d as comp,u as data};
