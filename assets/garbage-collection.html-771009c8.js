const e=JSON.parse('{"key":"v-e6208954","path":"/writings/JVM/garbage-collection.html","title":"垃圾回收基础","lang":"zh-CN","frontmatter":{"title":"垃圾回收基础","icon":"article","category":["JVM"],"tag":["监控","调优"],"description":"垃圾回收基础 垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收 判断一个对象是否可以被回收 引用计数算法 实现原理：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 弊端：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/JVM/garbage-collection.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"垃圾回收基础"}],["meta",{"property":"og:description","content":"垃圾回收基础 垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收 判断一个对象是否可以被回收 引用计数算法 实现原理：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 弊端：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:20:13.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"监控"}],["meta",{"property":"article:tag","content":"调优"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"垃圾回收基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:20:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"判断一个对象是否可以被回收","slug":"判断一个对象是否可以被回收","link":"#判断一个对象是否可以被回收","children":[{"level":3,"title":"引用计数算法","slug":"引用计数算法","link":"#引用计数算法","children":[]},{"level":3,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]}]},{"level":2,"title":"引用类型","slug":"引用类型","link":"#引用类型","children":[{"level":3,"title":"强引用","slug":"强引用","link":"#强引用","children":[]},{"level":3,"title":"软引用","slug":"软引用","link":"#软引用","children":[]},{"level":3,"title":"弱引用","slug":"弱引用","link":"#弱引用","children":[]},{"level":3,"title":"虚引用","slug":"虚引用","link":"#虚引用","children":[]}]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"标记-清除","slug":"标记-清除","link":"#标记-清除","children":[]},{"level":3,"title":"标记-整理","slug":"标记-整理","link":"#标记-整理","children":[]},{"level":3,"title":"复制","slug":"复制","link":"#复制","children":[]},{"level":3,"title":"具体落地","slug":"具体落地","link":"#具体落地","children":[]}]},{"level":2,"title":"垃圾收集器","slug":"垃圾收集器","link":"#垃圾收集器","children":[{"level":3,"title":"Serial 收集器","slug":"serial-收集器","link":"#serial-收集器","children":[]},{"level":3,"title":"ParNew 收集器","slug":"parnew-收集器","link":"#parnew-收集器","children":[]},{"level":3,"title":"Serial Old 收集器","slug":"serial-old-收集器","link":"#serial-old-收集器","children":[]},{"level":3,"title":"CMS 收集器","slug":"cms-收集器","link":"#cms-收集器","children":[]},{"level":3,"title":"G1 收集器","slug":"g1-收集器","link":"#g1-收集器","children":[]}]},{"level":2,"title":"堆的垃圾回收","slug":"堆的垃圾回收","link":"#堆的垃圾回收","children":[{"level":3,"title":"堆内存分配策略","slug":"堆内存分配策略","link":"#堆内存分配策略","children":[]},{"level":3,"title":"GC 触发条件","slug":"gc-触发条件","link":"#gc-触发条件","children":[]}]},{"level":2,"title":"方法区的垃圾回收","slug":"方法区的垃圾回收","link":"#方法区的垃圾回收","children":[]}],"git":{"createdTime":1677597613000,"updatedTime":1677597613000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":11.08,"words":3324},"filePathRelative":"writings/JVM/garbage-collection.md","localizedDate":"2023年2月28日","excerpt":"<h1> 垃圾回收基础</h1>\\n<blockquote>\\n<p>垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收</p>\\n</blockquote>\\n<h2> 判断一个对象是否可以被回收</h2>\\n<h3> 引用计数算法</h3>\\n<p>实现原理：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>\\n<p>弊端：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
