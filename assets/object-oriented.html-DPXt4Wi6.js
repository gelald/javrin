import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-Svu5x8lo.js";const p={};function t(e,i){return l(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h1><blockquote><p>每当提起 Java ，面向对象都是我们第一时间能想到与其关联的内容，我们在这里梳理一下面向对象的内容。</p></blockquote><h2 id="三大特性" tabindex="-1"><a class="header-anchor" href="#三大特性"><span>三大特性</span></a></h2><blockquote><p>面向对象的三大特性是老生常谈的话题，本节简单总结一下三大特性。</p></blockquote><h3 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h3><p>概念：使对象尽可能隐藏内部细节，只保留一些对外的方法使之与外部发生联系。用户无需知道对象内部细节，但可以通过对象对外提供的方法来访问对象。</p><p>优点：</p><ol><li><p>减少耦合：可以独立地进行开发、修改、测试。</p></li><li><p>便于开发人员理解这个类的功能。</p></li><li><p>提高系统的可复用性。</p></li></ol><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h3><p>概念：一个类可以通过关键字 <code>extend</code> 以继承父类的非 <code>private</code> 成员。解决共性抽取的问题。</p><p>特点：</p><ol><li><p>一个类只能有一个直接父类（单继承），但是接口可以有多个父类（多继承）。</p></li><li><p>一个子类只有一个直接父类，但是一个父类可以拥有多个子类。</p></li></ol><h3 id="多态" tabindex="-1"><a class="header-anchor" href="#多态"><span>多态</span></a></h3><p>多态具体分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要是体现为方法的重载。Java虚拟机在编译时根据参数类型、个数、顺序能确定执行重载方法中的某一个。</p></li><li><p>运行时多态主要是体现为父类的引用指向子类的对象。需要在运行时，Java虚拟机才能确定引用指向的具体类型，执行具体类型中的方法。</p></li></ul><h4 id="运行时多态" tabindex="-1"><a class="header-anchor" href="#运行时多态"><span>运行时多态</span></a></h4><p><strong>运行时多态是面向抽象编程的基础</strong>，使用这个特性可以很方便地进行面向抽象类/接口开发，无需为具体的子类/实现类一一编写逻辑，因为子类重写了父类方法，运行时根据具体的类型执行父类中定义的方法。</p><p>运行时多态的条件：</p><ul><li><p>继承，没有继承，就没有子类</p></li><li><p>重写，没有重写，多态就没有意义</p></li><li><p>向上转型</p></li></ul><blockquote><p>这里重点说说向上转型</p><p>向上转型的格式就是运行时多态的写法 <code>父类 对象名 = new 子类();</code> ，意为创建一个子类对象，但把他看成父类来进行使用。</p><p>这么做的好处是可以灵活地更换不同的子类；弊端是由于「编译看左，运行看右」，这个对象无法调用子类中特有的内容。</p><hr><p>既然有向上转型，也就有向下转型。向下转型具体写法是 <code>子类 对象名 = (子类) 原父类对象;</code> ，其实就是将父类对象「还原」成本来的子类对象。</p><p>这么做的好处是可以使用子类的内容；弊端是必须要先确定子类类型，才能进行强转，否则会有 ClassCastException （可以借助 <code>instanceof</code> 关键字进行判断）。</p></blockquote><p>下面用一个例子来体现运行时多态的特点</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> say</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cat</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> say</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;miao miao miao~&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Dog</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> say</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;wang wang wang~&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Animal</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">animals</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        animals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Cat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        animals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Dog</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Animal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> animal</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> animals) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">say</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ******输出******</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">miao miao miao</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">~</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">wang wang wang</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">~</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，即使开发时使用着接口的对象，但在运行时会根据具体的实现类型分别调用其重写的方法。这么做可以通用这一段遍历调用的逻辑，无需根据具体类型再开发相似的逻辑，非常的方便。</p><h2 id="重写与重载" tabindex="-1"><a class="header-anchor" href="#重写与重载"><span>重写与重载</span></a></h2><blockquote><p>上文「多态」这一小节提到方法的重写、重载，本节进行两个概念的解释与对比。</p></blockquote><p>相同点：</p><ul><li><p>作用：都是体现了多态这一特性。</p></li><li><p>形式：重写方法与重载方法都与原方法的名称一样。</p></li></ul><p>不同点：</p><ul><li><p>存在：重写方法存在于继承体系中；重载方法存在于同一个类中。</p></li><li><p>形式上：重写方法与原方法的参数列表一模一样；重载方法与原方法的参数列表有区别（可能是参数类型、顺序、数量）。</p></li></ul><p><strong>另外方法重写需要遵循以下规则</strong>：</p><ol><li><p>子类方法的访问权限必须<strong>大于等于</strong>父类方法访问权限</p><blockquote><p>public &gt; protected &gt; 什么都不写 &gt; private</p></blockquote></li><li><p>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围（换言之就是返回值类型要相同或者是其子类）</p></li><li><p>子类方法只能声明<strong>小于等于</strong>父类方法声明的异常范围（可以抛出更少、更具体设置说不抛出）</p></li></ol><p>前两点是里氏替换原则的内容，重写可以使用 <code>@Override</code> 注解，让编译器帮忙检查是否满足重写的规则</p><p>需要注意的是：<strong>两个方法名称一样，不管参数列表是否有区别，返回值都不允许相同</strong>。</p><h2 id="抽象类与接口" tabindex="-1"><a class="header-anchor" href="#抽象类与接口"><span>抽象类与接口</span></a></h2><p>抽象类特点</p><ul><li><p>结构：抽象类允许定义抽象方法，但是也可以不定义。</p></li><li><p>实例化：抽象类不可以实例化，必须有一个子类继承它。</p></li></ul><p>抽象方法：</p><ul><li><p>被 <code>abstract</code> 修饰</p></li><li><p>没有方法体</p></li><li><p>必须定义在抽象类中</p></li></ul><hr><p>接口特点</p><p>接口是一种特殊的抽象类，一般在开发中更偏向使用接口，因为组合关系比继承关系耦合度更低。</p><p>Jdk8 中接口可以拥有的内容：</p><ul><li><p>常量</p></li><li><p>抽象方法</p></li><li><p>默认方法，可以用于接口升级，避免增加接口导致大量实现类需要改动</p></li><li><p>静态方法</p></li></ul><h2 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字"><span>关键字</span></a></h2><blockquote><p>本小节总结一下面向对象中的一些关键字</p></blockquote><h3 id="super与this" tabindex="-1"><a class="header-anchor" href="#super与this"><span>super与this</span></a></h3><p>分别用于在成员中调用父类的成员和本类中的其他成员</p><p>重点介绍一下用在构造方法中的情况</p><blockquote><p>super(param) 调用父类构造方法</p><p>this(param) 调用本类其他构造方法</p><p>但是这两句必须是构造方法中第一句并且也是唯一一句，所以两者<strong>不能同时使用</strong>。</p></blockquote><h3 id="static" tabindex="-1"><a class="header-anchor" href="#static"><span>static</span></a></h3><p>static 关键字有三个使用途径，当被 static 关键字修饰后，所有类对象共享这一份数据。</p><ul><li><p>静态成员变量</p></li><li><p>静态成员方法</p></li><li><p>静态代码块，当第一次使用到本类时，静态代码块执行唯一的一次。一般用于一次性地为静态成员变量赋值。</p></li></ul><h3 id="final" tabindex="-1"><a class="header-anchor" href="#final"><span>final</span></a></h3><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h4><p>final 关键字可以用在四个地方</p><ul><li><p>修饰类，这个类不能有任何的子类。</p></li><li><p>修饰方法，这个方法不允许在子类中被重写。</p></li><li><p>修饰局部变量，如果是基本数据类型，是指栈中的值不允许被改变；如果是引用类型，引用的地址指不允许被改变。</p></li><li><p>修饰成员变量，比修饰局部变量更加严格。</p><ul><li><p>这个成员变量不允许有 setter 方法</p></li><li><p>被修饰后必须手动赋值或通过构造方法赋值，不会给默认值</p></li><li><p>值得一提的是，如果通过构造方法赋值的话，那么必须保证每一个构造方法中都能对这个成员变量赋值</p></li></ul></li></ul><h4 id="关于提升性能" tabindex="-1"><a class="header-anchor" href="#关于提升性能"><span>关于提升性能</span></a></h4><p>关于 final 关键字提升性能这个 topic ，众说纷纭，这里不做深究。本人认为提升性能应该从大方面出发，以大带小，比如合理设计表结构、合理设计连接池等，初学者暂时不合适在小地方深挖～</p><p>这里先说结论：使用 final 关键字更多地是一个编译时的提升，暂时没有发现对运行时有大幅度的提升，所以<strong>使用 final 关键字应该要出于清晰的设计和可读性的目的，而不是出于性能原因</strong>。</p><p>下面简单说说几个值得注意的地方</p><ul><li><p>JVM 会缓存 final 变量，优化字符串的拼接，当字符串变量被 final 修饰时，在拼接的时候会认为这是一个常量，编译期就可以完成拼接。</p></li><li><p>final 的变量避免线程安全问题，多个线程可以共享，不需要额外的同步开销。</p></li></ul>`,61)])])}const r=s(p,[["render",t]]),d=JSON.parse('{"path":"/writings/Java-base/object-oriented.html","title":"面向对象","lang":"zh-CN","frontmatter":{"title":"面向对象","icon":"article","category":["Java基础"],"tag":["面向对象"],"description":"面向对象 每当提起 Java ，面向对象都是我们第一时间能想到与其关联的内容，我们在这里梳理一下面向对象的内容。 三大特性 面向对象的三大特性是老生常谈的话题，本节简单总结一下三大特性。 封装 概念：使对象尽可能隐藏内部细节，只保留一些对外的方法使之与外部发生联系。用户无需知道对象内部细节，但可以通过对象对外提供的方法来访问对象。 优点： 减少耦合：可...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:20:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Java-base/object-oriented.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"面向对象"}],["meta",{"property":"og:description","content":"面向对象 每当提起 Java ，面向对象都是我们第一时间能想到与其关联的内容，我们在这里梳理一下面向对象的内容。 三大特性 面向对象的三大特性是老生常谈的话题，本节简单总结一下三大特性。 封装 概念：使对象尽可能隐藏内部细节，只保留一些对外的方法使之与外部发生联系。用户无需知道对象内部细节，但可以通过对象对外提供的方法来访问对象。 优点： 减少耦合：可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:20:13.000Z"}],["meta",{"property":"article:tag","content":"面向对象"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:20:13.000Z"}]]},"git":{"createdTime":1677597613000,"updatedTime":1677597613000,"contributors":[{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":1,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":7,"words":2099},"filePathRelative":"writings/Java-base/object-oriented.md","autoDesc":true}');export{r as comp,d as data};
