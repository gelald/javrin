import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as n}from"./app-CWqWNMCa.js";const l={};function e(h,i){return n(),a("div",null,[...i[0]||(i[0]=[t(`<h1 id="string" tabindex="-1"><a class="header-anchor" href="#string"><span>String</span></a></h1><blockquote><p>为 String 单独拆分一个模块出来，可以看出 String 的特殊性及重要性。此外 String 也是面试题的「常客」。</p></blockquote><h2 id="不可变" tabindex="-1"><a class="header-anchor" href="#不可变"><span>不可变</span></a></h2><p>String 类型最大的特点就是不可变，因为内部是使用一个被 <code>final</code> 关键字修饰的 <code>char[]</code> 存储数据，初始化后就不能引用其他数组，并且内部没有改变这个数组的方法，因此它是不可变的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.io.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Serializable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Comparable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CharSequence</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /** The value is used for character storage. */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不可变的优点：</p><ul><li><p>可以用于 <code>HashMap</code> 中的 key 。因为作为 key 是需要使用 hashcode 的，而 String 类型数据不可变，所以 hashcode 不需要重新计算，效率更高。</p></li><li><p>可以使用常量池的设计。如果一个字符串已经被创建过了，那么就会从 String 常量池中取得引用。</p></li><li><p>安全性。不可变让它具备线程安全的特点，可以在多个线程中使用。再比如可以作为类的全限定类名，在框架中往往大量使用反射，如果这个字符串是可以改变的，那么就无法使用反射的特性。</p></li></ul><h2 id="创建" tabindex="-1"><a class="header-anchor" href="#创建"><span>创建</span></a></h2><p>String 类型的数据常用的创建方式有两种</p><ul><li>构造方法创建</li><li>通过字面量创建</li></ul><p>两种方式的区别是</p><ul><li>构造方法创建每次都会在堆中创建一个新的对象，无论两个字符串内容是否相同</li><li>通过字面量创建的话，第一次创建会把字符串对象放在常量池中，下一次再创建相同内容的字符串时会引用常量池中相同的对象</li></ul><p>我们通过一个小例子来感受一下两种创建方式的区别</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中字面量创建还可以和编译器优化碰撞新的火花</p><blockquote><p>String s = &quot;123&quot; + &quot;456&quot;内存中产生几个字符串对象?</p><p>由于等号右边都是常量的运算，所以编译器在编译的时候会进行优化。把&quot;123&quot;、&quot;456&quot;拼接成&quot;123456&quot;，如果此时常量池中没有&quot;123456&quot;，则产生1个，如果有，则产生0个。</p></blockquote><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h2><blockquote><p>关于 String 的方法有很多，这里简单介绍一些值得注意的</p></blockquote><h3 id="boolean-equals-object-object" tabindex="-1"><a class="header-anchor" href="#boolean-equals-object-object"><span>boolean equals(Object object)</span></a></h3><p>这是比较两个字符串的内容是否一样的方法，通过比较底层数组中的每一个字符是否相等。</p><p>值得注意的是：一般推荐把能确定的非空字符串甚至是常量写在方法左边，这样可以有效避免空指针异常。</p><h3 id="string-concat-string-str" tabindex="-1"><a class="header-anchor" href="#string-concat-string-str"><span>String concat(String str)</span></a></h3><p>拼接字符串，返回新字符串。</p><h3 id="string-substring-int-begin-int-end" tabindex="-1"><a class="header-anchor" href="#string-substring-int-begin-int-end"><span>String substring(int begin, int end)</span></a></h3><p>以一个左闭右开的区间截断字符串，返回新字符串。</p><p>这两个方法重点不是介绍功能，而是因为 String 是不可变的，所以每一次对 String 进行一些内容上的增减操作时，都会返回一个新的 String ，保证了 String 的不可变的特点。</p><h3 id="native-string-intern" tabindex="-1"><a class="header-anchor" href="#native-string-intern"><span>native String intern()</span></a></h3><p>着重讲一下这个方法，这个方法把字符串对象放到常量池中并返回它的引用。</p><p>我们通过一个小例子来演示这个方法的功能</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;aaa&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;aaa&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// false</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">intern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  	// true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>讲讲这个过程到底发生了什么事情</p><ol><li><p>s1 采用构造方法的方式创建了一个字符串对象，这个对象是在堆上的；s2 采用字面量的方式创建了一个字符串对象，这个对象是在字符串常量池中的。</p></li><li><p>所以当判断 s1 == s2 的时候，结果自然是 false 的，因为这两个对象不是同一个对象。</p></li><li><p>s3 使用 intern 方法获得了一个字符串对象，这个 intern 方法具体是先把 s1 引用的对象放到字符串常量池中，然后返回这个对象的引用。</p></li><li><p>但是现在 &quot;aaa&quot; 这个字符串在字符串常量池中已存在，所以使用了同一个对象，所以判断 s3 == s2 的时候，结果自然是 true 的。</p></li></ol><h2 id="stringbuilder-和-stringbuffer" tabindex="-1"><a class="header-anchor" href="#stringbuilder-和-stringbuffer"><span>StringBuilder 和 StringBuffer</span></a></h2><blockquote><p>介绍完 String，接下来介绍一下它的两个「兄弟」类型</p></blockquote><p>可以把它们看成是长度可以变化的字符串，也就是没有 String 的不可变的特性。</p><p>现在从各个角度对比一下 String、StringBuilder、StringBuffer</p><ul><li><p>可变性：String 是不可变的；StringBuilder 和 StringBuffer 是可变的。原因：String 底层的字符数组是被 final 修饰的，一旦赋值不可以修改;而 StringBuilder 和 StringBuffer 的都没有。</p></li><li><p>线程安全性：String 是不可变的，多个线程可以共享同一个 String，所以是线程安全的；StringBuffer 的方法中加了同步锁，所以是线程安全的；StringBuilder 没有加锁，是线程不安全的。</p></li><li><p>性能方面：StringBuffer 加了锁，导致性能变差；StringBuilder 没有加锁，性能相对来说比较好；String 每次都会生成新的对象，性能更差一点。StringBuffer 和 StringBuilder 都不会生成新的对象，所以比 String 来说效率更高。</p></li><li><p>从使用场景来说：操作少量数据使用 String；单线程操作大量数据使用 StringBuilder；多线程操作大量数据使用 StringBuffer。</p></li></ul>`,37)])])}const k=s(l,[["render",e]]),g=JSON.parse('{"path":"/writings/Java-base/String.html","title":"String","lang":"zh-CN","frontmatter":{"title":"String","icon":"article","category":["Java基础"],"tag":["String"],"description":"String 为 String 单独拆分一个模块出来，可以看出 String 的特殊性及重要性。此外 String 也是面试题的「常客」。 不可变 String 类型最大的特点就是不可变，因为内部是使用一个被 final 关键字修饰的 char[] 存储数据，初始化后就不能引用其他数组，并且内部没有改变这个数组的方法，因此它是不可变的。 不可变的优点：...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"String\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:20:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Java-base/String.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"String"}],["meta",{"property":"og:description","content":"String 为 String 单独拆分一个模块出来，可以看出 String 的特殊性及重要性。此外 String 也是面试题的「常客」。 不可变 String 类型最大的特点就是不可变，因为内部是使用一个被 final 关键字修饰的 char[] 存储数据，初始化后就不能引用其他数组，并且内部没有改变这个数组的方法，因此它是不可变的。 不可变的优点：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:20:13.000Z"}],["meta",{"property":"article:tag","content":"String"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:20:13.000Z"}]]},"git":{"createdTime":1677597613000,"updatedTime":1677597613000,"contributors":[{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":1,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":4.57,"words":1370},"filePathRelative":"writings/Java-base/String.md","autoDesc":true}');export{k as comp,g as data};
