import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as n}from"./app-BH1OTr4j.js";const l={};function t(o,s){return n(),e("div",null,[...s[0]||(s[0]=[a(`<h1 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识"><span>基础知识</span></a></h1><p>概念：redis是一款高效的<strong>NoSQL</strong>(Not Only SQL)系列的<strong>非关系型</strong>数据库</p><p>关系型数据库和非关系型数据库的区别：</p><ul><li>关系型数据库： <ol><li>数据之间有关联关系（外键）</li><li>数据存储在硬盘上（查询速度相对慢）</li></ol></li><li>非关系型数据库 <ol><li>数据之间没有关联关系。key-value形式</li><li>数据存储在内存中（查询速度相对快）</li></ol></li><li>一般会将数据存储到关系型数据库中，在nosql数据库中备份存储关系型数据库中的数据</li></ul><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><ul><li>redis存储的是key，value形式，其中key都是字符串，value有5种不同的数据结构</li><li>字符串类型 string <ul><li>存储：<code>set key value</code>。如果key同名，则覆盖</li><li>获取：<code>get key</code>。如果key不存在，返回<code>(nil)</code></li><li>删除：<code>del key</code></li></ul></li><li>哈希类型 hash（Map格式） <ul><li>存储一个键值对：<code>hset key field value</code></li><li>获取指定field对应的值：<code>hget key field</code>。如果key不存在，返回<code>(nil)</code></li><li>获取所有的field和value：<code>hgetall key</code>。如果key不存在，返回<code>(empty list or set)</code></li><li>删除：<code>hdel key field</code></li></ul></li><li>列表类型 list（LinkedList格式）可以添加一个元素到列表的头部或尾部 <ul><li>将元素添加到列表左边：<code>lpush key value</code></li><li>将元素添加到列表右边：<code>rpush key value</code></li><li>范围获取：<code>lrange key start end</code></li><li>获取所有：<code>lrange key 0 -1</code></li><li>删除列表最左边的元素，并将元素返回：<code>lpop key</code></li><li>删除列表最右边的元素，并将元素返回：<code>rpop key</code></li></ul></li><li>集合类型 set（不允许重复）（HashSet格式） <ul><li>存储：<code>sadd key value</code>。存储成功返回1，存储失败（重复）返回0</li><li>获取set集合中所有元素：<code>smembers key</code></li><li>删除：<code>srem key value</code></li></ul></li><li>有序集合类型 sortedset（不允许重复且自动排序） <ul><li>存储数据及其对应的分数：<code>zdd key score value</code> 排序是按分数从小到大排</li><li>覆盖元素分数：<code>zdd key score value</code>，返回0</li><li>获取范围元素：<code>zrange key start end</code></li><li>获取所有元素：<code>zrange key 0 -1</code></li><li>获取时携带分数：<code>zrange key 0 -1 withscores</code></li><li>删除：<code>zrem key value</code></li></ul></li></ul><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrojipmnj312q0tq4ha.jpg" alt=""></p><h2 id="通用命令" tabindex="-1"><a class="header-anchor" href="#通用命令"><span>通用命令</span></a></h2><ul><li>查询所有键：<code>keys *</code> 后面使用正则表达式，*代表所有</li><li>查询键对应的value的类型：<code>type key</code></li><li>删除指定的key，value：<code>del key</code></li></ul><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化"><span>持久化</span></a></h2><p>redis是一个内存数据库，当redis服务器重启，数据会丢失，可以将redis内存中的数据持久化保存到硬盘文件中。</p><p>redis持久化机制：</p><ol><li><p>RDB：默认方式。<strong>在一定的时间间隔内，检测key的变化情况，然后持久化数据</strong>。这种方式对性能的影响比较低。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 默认的配置：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># after 900 sec (15 min) if at least 1 key changed</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 900秒后如果有1个key被改变了 就持久化一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 900</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># after 300 sec (5 min) if at least 10 keys changed</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 300秒后如果有10个key被改变了 就持久化一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 300</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># after 60 sec if at least 10000 keys changed</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 60秒后如果有10000个key被改变了 就持久化一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 修改配置文件后servet的启动方式：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./redis-server.sh</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>AOF：日志记录方式，<strong>可以记录每一条命令的操作。可以每一次命令操作后，进行持久化</strong>。对性能影响较大。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 默认的配置</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># AOF默认关闭</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendonly</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> no</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 需要改成yes才开启AOF</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># appendfsync always 每一次操作都进行持久化</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> everysec</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 每隔一秒进行持久化（默认）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># appendfsync no		 不进行持久化</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><ul><li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li><li>聊天室在线好友列表</li><li>任务队列（秒杀、抢购）</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul><h1 id="高阶" tabindex="-1"><a class="header-anchor" href="#高阶"><span>高阶</span></a></h1><h2 id="缓存和数据库写入的先后顺序" tabindex="-1"><a class="header-anchor" href="#缓存和数据库写入的先后顺序"><span>缓存和数据库写入的先后顺序</span></a></h2><h3 id="旁路缓存策略-cache-aside-pattern" tabindex="-1"><a class="header-anchor" href="#旁路缓存策略-cache-aside-pattern"><span>旁路缓存策略(Cache Aside Pattern)</span></a></h3><p>使用方式：</p><ul><li>读：<strong>先读缓存，缓存没有的话，再去读数据库，然后取出来放入缓存中，同时返回响应</strong></li></ul><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317231719.png" alt=""></p><ul><li>写：<strong>先更新数据库，后删除缓存</strong></li></ul><hr><h4 id="为什么不在更新完数据库后-采取更新缓存的方案-而是将其删除" tabindex="-1"><a class="header-anchor" href="#为什么不在更新完数据库后-采取更新缓存的方案-而是将其删除"><span>为什么不在更新完数据库后，采取更新缓存的方案，而是将其删除？</span></a></h4><ul><li>频繁更新浪费资源。假如一个字段在一段时间内频繁进行更新，如果不删除缓存，那么要频繁去更新缓存，但是这个资源很可能只用了几次，所以造成了浪费</li><li>缓存数据计算复杂。假如缓存的数据是需要许多步骤(读取多张表)来计算出来，计算成本比较高，那么每修改一次，为了更新缓存还要再查询多张表来算一次</li><li>两种情况同时具备</li></ul><p>在这种情况下，读请求过来的时候，发现 Redis 中没有数据，就会去数据库里读取，然后写入缓存中。</p><p>这也是一种懒加载方式，<strong>只有缓存被需要的时候才会去计算</strong>。这样可以避免大量计算及频繁更新。</p><hr><h4 id="隐患-数据库更新成功-但缓存删除失败" tabindex="-1"><a class="header-anchor" href="#隐患-数据库更新成功-但缓存删除失败"><span>隐患：数据库更新成功，但缓存删除失败</span></a></h4><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232454.png" alt=""></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232442.png" alt=""></p><p><img src="https://gitee.com/ngwingbun/pic/raw/master/20210317232506.png" alt=""></p><ol><li>刚开始时数据库和缓存中的数据是一致的</li><li>在写请求过来后，数据库更新成功，而缓存删除失败。这就导致数据库中的数据是最新的，但缓存中却依然存着旧数据。</li><li>如果这时读请求过来，就会直接读取缓存中的旧数据返回了。</li></ol><h3 id="双写一致方案" tabindex="-1"><a class="header-anchor" href="#双写一致方案"><span>双写一致方案</span></a></h3><ul><li>先确保删除缓存，后更新数据库（<strong>适用于并发量不高的业务场景</strong>）</li></ul><h4 id="假如更新数据库失败" tabindex="-1"><a class="header-anchor" href="#假如更新数据库失败"><span>假如更新数据库失败</span></a></h4><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232949.png" alt=""></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232957.png" alt=""></p><p><img src="https://gitee.com/ngwingbun/pic/raw/master/20210317233006.png" alt=""></p><p>如果你的项目并发量很低的话，那这么用没毛病，很少情况下才会出现数据不一致的问题。</p><h4 id="隐患-同时有一个读请求和写请求" tabindex="-1"><a class="header-anchor" href="#隐患-同时有一个读请求和写请求"><span>隐患：同时有一个读请求和写请求</span></a></h4><p>写请求先删除Redis中的数据，然后去数据库进行更新操作。</p><p>读请求判断Redis中有没有数据，没有数据时去请求数据库，拿到数据后写入缓存中。</p><p><strong>但是写请求此时并没有更新成功，或者执行了一个事务还没有成功。</strong></p><p><strong>这样的话，读请求拿到未修改的旧数据写入缓存。过了一会儿，写请求将数据库更新成功了，那么此时缓存与库中的数据就不一致了。</strong></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234534.png" alt=""></p><ul><li>缓存延时双删策略</li></ul><p><strong>写请求过来先把 Redis缓存删掉，等数据库更新成功后，异步等待一段时间再次把缓存删掉。</strong></p><p>第二次删除redis缓存是保证更新数据库成功后redis缓存能在下一次数据查询中正确设置数据</p><p>这种方案读取速度快，但是会出现短时间的脏数据。</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234740.png" alt=""></p><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><blockquote><p>一个女孩子去门店买口红，到了门店之后被告知她想要的那个色号已经没有了。于是她要求店员去问总部还有没有货。总部发现这个色号也没有了，于是女孩子就离开了。</p><p>过了一会另一个女孩子又来了，也想要购买同一个色号，店员就又总部问了一次。如此反复。</p><p>女孩子买口红不仅需要门店帮忙查询，还需要总部也进行盘货。类似这种情况，在缓存领域有一个类似的概念叫做<strong>缓存穿透</strong></p></blockquote><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412215026.png" alt=""></p><p><strong>缓存穿透</strong>是指缓存服务器中没有缓存数据，数据库中也没有符合条件的数据，导致业务系统每次都绕过缓存服务器查询下游的数据库，缓存服务器完全失去了其应有的作用</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><h4 id="缓存空值" tabindex="-1"><a class="header-anchor" href="#缓存空值"><span>缓存空值</span></a></h4><blockquote><p>解决多次询问总部的方法比较简单，如果口红门店在帮第一个女孩子查询之后，就记录下来这个色号已经没有了，下次其他女孩再来问这个色号的时候，直接告诉她没货了。</p></blockquote><p>在缓存中，之所以会发生穿透，就是因为缓存没有对那些不存在的值得Key缓存下来，从而导致每次查询都要请求到数据库。</p><p>那么我们就<strong>可以为这些key对应的值设置为null并放到缓存中，这样再出现查询这个key 的请求的时候，直接返回null即可 。</strong></p><p>但是还需要注意的就是需要有一个<strong>失效时间</strong>，因为如果不设置失效的话，如果哪天总部有货了，门店还是当做没货的话，就会影响销量了。</p><h4 id="bloom-filter-常用" tabindex="-1"><a class="header-anchor" href="#bloom-filter-常用"><span>Bloom Filter（常用）</span></a></h4><blockquote><p>比如如果有一群人经常来门店问一些根本不存在的色号，比如五彩斑斓的黑，这些色号该品牌根本没生产过的话，店员就可以直接告诉顾客不存在就行了，也不需要惊动总部。</p></blockquote><p>很多时候，缓存穿透是因为有很多<strong>恶意流量的请求</strong>，这些请求可能随机生成很多Key来请求查询，这些<strong>肯定在缓存和数据库中都没有</strong>，那就很容易导致缓存穿透。针对类似的情况，可以使用在缓存穿透防治上常用的<strong>布隆过滤器</strong>。</p><p>布隆过滤器是一种比较巧妙的概率性数据结构，它可以告诉你数据一定不存在或可能存在，相比Map、Set、List等传统数据结构它占用<strong>内存少</strong>、<strong>结构更高效</strong></p><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><blockquote><p>有一种比较特殊的情况，那就是如果某一个热门色号的口红刚好卖完了，这时候有很多顾客同时来咨询要购买这个色号，那么门店内的多个售货员可能分别给总部打电话咨询是否有存货。</p><p>或者如果有多家门店同时卖完了，那么总部接收到的咨询量就会剧增。类似这种情况，在缓存领域有一个类似的概念叫做<strong>缓存击穿</strong></p></blockquote><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220154.png" alt=""></p><p><strong>缓存击穿</strong>是指当某一key的缓存过期时大并发量的请求同时访问此key，瞬间击穿缓存服务器直接访问数据库，让数据库处于负载的情况</p><p>场景：秒杀、大促等</p><h3 id="解决方案-1" tabindex="-1"><a class="header-anchor" href="#解决方案-1"><span>解决方案</span></a></h3><h4 id="异步定时更新" tabindex="-1"><a class="header-anchor" href="#异步定时更新"><span>异步定时更新</span></a></h4><blockquote><p>如果提前知道某一个色号比较畅销的话，那就可以定时的咨询总部是否还有存货，定时的更新库存情况就可以避免上面这种情况了。</p></blockquote><p><strong>某一个热点数据的过期时间是1小时，那么每59分钟，通过定时任务去更新这个热点key，并重新设置其过期时间</strong></p><h4 id="互斥锁-常用" tabindex="-1"><a class="header-anchor" href="#互斥锁-常用"><span>互斥锁（常用）</span></a></h4><blockquote><p>还有一种解决办法，那就是如果很多顾客咨询的是同一个色号的口红，那么就先处理第一个用户的咨询，其他同样请求的顾客先排队等待。一直到店员从总部那里获取到最新的库存信息后，就可以安排其他人继续购买了。</p></blockquote><p><strong>当Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则先阻塞</strong>。缺点：吞吐量降低</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><blockquote><p>如果门店内的多个色号的口红同时售罄了，并且门店在这个时间点刚好也不知道总部有没有库存了，这时候如果有大量顾客来到门店购物的话，就会有更多的咨询电话打到总部那里。</p><p>或者是门店突然出现问题了，不能提供服务了，很多顾客就可能自己打电话到总部咨询库存情况。类似这种情况，在缓存领域有一个类似的概念叫做<strong>缓存雪崩</strong></p></blockquote><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220622.png" alt=""></p><p><strong>缓存雪崩</strong>是指当大量缓存同时过期或缓存服务宕机，<strong>所有请求的都直接访问数据库</strong>，造成数据库高负载，影响性能，甚至数据库宕机。</p><p>场景：微博热搜</p><h3 id="解决方案-2" tabindex="-1"><a class="header-anchor" href="#解决方案-2"><span>解决方案</span></a></h3><h4 id="不同的过期时间" tabindex="-1"><a class="header-anchor" href="#不同的过期时间"><span>不同的过期时间</span></a></h4><blockquote><p>为了避免缓存雪崩，门店可以考虑给不同的色号的口红预留不同的库存，并且采用不同的频率咨询总部库存情况，更新到门店中。这样就可以避免突然同一个时间点所有色号都售罄。</p></blockquote><p><strong>为了避免大量的缓存在同一时间过期，可以把不同的key过期时间设置成不同的， 并且通过定时刷新的方式更新过期时间</strong></p><h4 id="集群-常用" tabindex="-1"><a class="header-anchor" href="#集群-常用"><span>集群（常用）</span></a></h4><blockquote><p>为了避免门店出问题导致大量顾客直接打电话到总部，可以考虑开更多的门店，将用户分流到多个店铺中</p></blockquote><p><strong>在缓存雪崩问题防治上面，一个比较典型的技术就是采用集群方式部署，使用集群可以避免服务单点故障</strong></p>`,89)])])}const c=i(l,[["render",t]]),r=JSON.parse('{"path":"/writings/archive/Redis.html","title":"基础知识","lang":"zh-CN","frontmatter":{"description":"基础知识 概念：redis是一款高效的NoSQL(Not Only SQL)系列的非关系型数据库 关系型数据库和非关系型数据库的区别： 关系型数据库： 数据之间有关联关系（外键） 数据存储在硬盘上（查询速度相对慢） 非关系型数据库 数据之间没有关联关系。key-value形式 数据存储在内存中（查询速度相对快） 一般会将数据存储到关系型数据库中，在no...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基础知识\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrojipmnj312q0tq4ha.jpg\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317231719.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232454.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232442.png\\",\\"https://gitee.com/ngwingbun/pic/raw/master/20210317232506.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232949.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232957.png\\",\\"https://gitee.com/ngwingbun/pic/raw/master/20210317233006.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234534.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234740.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412215026.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220154.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220622.png\\"],\\"dateModified\\":\\"2022-07-30T16:21:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/archive/Redis.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"基础知识"}],["meta",{"property":"og:description","content":"基础知识 概念：redis是一款高效的NoSQL(Not Only SQL)系列的非关系型数据库 关系型数据库和非关系型数据库的区别： 关系型数据库： 数据之间有关联关系（外键） 数据存储在硬盘上（查询速度相对慢） 非关系型数据库 数据之间没有关联关系。key-value形式 数据存储在内存中（查询速度相对快） 一般会将数据存储到关系型数据库中，在no..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrojipmnj312q0tq4ha.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-30T16:21:52.000Z"}],["meta",{"property":"article:modified_time","content":"2022-07-30T16:21:52.000Z"}]]},"git":{"createdTime":1657786542000,"updatedTime":1659198112000,"contributors":[{"name":"wuyingbin","username":"wuyingbin","email":"yb.ng@foxmail.com","commits":1,"url":"https://github.com/wuyingbin"},{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":2,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":11.24,"words":3371},"filePathRelative":"writings/archive/Redis.md","autoDesc":true}');export{c as comp,r as data};
