import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-859571d0.js";const p={},t=e(`<h1 id="mysql-分页查询" tabindex="-1"><a class="header-anchor" href="#mysql-分页查询" aria-hidden="true">#</a> MySQL 分页查询</h1><blockquote><p>在业务中，分页查询还是较为常用的，特别是数据量大时，分页查询能有效提高执行效率，也能降低网络传输的资源消耗</p></blockquote><h2 id="业务引入" tabindex="-1"><a class="header-anchor" href="#业务引入" aria-hidden="true">#</a> 业务引入</h2><p>现在有一张订单表，结构大致是这样</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>user_name<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39; 用户名&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>create_time<span class="token punctuation">\`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;发生时间&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>price<span class="token punctuation">\`</span></span> <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;价格&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>idx_user_name<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>user_name<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>id</code> 是主键，在 <code>user_name</code> 字段上建了一个普通索引，并且模拟了 20000 条数据</p><p>现在需要进行分页查询，每页 10 条</p><p>查询第 1 页的 SQL 语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查询第 1000 页的 SQL 语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">9990</span><span class="token punctuation">,</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="分页查询原理" tabindex="-1"><a class="header-anchor" href="#分页查询原理" aria-hidden="true">#</a> 分页查询原理</h2><p>简单回顾 MySQL 执行查询语句的流程</p><p>当客户端连接到 MySQL 服务端后，经过一系列的分析优化，最终由服务层的执行器调用存储引擎的数据读取的接口并返回数据</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617143115.png" alt=""></p><p>其中决定 SQL 语句如何执行的地方在优化器，优化器会选择开销最小的执行计划最终提交给存储引擎来执行</p><h3 id="查看执行计划" tabindex="-1"><a class="header-anchor" href="#查看执行计划" aria-hidden="true">#</a> 查看执行计划</h3><p>执行计划的查看可以通过 <code>explain</code> 命令来完成</p><p>比如对查询第 1 页的 SQL 语句查看执行计划</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span> explain <span class="token keyword">select</span> * from <span class="token variable"><span class="token variable">\`</span>order<span class="token variable">\`</span></span> order by <span class="token function">id</span> limit <span class="token number">0</span>, <span class="token number">10</span> <span class="token punctuation">\\</span>G<span class="token punctuation">;</span>
*************************** <span class="token number">1</span>. row ***************************
           id: <span class="token number">1</span>
  select_type: SIMPLE
        table: order
   partitions: NULL
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: <span class="token number">4</span>
          ref: NULL
         rows: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: NULL
<span class="token number">1</span> row <span class="token keyword">in</span> set, <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看执行计划中 <code>key</code> 这一项，显示的是 <code>PRIMARY</code> ，也就是走的主键索引</p><p>使用主键索引：从 B+ 树上查询具体的叶子节点并<strong>获取叶子节点上的完整行数据信息</strong></p><h2 id="分页查询隐藏的问题" tabindex="-1"><a class="header-anchor" href="#分页查询隐藏的问题" aria-hidden="true">#</a> 分页查询隐藏的问题</h2><p>查看完执行计划后，发现这个查询是相当高效的，因为使用了主键索引，所以可以直接执行</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">9990</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两条 SQL 语句执行出来的结果也和我们的需求一致，似乎已经没什么问题的</p><p><strong>但是，SQL 语句执行的过程真的和我们想象的一样吗？</strong></p><p><strong>实际上，<code>limit</code> 子句是服务层返回给客户端之前才去执行的</strong>，而执行器在调用 innodb 存储引擎的查询接口时，存储引擎是<strong>返回了第 1 条到 (offset + size) 条完整行数据的</strong></p><p>如果查询第 1 页的数据，那么是返回第 1 条到第 10 条的数据给服务层，咋一看没问题</p><p>如果查询第 1000 页的数据，那么是返回第 1 条到第 10000 条的数据给服务层，<strong>服务层再把第 9991 条之前的数据逐一抛弃，最终留下 10 条返回给客户端</strong></p><p>显然当 offset 不为 0 时，服务层会从存储引擎层中获取许多无用的数据，而获取、抛弃这个过程也是需要耗时的</p><p>如果不是用主键索引来排序，使用普通索引来排序，时间的差距可能会更大</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span> explain <span class="token keyword">select</span> * from <span class="token variable"><span class="token variable">\`</span>order<span class="token variable">\`</span></span> order by user_name limit <span class="token number">0</span>, <span class="token number">10</span> <span class="token punctuation">\\</span>G<span class="token punctuation">;</span>
*************************** <span class="token number">1</span>. row ***************************
           id: <span class="token number">1</span>
  select_type: SIMPLE
        table: order
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_user_name
      key_len: <span class="token number">1022</span>
          ref: NULL
         rows: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: NULL
<span class="token number">1</span> row <span class="token keyword">in</span> set, <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询第 1 页时，执行计划还能显示使用索引</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span> explain <span class="token keyword">select</span> * from <span class="token variable"><span class="token variable">\`</span>order<span class="token variable">\`</span></span> order by user_name limit <span class="token number">9990</span>, <span class="token number">10</span> <span class="token punctuation">\\</span>G<span class="token punctuation">;</span>
*************************** <span class="token number">1</span>. row ***************************
           id: <span class="token number">1</span>
  select_type: SIMPLE
        table: order
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: <span class="token number">20400</span>
     filtered: <span class="token number">100.00</span>
        Extra: Using filesort
<span class="token number">1</span> row <span class="token keyword">in</span> set, <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询第 1000 页时，执行计划却显示了需要做全表扫描了（ <code>type</code> = <code>ALL</code> ），并进行 <code>filesort</code></p><blockquote><p>简单分析一下为什么做全表扫描</p><p>执行查询第 1000 页的语句时，服务层应该会得出两个执行计划</p><ol><li>全表扫描</li><li>使用普通索引进行查询，并且每一条记录都要进行回表操作</li></ol><p>兴许是优化器权衡后认为做全表扫描的开销比使用普通索引后逐一回表的开销更小，于是选择了全表扫描，无论他的执行时间是否更长</p></blockquote><h2 id="分页查询优化" tabindex="-1"><a class="header-anchor" href="#分页查询优化" aria-hidden="true">#</a> 分页查询优化</h2><p>如果这时候需求就是需要使用普通索引来排序并分页查询，进行全表扫描的执行计划一定是需要被优化的</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> user_name <span class="token keyword">limit</span> <span class="token number">9990</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="b-树结构" tabindex="-1"><a class="header-anchor" href="#b-树结构" aria-hidden="true">#</a> B+ 树结构</h3><p>在开始进行优化前，我们需要先简单回顾一下 MySQL 中 innodb 存储引擎的存储结构，从数据结构中寻找可以优化的地方</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617155356.png" alt=""></p><p>普通索引：叶子节点存放索引内容和主键值</p><p>主键索引：叶子节点存放主键值和整行内容</p><p>回表：从普通索引中查询到数据对应的主键，再从主键索引中查询到完整的数据内容</p><blockquote><p>题外话：在开发中尽量少用 select * ，因为需要回表，尽量建立联合索引，并让查询的字段命中这些联合索引，因为叶子节点上就有我们所需要的值，不需要回表，这个也称为索引覆盖</p></blockquote><h3 id="拆分子查询" tabindex="-1"><a class="header-anchor" href="#拆分子查询" aria-hidden="true">#</a> 拆分子查询</h3><p>我们可以把这个使用普通索引的查询拆分成两个子查询</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">\`</span>order<span class="token punctuation">\`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> user_name <span class="token keyword">limit</span> <span class="token number">9990</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> t2 <span class="token keyword">where</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>思路：</p><ol><li>无论怎么样，都是要向服务层返回多余的前 9990 条数据的，就让返回的数据字段尽可能少，便利普通索引树，只返回主键 id</li><li>再把这 10 个 id 去订单表中查询对应的数据，此时用的是主键索引，只需要进行 10 次回表，将匹配到的 10 条数据返回</li></ol><p>这样就从一开始的全表扫描改进成使用<strong>普通索引+主键索引</strong>的方式了，省去了前 9990 条数据的回表操作，从而提升了查询效率</p><h3 id="深度分页" tabindex="-1"><a class="header-anchor" href="#深度分页" aria-hidden="true">#</a> 深度分页</h3><p>当 offset 变得很大，达到了百万、千万级别，那这个问题就非常棘手了。目前无论是 MySQL 还是 Elasticsearch 都没有很好的解决方案，只有一些减缓的手段</p><p>这是应该要反思一下这个需求为什么会出现</p><p>实际上分页查询不会一下子翻到几百万页后，所以这个需求是不合理的需求，应该修改需求使其更接近真实用户的行为</p><p>假如可以做成不支持跳页，只支持上一页或下一页的跳转，这样可以做分批获取数据的方式，也称“瀑布流”，这种方式速度是稳定的</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 假设是用主键自增的方式</span>
<span class="token class-name">Integer</span> startId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> data<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取数据</span>
    <span class="token comment">// select * from \`order\` where id &gt; startId order by id limit 100;</span>
    data <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>startId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 数据取完了已经，遍历结束</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 处理数据</span>
    <span class="token function">handle</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新startId</span>
    startId <span class="token operator">=</span> <span class="token function">getMaxId</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样每次都是稳定地往下取 100 条数据，直至查询停止</p><h2 id="导出数据时分页查询" tabindex="-1"><a class="header-anchor" href="#导出数据时分页查询" aria-hidden="true">#</a> 导出数据时分页查询</h2><p>在分页查询时尽量不要做连接查询，会降低性能。应该处理成两份查询，第一份查询是查询外键对应的数据，另一份查询是主体的分页查询，在分页查询中只查询其本身。</p><p>然后在程序中把主体于外键对应的冗余字段做拼接，在外面一次性查出来放到 Map 里面(推荐使用@MapKey注解)，然后在遍历主体集合的时候根据外键从 Map 中获取对应的数据。一个宗旨：<strong>少发查询 SQL , 才能更快的查询出来</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 把公司数据查询出来放到一个Map集合中，key为公司主键，value为公司数据</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Company</span><span class="token punctuation">&gt;</span></span> companyMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>companyService<span class="token punctuation">.</span><span class="token function">getMap</span><span class="token punctuation">(</span>companyQueryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 分页循环开始</span>
	<span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>当前页码<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 分页查询员工数据</span>
	<span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> pageResult <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">page</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> employeeQueryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 把公司数据设置到员工数据中</span>
	pageResult<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>employee <span class="token operator">-&gt;</span> employee<span class="token punctuation">.</span><span class="token function">setCompany</span><span class="token punctuation">(</span>companyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getCompanyId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分页循环结束</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,64),o=[t];function c(l,i){return s(),a("div",null,o)}const d=n(p,[["render",c],["__file","MySQL-paging-query.html.vue"]]);export{d as default};
