import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as l}from"./app-Bow4eu0W.js";const e={},n=l(`<h1 id="mysql-语句执行流程-server-层" tabindex="-1"><a class="header-anchor" href="#mysql-语句执行流程-server-层"><span>MySQL 语句执行流程- Server 层</span></a></h1><blockquote><p>如果想深入地学习 MySQL ，那么应该从宏观的架构上面着手，这一篇我们学习 MySQL 的整体架构及语句执行流程之 Server 层</p></blockquote><h2 id="mysql-整体架构" tabindex="-1"><a class="header-anchor" href="#mysql-整体架构"><span>MySQL 整体架构</span></a></h2><p>整体上来说 MySQL 服务端可以分成两层</p><ul><li>Server 层：负责 SQL 语句层面的处理，解析、优化等</li><li>存储引擎层：负责数据的存储与读取，不同的存储引擎有不同的数据存储与查询的手段，存储引擎层给 Server 层提供了统一的接口访问数据</li></ul><h2 id="mysql-server-层架构图" tabindex="-1"><a class="header-anchor" href="#mysql-server-层架构图"><span>MySQL Server 层架构图</span></a></h2><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230226231234.png" alt=""></p><h2 id="连接处理器" tabindex="-1"><a class="header-anchor" href="#连接处理器"><span>连接处理器</span></a></h2><p>连接处理器主要处理客户端的连接是否正确，是否具有相应数据操作的权限</p><h2 id="解析器" tabindex="-1"><a class="header-anchor" href="#解析器"><span>解析器</span></a></h2><p>解析器的作用是对客户端传来的 SQL 语句进行以下工作：</p><ul><li>语法解析：检查 SQL 语句的语法，括号、引号是否闭合等</li><li>词法解析：把 SQL 语句中的关键词、表名、字段名拆分成一个个节点，最终得到一颗解析树</li></ul><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230106114601.png" alt=""></p><h2 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器"><span>预处理器</span></a></h2><p>解析器主要是检查语法词法方面，但是如果语法词法都正确，但是表、字段是不存在的，那么这段 SQL 语句也是无法正确执行的。</p><p>所以预处理器的作用是：<strong>语义解析</strong>，<strong>判断解析树的语义是否正确，表、字段这些是否存在</strong>，预处理后会得到一颗新的解析树。</p><h2 id="查询优化器" tabindex="-1"><a class="header-anchor" href="#查询优化器"><span>查询优化器</span></a></h2><p>查询优化器结构</p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230106162410.png" style="zoom:40%;"><p>在 MySQL 中一条 SQL 语句的执行方式有多种，虽然最终都会得到相同的结果，但是存在<strong>开销上的差异</strong>，具体选择哪一种执行方式是由查询优化器来决定的。比如说：</p><ul><li>表中有多个索引可以选择，具体选择哪一个索引</li><li>当我们对多张表进行关联查询时，以哪一张表的数据为基准表</li></ul><p><strong>查询优化器是基于开销（cost）的优化器</strong>，它的工作原理是根据解析树生成的多种执行计划，会评估各种执行方式所需的开销（cost），<strong>最终会得到一个开销最小的执行计划作为最终方案</strong>。</p><p>但是这个开销最小的执行方式不一定是最优的执行方式，比如本该使用索引，却进行了全表扫描等。虽然查询优化器中有「优化」两个字，但是这个优化并不是万能的，很多时候更加需要考虑 SQL 语句书写得是否合理。</p><h3 id="逻辑查询优化" tabindex="-1"><a class="header-anchor" href="#逻辑查询优化"><span>逻辑查询优化</span></a></h3><p>逻辑查询优化主要负责进行一些关系代数对 SQL 语句进行优化，从而使 SQL 语句执行效率更高</p><p>逻辑查询优化我们可以使用几个案例来简单理解</p><ul><li><p><strong>子查询合并</strong></p><p>合并前</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	EXISTS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">a2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">OR</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	EXISTS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">a2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>合并后</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	EXISTS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">a2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> OR</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">b2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把多个子查询通过合并查询条件而合并查询，把多次连接操作减少为单次表扫描和单次连接</p></li><li><p><strong>等价谓词重写</strong></p><p>像我们熟悉的 <strong>like 模糊查询，% 写在条件后面才会进行索引范围查询，其实这是查询优化器的功劳</strong></p><p>假设使用的条件都是有建立索引的，重写前</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> USERINFO </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LIKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Abc%&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>重写后</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> USERINFO </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &gt;=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Abc&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Abd&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这就是为什么能进行索引范围查询的答案</p></li><li><p><strong>条件简化</strong></p><p>条件简化也是利用一些等式、代数关系来实现简化</p><ul><li><strong>去除表达式中的冗余括号</strong>，减少语法分析时产生的AND和OR 树的层 次，比如 <code>((a AND b) AND (c AND d))</code> 简化为 <code>a AND b AND c AND d</code></li><li><strong>常量传递</strong>，比如 <code>col1 = col2 AND col2 = 3</code> 简化为 <code>col1 = 3 AND col2 = 3</code></li><li><strong>表达式计算</strong>，对于一些可直接求解的表达式会转换为最终的计算结果，比如 <code>col1 = 1+2</code> 简化为 <code>col1 = 3</code></li></ul></li></ul><h3 id="物理查询优化" tabindex="-1"><a class="header-anchor" href="#物理查询优化"><span>物理查询优化</span></a></h3><p>物理查询优化主要做的工作是根据 SQL 语句分别对多种执行计划进行开销的评估</p><p>物理查询优化主要解决以下几个问题：</p><ol><li><strong>单表扫描中采用哪种方式是开销最小的（扫描索引+回表 or 全表扫描）</strong></li><li><strong>存在表连接的时候使用哪种连接方式是开销最小的</strong></li></ol><p>简单了解一下代价评估，代价评估是基于 CPU 代价和 IO 代价两个维度的</p><table><thead><tr><th>扫描方式</th><th>代价评估公式</th></tr></thead><tbody><tr><td>顺序扫描</td><td>N_page * a_page_IO_time + N_tuple * a_tuple_CPU_time</td></tr><tr><td>索引扫描</td><td>C_index + N_page_index * a_page_IO_time</td></tr></tbody></table><p>上述参数说明如下：</p><ul><li>a_page_IO_time， 一个数据页加载的IO耗时</li><li>N_page，数据页数量</li><li>N_tuple，元组数（元组理解为一行数据）</li><li>a_tuple_CPU_time，一个元组从数据页中解析的CPU耗时</li><li>C_index，索引的IO耗时</li><li>N_page_index，索引页数量</li></ul><p>关于索引成本计算可以参考这篇文章：<a href="https://blog.csdn.net/qq_34115899/article/details/120217907" target="_blank" rel="noopener noreferrer">MySQL查询为什么选择使用这个索引？——基于MySQL 8.0.22索引成本计算</a></p><h2 id="执行计划" tabindex="-1"><a class="header-anchor" href="#执行计划"><span>执行计划</span></a></h2><p>执行计划是查询优化器的产物，最终会交给存储引擎进行执行。执行计划可以帮助我们得知 MySQL 会怎么执行这条 SQL 语句。</p><p>使用 <code>explain</code> 关键字查看 SQL 语句的执行计划，可以得到以下信息：</p><ul><li>id：嵌套查询中查询的执行顺序</li><li>possible_keys：本次查询可能用到的索引</li><li>key：实际用到的索引</li><li>key_len：使用到的索引的字段长度</li><li>rows：得到结果大概要检索多少行数据</li><li>select_type多表之间的连接类型</li><li>extra：额外的信息，是否有索引覆盖、索引下推等</li></ul><h2 id="执行器与存储引擎" tabindex="-1"><a class="header-anchor" href="#执行器与存储引擎"><span>执行器与存储引擎</span></a></h2><p>执行期负责拿着查询优化器生成的执行计划，对存储引擎调用统一的数据操作接口。</p><p>MySQL 服务端规定了数据如何存储、如何提取、如何更新的规范，这个规范由存储引擎来实现，不同的存储引擎的实现方式不同，所以不同的存储引擎会呈现其独特的功能和特点。其中最常用的存储引擎是 InnoDB 和 MyISAM ，简单说说这两款存储引擎的特点</p><p>InnoDB：</p><ul><li>支持外键、事务，保证了数据的完整性和一致性</li><li>支持更细的锁粒度，对锁的控制更好，读写效率更高</li></ul><p>MyISAM</p><ul><li>不支持事务，只支持行锁，适合数据只读的场景</li></ul><blockquote><p>存储引擎方面暂时先不展开，会在其他文章继续穿插他们的对比，以及会详细分析 InnoDB 更新数据的流程</p></blockquote><h2 id="binlog" tabindex="-1"><a class="header-anchor" href="#binlog"><span>Binlog</span></a></h2><p>Binlog 是 <strong>MySQL Server 层自己维护</strong>的一个二进制日志，以事件的形式记录了所有 DDL 和 DML 语句</p><ul><li>日志写入的机制是<strong>顺序写</strong>，省去寻址时间，写入效率高</li><li>日志采用<strong>追加写</strong>的模式，一份日志文件写到一定大小会切换到下一个</li></ul><p>Binlog 中最重要的功能：数据恢复与主从同步</p><ul><li>数据恢复：因为 Binlog 记录了 DDL 和 DML 语句，可以通过 <code>mysqlbinlog</code> 工具来恢复数据</li><li>主从同步：master 结点把它的 Binlog 传递给 slave 结点，slave 根据 master 中发生过的数据修改同步修改到自己库上</li></ul><p>Binlog 开启后会有性能上的消耗，默认是关闭的，如果需要打开的话需要在 MySQL 配置文件 <code>my.cnf</code> 中的<code>mysqld</code> 区加入以下配置</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[mysqld]</span></span>
<span class="line"><span>log-bin=/data/mysql-bin #日志路径</span></span>
<span class="line"><span>binlog_format=MIXED</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Binlog 相关查询命令</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-- 查看 Binlog 的开关状态、文件目录、索引文件目录等信息</span></span>
<span class="line"><span>show variables like &#39;%log_bin%&#39;;</span></span>
<span class="line"><span>-- 查看 Binlog 文件信息</span></span>
<span class="line"><span>show binary logs;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="binlog-格式" tabindex="-1"><a class="header-anchor" href="#binlog-格式"><span>Binlog 格式</span></a></h3><ul><li>row：记录数据被修改成什么样子。但是无法记录函数执行的结果，而且如果一条修改语句修改了大量的数据行或者 alter table 时，那么日志量会很大</li><li>statement：记录执行了的 SQL 语句。减少 Binlog 日志量，节省 IO，但是可能会出现同一条 SQL 语句在 master 结点和 slave 结点上结果不一致的情况</li><li>mixed：以上两种格式混合使用，MySQL 根据 SQL 语句自己选择最优的</li></ul><p>MySQL 在事务提交时需要写入 Binlog，这一点在介绍存储引擎层时再详细地介绍</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>从前，只知道在客户端软件上写下 SQL 语句，点击执行，拿到数据</p><p>到现在终于了解到一条查询语句传入 MySQL 服务端后需要经历这一系列的操作</p><ol><li>解析器根据这条 SQL 语句的语法、词法进行检查，如果没有错误的话会按关键词拆分成一个个节点，最终形成一棵解析树</li><li>预处理器会检查 SQL 语句的语义，检查 SQL 语句是否有歧义、字段等是否存在，形成一棵新的解析树</li><li>查询优化器拿到这个解析树生成的各种执行计划，经过逻辑查询优化、物理查询优化后得到一个开销最小的执行计划</li><li>执行器拿到这份执行计划调用存储引擎的接口</li><li>存储引擎根据执行计划进行数据查询，查询会查询调用操作系统中文件系统的一些接口，完成数据查询，最后返回给客户端</li></ol><p>以上就是 SQL 语句在 MySQL 的 Server 层流转的整体流程。</p>`,65),t=[n];function h(p,r){return a(),s("div",null,t)}const g=i(e,[["render",h],["__file","MySQL-process-Server.html.vue"]]),o=JSON.parse('{"path":"/writings/MySQL/MySQL-process-Server.html","title":"MySQL 语句执行流程- Server 层","lang":"zh-CN","frontmatter":{"title":"MySQL 语句执行流程- Server 层","icon":"article","category":["数据库","文章"],"tag":["MySQL","原理"],"description":"MySQL 语句执行流程- Server 层 如果想深入地学习 MySQL ，那么应该从宏观的架构上面着手，这一篇我们学习 MySQL 的整体架构及语句执行流程之 Server 层 MySQL 整体架构 整体上来说 MySQL 服务端可以分成两层 Server 层：负责 SQL 语句层面的处理，解析、优化等 存储引擎层：负责数据的存储与读取，不同的存储...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/MySQL/MySQL-process-Server.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"MySQL 语句执行流程- Server 层"}],["meta",{"property":"og:description","content":"MySQL 语句执行流程- Server 层 如果想深入地学习 MySQL ，那么应该从宏观的架构上面着手，这一篇我们学习 MySQL 的整体架构及语句执行流程之 Server 层 MySQL 整体架构 整体上来说 MySQL 服务端可以分成两层 Server 层：负责 SQL 语句层面的处理，解析、优化等 存储引擎层：负责数据的存储与读取，不同的存储..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230226231234.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"原理"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 语句执行流程- Server 层\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230226231234.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230106114601.png\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"MySQL 整体架构","slug":"mysql-整体架构","link":"#mysql-整体架构","children":[]},{"level":2,"title":"MySQL Server 层架构图","slug":"mysql-server-层架构图","link":"#mysql-server-层架构图","children":[]},{"level":2,"title":"连接处理器","slug":"连接处理器","link":"#连接处理器","children":[]},{"level":2,"title":"解析器","slug":"解析器","link":"#解析器","children":[]},{"level":2,"title":"预处理器","slug":"预处理器","link":"#预处理器","children":[]},{"level":2,"title":"查询优化器","slug":"查询优化器","link":"#查询优化器","children":[{"level":3,"title":"逻辑查询优化","slug":"逻辑查询优化","link":"#逻辑查询优化","children":[]},{"level":3,"title":"物理查询优化","slug":"物理查询优化","link":"#物理查询优化","children":[]}]},{"level":2,"title":"执行计划","slug":"执行计划","link":"#执行计划","children":[]},{"level":2,"title":"执行器与存储引擎","slug":"执行器与存储引擎","link":"#执行器与存储引擎","children":[]},{"level":2,"title":"Binlog","slug":"binlog","link":"#binlog","children":[{"level":3,"title":"Binlog 格式","slug":"binlog-格式","link":"#binlog-格式","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1672997399000,"updatedTime":1677655655000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1},{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":8.36,"words":2509},"filePathRelative":"writings/MySQL/MySQL-process-Server.md","localizedDate":"2023年1月6日","autoDesc":true}');export{g as comp,o as data};
