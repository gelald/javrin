const e=JSON.parse('{"key":"v-8bf5c186","path":"/writings/Redis/Redis-interview.html","title":"Redis 面试突击","lang":"zh-CN","frontmatter":{"description":"Redis 面试突击 Redis 是什么 Redis 是一个基于内存的数据库，其对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等 Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Redis/Redis-interview.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"Redis 面试突击"}],["meta",{"property":"og:description","content":"Redis 面试突击 Redis 是什么 Redis 是一个基于内存的数据库，其对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等 Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-27T12:37:11.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-07-27T12:37:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 面试突击\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-27T12:37:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"Redis 是什么","slug":"redis-是什么","link":"#redis-是什么","children":[]},{"level":2,"title":"为什么选择 Redis 作为 MySQL 的缓存","slug":"为什么选择-redis-作为-mysql-的缓存","link":"#为什么选择-redis-作为-mysql-的缓存","children":[]},{"level":2,"title":"Redis 的数据类型及其使用场景","slug":"redis-的数据类型及其使用场景","link":"#redis-的数据类型及其使用场景","children":[{"level":3,"title":"String 字符串","slug":"string-字符串","link":"#string-字符串","children":[]},{"level":3,"title":"List 列表","slug":"list-列表","link":"#list-列表","children":[]},{"level":3,"title":"压缩列表","slug":"压缩列表","link":"#压缩列表","children":[]},{"level":3,"title":"ListPack","slug":"listpack","link":"#listpack","children":[]},{"level":3,"title":"QuickList","slug":"quicklist","link":"#quicklist","children":[]},{"level":3,"title":"Hash 哈希","slug":"hash-哈希","link":"#hash-哈希","children":[]},{"level":3,"title":"Set 集合","slug":"set-集合","link":"#set-集合","children":[]},{"level":3,"title":"ZSet 有序集合","slug":"zset-有序集合","link":"#zset-有序集合","children":[]},{"level":3,"title":"跳表","slug":"跳表","link":"#跳表","children":[]}]},{"level":2,"title":"Redis 线程模型","slug":"redis-线程模型","link":"#redis-线程模型","children":[{"level":3,"title":"Redis 单线程模型","slug":"redis-单线程模型","link":"#redis-单线程模型","children":[]},{"level":3,"title":"Redis 监听大量客户端连接的做法","slug":"redis-监听大量客户端连接的做法","link":"#redis-监听大量客户端连接的做法","children":[]},{"level":3,"title":"Redis 的后台线程","slug":"redis-的后台线程","link":"#redis-的后台线程","children":[]},{"level":3,"title":"Redis 6 之前为什么使用单线程","slug":"redis-6-之前为什么使用单线程","link":"#redis-6-之前为什么使用单线程","children":[]},{"level":3,"title":"Redis 6 后为什么引入多线程","slug":"redis-6-后为什么引入多线程","link":"#redis-6-后为什么引入多线程","children":[]},{"level":3,"title":"为什么 Redis 单线程性能也这么高","slug":"为什么-redis-单线程性能也这么高","link":"#为什么-redis-单线程性能也这么高","children":[]}]},{"level":2,"title":"Redis 持久化","slug":"redis-持久化","link":"#redis-持久化","children":[{"level":3,"title":"Redis 提供三种持久化策略","slug":"redis-提供三种持久化策略","link":"#redis-提供三种持久化策略","children":[]}]}],"git":{"createdTime":1690461431000,"updatedTime":1690461431000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":11.06,"words":3318},"filePathRelative":"writings/Redis/Redis-interview.md","localizedDate":"2023年7月27日","excerpt":"<h1> Redis 面试突击</h1>\\n<h2> Redis 是什么</h2>\\n<p>Redis 是一个基于内存的数据库，其对数据的读写都是在内存中完成的，因此读写速度非常快，常用于缓存、消息队列、分布式锁等</p>\\n<p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>","autoDesc":true}');export{e as data};
