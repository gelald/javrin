const e=JSON.parse('{"key":"v-672b0c17","path":"/writings/archive/HashMap.html","title":"HashMap源码学习","lang":"zh-CN","frontmatter":{"description":"HashMap源码学习 前提知识 HashMap的数据结构是：数组+链表+红黑树 数据存储形式：key-value形式；用Node对象来管理，记录了key、value、hash、next(指向下一个结点所持有的引用) 引入红黑树的目的：减少链表长度，查询/插入的效率更高","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/archive/HashMap.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"HashMap源码学习"}],["meta",{"property":"og:description","content":"HashMap源码学习 前提知识 HashMap的数据结构是：数组+链表+红黑树 数据存储形式：key-value形式；用Node对象来管理，记录了key、value、hash、next(指向下一个结点所持有的引用) 引入红黑树的目的：减少链表长度，查询/插入的效率更高"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-30T16:21:52.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2022-07-30T16:21:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap源码学习\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-07-30T16:21:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"前提知识","slug":"前提知识","link":"#前提知识","children":[]},{"level":2,"title":"put方法的执行流程","slug":"put方法的执行流程","link":"#put方法的执行流程","children":[]},{"level":2,"title":"HashMap容量调整方面的内容","slug":"hashmap容量调整方面的内容","link":"#hashmap容量调整方面的内容","children":[]},{"level":2,"title":"抛开HashMap，hash冲突有哪些解决方法","slug":"抛开hashmap-hash冲突有哪些解决方法","link":"#抛开hashmap-hash冲突有哪些解决方法","children":[]},{"level":2,"title":"多线程方面","slug":"多线程方面","link":"#多线程方面","children":[]},{"level":2,"title":"遍历","slug":"遍历","link":"#遍历","children":[{"level":3,"title":"遍历方法","slug":"遍历方法","link":"#遍历方法","children":[]},{"level":3,"title":"性能测试","slug":"性能测试","link":"#性能测试","children":[]}]},{"level":2,"title":"删除安全性测试","slug":"删除安全性测试","link":"#删除安全性测试","children":[{"level":3,"title":"重要的属性","slug":"重要的属性","link":"#重要的属性","children":[]},{"level":3,"title":"HashMap数据结构","slug":"hashmap数据结构","link":"#hashmap数据结构","children":[]},{"level":3,"title":"HashMap工作原理","slug":"hashmap工作原理","link":"#hashmap工作原理","children":[]},{"level":3,"title":"数组长度为什么是 2 的n次幂","slug":"数组长度为什么是-2-的n次幂","link":"#数组长度为什么是-2-的n次幂","children":[]},{"level":3,"title":"HashMap如何保证数组的长度是2的n次幂","slug":"hashmap如何保证数组的长度是2的n次幂","link":"#hashmap如何保证数组的长度是2的n次幂","children":[]},{"level":3,"title":"当两个对象的 hashCode 相同会发生什么","slug":"当两个对象的-hashcode-相同会发生什么","link":"#当两个对象的-hashcode-相同会发生什么","children":[]},{"level":3,"title":"为什么要重写hashCode和equals方法","slug":"为什么要重写hashcode和equals方法","link":"#为什么要重写hashcode和equals方法","children":[]},{"level":3,"title":"有没有重写过hashCode和equals方法","slug":"有没有重写过hashcode和equals方法","link":"#有没有重写过hashcode和equals方法","children":[]},{"level":3,"title":"hash方法原理","slug":"hash方法原理","link":"#hash方法原理","children":[]},{"level":3,"title":"确定索引的原理","slug":"确定索引的原理","link":"#确定索引的原理","children":[]},{"level":3,"title":"put方法执行流程","slug":"put方法执行流程","link":"#put方法执行流程","children":[]},{"level":3,"title":"扩容方法执行流程","slug":"扩容方法执行流程","link":"#扩容方法执行流程","children":[]},{"level":3,"title":"get方法执行流程","slug":"get方法执行流程","link":"#get方法执行流程","children":[]},{"level":3,"title":"remove方法执行流程","slug":"remove方法执行流程","link":"#remove方法执行流程","children":[]},{"level":3,"title":"HashMap 的 table 的容量如何确定？loadFactor 是什么？该容量如何变化？这种变化会带来什么问题？","slug":"hashmap-的-table-的容量如何确定-loadfactor-是什么-该容量如何变化-这种变化会带来什么问题","link":"#hashmap-的-table-的容量如何确定-loadfactor-是什么-该容量如何变化-这种变化会带来什么问题","children":[]},{"level":3,"title":"modCount属性的理解","slug":"modcount属性的理解","link":"#modcount属性的理解","children":[]},{"level":3,"title":"红黑树的见解","slug":"红黑树的见解","link":"#红黑树的见解","children":[]},{"level":3,"title":"链地址法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？","slug":"链地址法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树","link":"#链地址法导致的链表过深问题为什么不用二叉查找树代替-而选择红黑树-为什么不一直使用红黑树","children":[]},{"level":3,"title":"jdk1.8对HashMap做了哪些改变","slug":"jdk1-8对hashmap做了哪些改变","link":"#jdk1-8对hashmap做了哪些改变","children":[]},{"level":3,"title":"HashMap、LinkedHashMap、TreeMap有什么区别","slug":"hashmap、linkedhashmap、treemap有什么区别","link":"#hashmap、linkedhashmap、treemap有什么区别","children":[]},{"level":3,"title":"HashMap、HashTable的区别","slug":"hashmap、hashtable的区别","link":"#hashmap、hashtable的区别","children":[]},{"level":3,"title":"为什么HashMap是线程不安全的","slug":"为什么hashmap是线程不安全的","link":"#为什么hashmap是线程不安全的","children":[]},{"level":3,"title":"HashMap、ConcurrentHashMap的区别","slug":"hashmap、concurrenthashmap的区别","link":"#hashmap、concurrenthashmap的区别","children":[]},{"level":3,"title":"ConcurrentHashMap、HashTable的区别","slug":"concurrenthashmap、hashtable的区别","link":"#concurrenthashmap、hashtable的区别","children":[]},{"level":3,"title":"针对 ConcurrentHashMap 锁机制具体分析","slug":"针对-concurrenthashmap-锁机制具体分析","link":"#针对-concurrenthashmap-锁机制具体分析","children":[]},{"level":3,"title":"ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？","slug":"concurrenthashmap-在-jdk-1-8-中-为什么要使用内置锁-synchronized-来代替重入锁-reentrantlock","link":"#concurrenthashmap-在-jdk-1-8-中-为什么要使用内置锁-synchronized-来代替重入锁-reentrantlock","children":[]},{"level":3,"title":"ConcurrentHashMap 的并发度是什么","slug":"concurrenthashmap-的并发度是什么","link":"#concurrenthashmap-的并发度是什么","children":[]},{"level":3,"title":"简单介绍一下ConcurrentHashMap","slug":"简单介绍一下concurrenthashmap","link":"#简单介绍一下concurrenthashmap","children":[]}]}],"git":{"createdTime":1659198112000,"updatedTime":1659198112000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":23.35,"words":7004},"filePathRelative":"writings/archive/HashMap.md","localizedDate":"2022年7月30日","excerpt":"<h1> HashMap源码学习</h1>\\n<h2> 前提知识</h2>\\n<ul>\\n<li>\\n<p>HashMap的数据结构是：<strong>数组+链表+红黑树</strong></p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gg4n24g07uj31500jeq5e.jpg\\" alt=\\"image-20200625165758447\\"></p>\\n</li>\\n<li>\\n<p>数据存储形式：key-value形式；用Node对象来管理，记录了key、value、hash、next(指向下一个结点所持有的引用)<img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gg4wuvac6yj30x807i0tl.jpg\\" alt=\\"image-20200625223702194\\"></p>\\n</li>\\n<li>\\n<p>引入红黑树的目的：减少链表长度，查询/插入的效率更高</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
