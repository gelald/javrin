const e=JSON.parse('{"key":"v-73902d7e","path":"/writings/pattern/design-pattern-summary.html","title":"设计模式总结","lang":"zh-CN","frontmatter":{"title":"设计模式总结","icon":"article","category":["设计模式"],"description":"设计模式 最重要的目的：解耦 开发时区分开，运行时合并用 创建型 简单来说目的就是new对象的 对类的实例化进行了抽象，能够使软件模块做到与对象的创建和代码组织无关 结构型 简单来说是用于控制代码组成结构的、代码的表现形式 描述类和对象之间如何进行有效的组织，以形成良好的软件体系结构，主要的方式是使用继承方式来组织各个类 行为型 简单来说是用于控制逻辑的 描述类和对象之间如何交互以及如何分配职责","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/pattern/design-pattern-summary.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"设计模式总结"}],["meta",{"property":"og:description","content":"设计模式 最重要的目的：解耦 开发时区分开，运行时合并用 创建型 简单来说目的就是new对象的 对类的实例化进行了抽象，能够使软件模块做到与对象的创建和代码组织无关 结构型 简单来说是用于控制代码组成结构的、代码的表现形式 描述类和对象之间如何进行有效的组织，以形成良好的软件体系结构，主要的方式是使用继承方式来组织各个类 行为型 简单来说是用于控制逻辑的 描述类和对象之间如何交互以及如何分配职责"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"创建型","slug":"创建型","link":"#创建型","children":[]},{"level":2,"title":"结构型","slug":"结构型","link":"#结构型","children":[]},{"level":2,"title":"行为型","slug":"行为型","link":"#行为型","children":[]},{"level":2,"title":"各设计模式间对比","slug":"各设计模式间对比","link":"#各设计模式间对比","children":[{"level":3,"title":"策略模式 vs 委派模式","slug":"策略模式-vs-委派模式","link":"#策略模式-vs-委派模式","children":[]},{"level":3,"title":"工厂方法模式 vs 抽象工厂模式","slug":"工厂方法模式-vs-抽象工厂模式","link":"#工厂方法模式-vs-抽象工厂模式","children":[]},{"level":3,"title":"中介者模式 vs 桥接模式","slug":"中介者模式-vs-桥接模式","link":"#中介者模式-vs-桥接模式","children":[]},{"level":3,"title":"委派模式 vs 代理模式","slug":"委派模式-vs-代理模式","link":"#委派模式-vs-代理模式","children":[]},{"level":3,"title":"代理模式 vs 中介者模式","slug":"代理模式-vs-中介者模式","link":"#代理模式-vs-中介者模式","children":[]},{"level":3,"title":"桥接模式 vs 适配器模式","slug":"桥接模式-vs-适配器模式","link":"#桥接模式-vs-适配器模式","children":[]},{"level":3,"title":"建造者模式 vs 工厂模式","slug":"建造者模式-vs-工厂模式","link":"#建造者模式-vs-工厂模式","children":[]},{"level":3,"title":"代理模式 vs 适配器模式","slug":"代理模式-vs-适配器模式","link":"#代理模式-vs-适配器模式","children":[]},{"level":3,"title":"适配器模式 vs 装饰器模式","slug":"适配器模式-vs-装饰器模式","link":"#适配器模式-vs-装饰器模式","children":[]},{"level":3,"title":"桥接模式 vs 组合模式","slug":"桥接模式-vs-组合模式","link":"#桥接模式-vs-组合模式","children":[]},{"level":3,"title":"策略模式 vs 模板方法模式","slug":"策略模式-vs-模板方法模式","link":"#策略模式-vs-模板方法模式","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1677655655000,"updatedTime":1677655655000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":5.43,"words":1629},"filePathRelative":"writings/pattern/design-pattern-summary.md","localizedDate":"2023年3月1日","excerpt":"<h1> 设计模式</h1>\\n<p><strong>最重要的目的：解耦</strong></p>\\n<p>开发时区分开，运行时合并用</p>\\n<h2> 创建型</h2>\\n<p>简单来说目的就是new对象的</p>\\n<p>对类的实例化进行了抽象，能够使软件模块做到与对象的创建和代码组织无关</p>\\n<h2> 结构型</h2>\\n<p>简单来说是用于控制代码组成结构的、代码的表现形式</p>\\n<p>描述类和对象之间如何进行有效的组织，以形成良好的软件体系结构，主要的方式是使用继承方式来组织各个类</p>\\n<h2> 行为型</h2>\\n<p>简单来说是用于控制逻辑的</p>\\n<p>描述类和对象之间如何交互以及如何分配职责</p>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
