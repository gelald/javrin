import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e}from"./app-859571d0.js";const t={},i=e(`<h1 id="二分法" tabindex="-1"><a class="header-anchor" href="#二分法" aria-hidden="true">#</a> 二分法</h1><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h2><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h2><ol><li><p>遍历的条件</p><ol><li><code>while(left &lt;= right)</code>；退出循环的条件是left&gt;right，需要思考最终返回left还是right</li><li><code>while(left &lt; right)</code>；退出循环的条件是left=right，只需返回left或right即可，因为是一样的值</li><li><code>while(left+1 &lt;= right)</code>；退出循环的条件是left+1=right，需要思考最终返回left还是right</li></ol><p><strong>推荐使用<code>while(left &lt; right)</code></strong></p></li><li><p>边界收缩，mid可以分到左边或者分到右边</p><ul><li><p>左边，即区间分成[left, mid]和[mid+1, right]</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>left = mid + 1;
right = mid;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>右边，即区间分成[left, mid-1]和[mid, right]</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>left = mid;
right = mid - 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><h2 id="模板" tabindex="-1"><a class="header-anchor" href="#模板" aria-hidden="true">#</a> 模板</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 注意</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 注意</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 注意</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 相关逻辑</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 注意</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      right <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment">// 注意</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 相关返回值</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h1><p>滑动窗口模式是用于在给定数组或链表中从第一个元素开始<strong>滑动一个特定大小的窗口</strong>并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210816145253.png" alt=""></p><h2 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1" aria-hidden="true">#</a> 适用场景</h2><ol><li>问题的输入是一种线性数据机构，比如链表、数组或字符串</li><li>要求寻找最长/最短的子字符串、子数组或者所需的值</li></ol><p>例子</p><ul><li>大小为 K 的子数组的最大和</li><li>带有 K 个不同字符的最长子字符串</li><li>寻找字符相同但排序不一样的字符串</li></ul><h1 id="双指针" tabindex="-1"><a class="header-anchor" href="#双指针" aria-hidden="true">#</a> 双指针</h1><p>二指针（Two Pointers）是这样一种模式：两个指针以<strong>一前一后的模式</strong>在数据结构中<strong>迭代</strong>，直到一个或两个指针达到某种特定条件</p><p>二指针通常在排序数组或链表中搜索配对时很有用；<strong>比如当你必须将一个数组的每个元素与其它元素做比较时</strong>。如果只有一个指针，必须继续在数组中循环回来才能找到答案。这种使用单个迭代器进行来回在时间和空间复杂度上都很低效——这个概念被称为「渐进分析（asymptotic analysis）」</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210816153450.png" alt=""></p><h2 id="适用场景-2" tabindex="-1"><a class="header-anchor" href="#适用场景-2" aria-hidden="true">#</a> 适用场景</h2><ol><li>处理<strong>排序数组</strong></li><li>查找满足某些约束的一组元素</li></ol><p>例子</p><ul><li>求一个排序数组的平方</li><li>求总和为零的三元组</li><li>比较包含回退（backspace）的字符串</li></ul><h1 id="快慢指针" tabindex="-1"><a class="header-anchor" href="#快慢指针" aria-hidden="true">#</a> 快慢指针</h1><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列/链表）中<strong>以不同速度移动的指针</strong></p><p>通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。<strong>只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针</strong></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210816155229.png" alt=""></p><h2 id="适用场景-3" tabindex="-1"><a class="header-anchor" href="#适用场景-3" aria-hidden="true">#</a> 适用场景</h2><ol><li>处理<strong>链表中的循环</strong>的问题</li><li>当你需要知道特定元素的位置或链表的总长度时</li></ol><p>例子</p><ul><li>链表循环</li><li>回文链表</li><li>环形数组中的循环</li></ul><h3 id="如何判断使用快慢指针而不是双指针" tabindex="-1"><a class="header-anchor" href="#如何判断使用快慢指针而不是双指针" aria-hidden="true">#</a> 如何判断使用快慢指针而不是双指针</h3><ul><li>在不能反向移动的单链链表中，不适合使用双指针，因为双指针是需要一个一前一后的模式</li><li>如果是想确定一个链表是否是回文时，需要使用快慢指针</li><li>双指针常用于数组、快慢指针常用于链表</li></ul><h1 id="广度优先搜索" tabindex="-1"><a class="header-anchor" href="#广度优先搜索" aria-hidden="true">#</a> 广度优先搜索</h1><p>广度优先搜索（Breadth first search, BFS）</p><h1 id="深度优先搜索" tabindex="-1"><a class="header-anchor" href="#深度优先搜索" aria-hidden="true">#</a> 深度优先搜索</h1><p>深度优先搜索（Depth first search, DFS）</p>`,35),l=[i];function p(o,c){return a(),s("div",null,l)}const u=n(t,[["render",p],["__file","Algorithm.html.vue"]]);export{u as default};
