import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as i,a as s}from"./app-ztW5o0ZG.js";const a={},l=s('<h1 id="mysql-索引" tabindex="-1"><a class="header-anchor" href="#mysql-索引"><span>MySQL 索引</span></a></h1><blockquote><p>MySQL 的索引是一种帮助 MySQL 高效获取数据的结构。由于磁盘 IO 比较耗时，所以 MySQL 通过建立索引来减少磁盘 IO 的次数进而提升查询数据的效率。<strong>通过索引缩小获取数据的范围，减少数据筛选的过程的时间消耗</strong>。</p></blockquote><h2 id="索引结构探索" tabindex="-1"><a class="header-anchor" href="#索引结构探索"><span>索引结构探索</span></a></h2><p>选择一种适合 MySQL 的索引结构，如何选择结构使得查询用最少的磁盘 IO 次数，获得目标数据。顺序查询在数据量大的时候显然是不合适的，需要寻找其他合适的结构。</p><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener noreferrer">Data Structure Visualization (usfca.edu)</a> 这个链接可以进行各种数据结构的可视化</p></blockquote><h3 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表"><span>哈希表</span></a></h3><p>优势：哈希表可以快速查询，查询效率高</p><p>劣势：当出现大量重复键时，存在哈希冲突；数据排序、模糊查询难以实现</p><h3 id="二叉查找树" tabindex="-1"><a class="header-anchor" href="#二叉查找树"><span>二叉查找树</span></a></h3><p>优势：规定了左子树上的所有节点都小于根节点，右子树上的所有节点都大于根节点，所以可以使用二分查找提高效率</p><p>劣势：在极端情况下会退化成单向链表，查询效率低</p><p><strong>二叉查找树不适合作为索引的结构</strong></p><h3 id="平衡二叉查找树-avl-tree" tabindex="-1"><a class="header-anchor" href="#平衡二叉查找树-avl-tree"><span>平衡二叉查找树（AVL Tree）</span></a></h3><p>优势：规定了左子树和右子树的高度差值不能大于 1，差值超出 1 时树会进行自平衡，避免了出现退化成单向链表的情况</p><p>劣势：由于结点的度太少，导致数据量非常大的时候，树深度会变得很深，深度越深，磁盘 IO 次数越多，效率越低</p><p><strong>平衡二叉查找树也不适合作为索引的结构</strong></p><h3 id="多路平衡查找树-b-tree" tabindex="-1"><a class="header-anchor" href="#多路平衡查找树-b-tree"><span>多路平衡查找树（B Tree）</span></a></h3><p>前两个结构的核心问题点就是树的深度，树的深度和磁盘 IO 次数息息相关</p><p>B Tree 最大的特点是一个节点的度数 = 一个节点的关键字数 + 1，关键字数越多，度越多，树深度越小，IO 次数越少</p><p>B Tree 结构图（假设最大度数为 3 ）：</p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230112154202.png" style="zoom:50%;"><h4 id="b-tree-工作原理" tabindex="-1"><a class="header-anchor" href="#b-tree-工作原理"><span>B Tree 工作原理</span></a></h4><p>B Tree 一个节点存储多个关键字，是通过分裂、合并这两种方式来保证树的平衡性的</p><ul><li><p>分裂：当一个节点的关键字数量等于最大度数时，节点需要分裂来保证平衡</p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230112155002.png" style="zoom:50%;"></li><li><p>合并：当一个节点发生分裂而产生一个父级节点，且原父级节点已有关键字，那么这两个节点可以根据不超过最大度数的规则来合并称为一个父级节点</p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230112155705.png" style="zoom:50%;"></li></ul><h4 id="b-tree-在-mysql-中的实现" tabindex="-1"><a class="header-anchor" href="#b-tree-在-mysql-中的实现"><span>B Tree 在 MySQL 中的实现</span></a></h4><p>B Tree 中的节点，在 MySQL 中代表的是 Page 数据页</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230113214705.png" alt=""></p><p>优势：B Tree 解决了 AVL Tree 只有两个度的问题，B Tree 的节点可以有很多的度，能有效解决数据量大的时候树深度过深导致磁盘 IO 次数过多的问题。</p><p>劣势：B Tree 在数据插入与删除的时候，会破坏 B Tree 自身的平衡，不得不使用合并与分裂来保证平衡，由于 B Tree 节点不仅存储索引也存储数据区，所以导致合并、分裂结点的操作效率不高，在节点数量较多的情况下性能影响大；并且所有节点都存储数据，会导致数据查询的时间不稳定。</p><h3 id="加强版多路平衡查找树-b-tree" tabindex="-1"><a class="header-anchor" href="#加强版多路平衡查找树-b-tree"><span>加强版多路平衡查找树（B+ Tree）</span></a></h3><p>MySQL 中 InnoDB 没有直接使用 B Tree，而是对 B Tree 做了强化，使用了一种 B+ Tree 的结构来存储索引</p><p>B+ Tree 的结构图：</p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230113214156.png" style="zoom:50%;"><h4 id="b-tree-的工作原理" tabindex="-1"><a class="header-anchor" href="#b-tree-的工作原理"><span>B+ Tree 的工作原理</span></a></h4><p>为了保证树的平衡性，B+ Tree 也像 B Tree 一样采用了分裂、合并的操作来保证自身平衡</p><p>此外每一个叶子结点都有一个指向相邻叶子结点的指针，形成一个有序链表</p><h4 id="b-tree-在-mysql-中的实现-1" tabindex="-1"><a class="header-anchor" href="#b-tree-在-mysql-中的实现-1"><span>B+ Tree 在 MySQL 中的实现</span></a></h4><p>B+ Tree 中的节点，在 MySQL 中代表的是 Page 数据页，所以 B+ Tree 中一个节点的大小是 16 KB，非叶子结点存储索引数据和下一个结点的地址，因此B+ Tree 的深度和度数由索引数据大小来决定</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230112161207.png" alt=""></p><p>B+ Tree 特点：</p><ol><li>B+ Tree 节点的关键字和度数的关系是 1 : 1</li><li>B+ Tree 节点的数据检索规则变成了左闭右开的规则</li><li>B+ Tree 只有叶子结点存储数据，其他节点都只存储关键字索引</li><li>B+ Tree 的叶子结点都会有指向上一个和下一个叶子结点的指针，形成一个有序双向链表，方便做区间查询</li></ol><h3 id="b-tree-和-b-tree-区别" tabindex="-1"><a class="header-anchor" href="#b-tree-和-b-tree-区别"><span>B+ Tree 和 B Tree 区别</span></a></h3><ol><li>存储内容：B Tree 所有节点都存储索引和数据，B+ Tree 只有叶子结点才存储数据，非叶子结点只存储索引关键字</li><li>搜索规则：B Tree 的子树区间时不包含关键字的，B+ Tree 是左闭右开区间。是因为 B+ Tree 中的非叶子结点不存储数据，数据都在叶子结点中</li><li>B+ 树的叶子结点是顺序排列的，使得全表扫描时的效率会更高</li></ol><h3 id="为什么-mysql-选择-b-tree-作为索引的存储结构" tabindex="-1"><a class="header-anchor" href="#为什么-mysql-选择-b-tree-作为索引的存储结构"><span>为什么 MySQL 选择 B+ Tree 作为索引的存储结构</span></a></h3><p><strong>最根本的考虑一定是性能</strong></p><ol><li>扫表能力更强，对 B+ Tree 进行全表扫描时，只需要扫描存储数据的叶子结点，不需要遍历整棵树的结点</li><li>排序能力更强，因为 B+ Tree 上的叶子结点有指向上一个和下一个叶子结点的指针，数据形成一个有序链表</li><li>查询效率更稳定，因为 B+ Tree 只有叶子结点存储了数据，所以磁盘 IO 次数是稳定的；而 B Tree 每一个节点都存储数据，查询的 IO 次数会不稳定</li><li>度数更多，B+ Tree 的结点不需要存储数据，只需要存储索引和指针，一次加载的关键字数量更多了，所以度数更多</li></ol><h2 id="存储引擎的索引实现" tabindex="-1"><a class="header-anchor" href="#存储引擎的索引实现"><span>存储引擎的索引实现</span></a></h2><h3 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam"><span>MyISAM</span></a></h3><p>在使用 MyISAM 存储引擎的表会分别有三个文件：<code>.sid</code>（表结构）、<code>.MYI</code>（索引）、<code>.MYD</code>（数据）</p><p>一个索引对应一棵 B+ Tree，所有的 B+ Tree 都存储在 MYI 文件这里，在 MYI 文件中找到索引值对应数据的磁盘地址后再从 MYD 文件中找到完整的数据</p><p><strong>在 MyISAM 存储引擎中，主键索引和普通索引在结构上没有区别，叶子结点统一存储的是数据的磁盘地址，只是主键索引要求关键字是唯一的</strong></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230116145439.png" alt=""></p><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb"><span>InnoDB</span></a></h3><p>在使用 InnoDB 存储引擎的表只有一个文件：<code>.idb</code>（存储索引和数据）</p><p>InnoDB 把索引划分成两大类：聚簇索引、非聚簇索引</p><ul><li>聚簇索引：聚簇索引中索引键值的逻辑顺序和表数据行的物理顺序是一致的。聚簇索引中非叶子结点存储的是索引关键字，叶子结点存储的是数据。InnoDB 中索引和数据都存储在一个文件中，是因为数据是通过聚簇索引来组织表的，InnoDB 中的主键索引就是聚簇索引。</li><li>非聚簇索引：除了聚簇索引外，其他所有索引都是非聚簇索引。非聚簇索引中的非叶子结点存储的是索引，叶子结点存储的是对应数据行的主键，因此通过非聚簇索引查询数据时需要进行回表，涉及到两次查找。</li></ul><p>InnoDB 主键索引和普通索引的结构，以及查询数据的检索路线：</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230116154959.png" alt=""></p><h2 id="mysql-索引分类" tabindex="-1"><a class="header-anchor" href="#mysql-索引分类"><span>MySQL 索引分类</span></a></h2><ul><li>PRIMARY KEY（主键索引）：主键</li><li>NORMAL（普通索引）：就是我们平常在字段上面建的普通索引</li><li>UNIQUE（唯一索引）：在普通索引的基础上要求字段不允许有重复值，但可以有多个 NULL 值</li><li>FULLTEXT（全文索引）：适合比较大量的数据字段，比如存储一些文章类或长文本类的数据，可以基于全文中某些关键字进行索引查询</li><li>SPATIAL（空间索引）：空间索引是对空间数据类型的字段建立的索引，常见有地理坐标数据等，研究较少</li></ul><h2 id="索引创建规则" tabindex="-1"><a class="header-anchor" href="#索引创建规则"><span>索引创建规则</span></a></h2><p>因为索引对于改善查询性能的作用是巨大的，但同时索引也会带来空间上的负担，所以想要正确地创建索引，需要遵循一定的规则。</p><ul><li><p>一般选择在 where 条件、order 排序、join 连接、group by 分组的字段上建立索引，因为这里<strong>涉及到数据的查询与排序</strong>，可以充分发挥 B+ Tree 的作用。</p></li><li><p>索引的数量不宜过多，一个表应该<strong>尽可能精简索引的数量</strong>，因为一个索引对应一棵 B+ Tree，索引太多会浪费空间，插入删除数据时可能涉及 B+ Tree 的分裂合并操作，导致更新索引树效率低。</p></li><li><p><strong>如果索引字段较长，应该建立前缀索引</strong>。因为索引字段太长会导致占用的空间太大，进行索引匹配时也需要进行更长的时间；此外 B+ Tree 上一页数据能存储的索引关键字的数量也不多，导致度数也少，进而导致 B+ Tree 的深度变得很大。前缀索引创建的计算方式：<a href="http://blog.itpub.net/30317998/viewspace-2654308/" target="_blank" rel="noopener noreferrer">mysql索引之前缀索引_ITPUB博客</a></p></li><li><p><strong>索引值应该足够稳定</strong>，频繁更新的字段不适合做索引，因为索引数据频繁地更新，B+ Tree 需要保持平衡而进行结点的分裂和合并、重新排序，这个调整的过程是需要耗费性能的。如果这一行数据插入后，索引对应的字段一直不会被修改，这种情况是最好的。</p></li><li><p><strong>索引对数据的区分度应该尽可能高</strong>，如果重复值太多（区分度太低），MySQL 会认为使用索引再回表的开销还不如直接全表扫描的开销大，反而会增加 IO 次数，往往会选择全表扫描这种方式。数据重复率越小越好，如果这一列数据都是唯一的，那么这一列加索引是最好的。比如性别这种数据就不适合加索引，区分度非常低。</p></li><li><p><strong>随机无序的值不适合做索引</strong>，比如 UUID 和身份证这种随机且无序的值，因为 B+ Tree 的索引是有序组织的，所以无序的数据插入删除也就意味着需要频繁的分裂与合并操作。</p></li><li><p><strong>如果创建组合索引，那么把区分度最高的列放在前面</strong>。因为组合索引会按照从左到右的顺序创建索引关键字，索引的匹配遵循最左匹配原则。</p></li></ul><h2 id="索引失效场景" tabindex="-1"><a class="header-anchor" href="#索引失效场景"><span>索引失效场景</span></a></h2><p>当一条 SQL 语句执行得比较慢的时候，需要去看执行计划分析原因。如果是全表扫描或者没有使用索引，那么就说明没有建立索引或者没有正确使用索引甚至是这个 SQL 语句破坏了索引的使用规则 。</p><ul><li><p>组合索引<strong>未遵循最左匹配原则</strong></p></li><li><p>索引字段<strong>区分度过低</strong>，如性别</p></li><li><p>索引列<strong>使用函数</strong>（replace、concat）、<strong>表达式</strong>（+-*/）。</p></li><li><p>索引列<strong>发生隐式转换</strong>。比如一个索引列是 varchar 类型，但是在查询时 SQL 语句中传入了 int 类型的条件，这种做法存在类型转化，会导致全表扫描。</p></li><li><p><strong>模糊查询时使用 like % 前缀</strong>。原因和 B+ Tree 索引结构有关系，索引关键字都是从左往右排布的，当前缀未知的时候，就无法定位索引关键字，因此查询时只能进行全表扫描。</p></li><li><p><strong>索引列使用 not like、!=、&lt;&gt;</strong>。和 like % 前缀一样，无法按照最左匹配原则定位索引关键字</p></li><li><p>SQL 语句中出现 <strong>or、not null、not in、not exist</strong> 等关键字</p></li></ul><h2 id="索引进阶使用" tabindex="-1"><a class="header-anchor" href="#索引进阶使用"><span>索引进阶使用</span></a></h2><h3 id="索引覆盖" tabindex="-1"><a class="header-anchor" href="#索引覆盖"><span>索引覆盖</span></a></h3><p>使用普通索引查找数据的流程是先在普通索引树上查找到数据的主键，再去主键索引树上查找对应的数据，这其中有一次回表的过程。</p><p>索引覆盖的概念是：如果需要查询的字段列只包含联合索引列中的字段，那么在普通索引树上查找到具体的索引数据后，因为结点上包含了联合索引中的多个索引数据，从这个结点上取出所需字段数据即可，无需回表。索引覆盖往往和联合索引一起使用，因为单一索引没有索引覆盖的意义。</p><p>例如，有一个联合索引 <code>index(f1, f2, f3)</code> ，此时使用这个 SQL 语句：<code>select f1, f2, f3 from table1 where f1 = &#39;a&#39;</code> ，那么只需要执行一次 B+ Tree 的树查找，不需要再次回表。</p><p>如果使用了索引覆盖，那么在执行计划中，<code>Extra</code> 列中会显示 <code>Using index</code> 。</p><h3 id="索引条件下推" tabindex="-1"><a class="header-anchor" href="#索引条件下推"><span>索引条件下推</span></a></h3><p>索引条件下推（Index Condition Push）的概念是：MySQL Server 层把与索引相关的条件下推给存储引擎层，由存储引擎层做进一步的数据筛选。核心的目标是：<strong>尽可能地使用索引条件来减少回表操作，进而减少 IO 操作</strong>。</p><h4 id="没开启索引条件下推前" tabindex="-1"><a class="header-anchor" href="#没开启索引条件下推前"><span>没开启索引条件下推前</span></a></h4><ul><li>存储引擎根据索引条件定位对应索引记录及其主键值</li><li>根据主键值去主键索引树上定位并读取完整的数据行</li><li>把数据行交给 Server 层检测是否满足 where 条件</li></ul><p>执行计划中，<code>Extra</code> 列中会显示 <code>Using where</code></p><h4 id="开启索引条件下推后" tabindex="-1"><a class="header-anchor" href="#开启索引条件下推后"><span>开启索引条件下推后</span></a></h4><ul><li>存储引擎根据索引条件定位对应对应索引记录</li><li>判断 where 语句中其他条件能否用索引记录中的列来做检查，条件不满足，则处理下一行索引记录</li><li>条件满足，使用索引中的主键值去主键索引树上定位并读取完整的数据行</li><li>把数据行交给 Server 层，Server 层检测这些数据能否满足 where 条件的其余部分</li></ul><p>执行计划中，<code>Extra</code> 列中会显示 <code>Using index condition</code></p><h4 id="相关参数" tabindex="-1"><a class="header-anchor" href="#相关参数"><span>相关参数</span></a></h4><ul><li><p>查看状态</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select @@optimizer_switch;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>-- 结果</span></span>\n<span class="line"><span>index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on,hash_join=on,subquery_to_derived=off,prefer_ordering_index=on</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>切换开关</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>set optimizer_switch=&quot;index_condition_pushdown=off&quot;;</span></span>\n<span class="line"><span>set optimizer_switch=&quot;index_condition_pushdown=on&quot;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><p>建表语句</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE `t_user` (</span></span>\n<span class="line"><span>  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span></span>\n<span class="line"><span>  `user_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;用户名&#39;,</span></span>\n<span class="line"><span>  `full_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;全名&#39;,</span></span>\n<span class="line"><span>  `age` int(11) DEFAULT &#39;18&#39; COMMENT &#39;年龄&#39;,</span></span>\n<span class="line"><span>  `updated_date` date DEFAULT NULL COMMENT &#39;更新日期&#39;,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`),</span></span>\n<span class="line"><span>  KEY `combined_key` (`user_name`,`full_name`,`age`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到创建了一个包含 3 列字段（user_name、full_name、age）的组合索引。</p><ul><li><p>使用组合索引中，第一列进行了模糊查询</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>EXPLAIN SELECT * FROM `t_user` WHERE user_name like &#39;Shannon%&#39; AND full_name = &#39;xiao ming&#39; And age = 20;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为索引匹配规则是从左到右匹配，当使用 user_name 进行模糊查询时会导致即使正确使用组合索引，存储引擎最终也只能用上其中的 user_name 这一个字段来做筛选，后面两个字段需要交给 Server 层自行筛选</p><p>使用 <code>EXPLAIN</code> 来查看执行计划，可以看到 <code>Extra</code> 列是 <code>Using Index Condition</code></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213160931.png" alt=""></p><p>如果把索引条件下推关闭的话，可以看到 <code>Extra</code> 列是 <code>Using Where</code></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161118.png" alt=""></p></li><li><p>使用了组合索引中的第一列和第三列</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>EXPLAIN SELECT * FROM `t_user` WHERE user_name = &#39;Shannon Henry&#39; AND age = 20;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>根据最左索引匹配规则，使用组合索引时必须严格按照组合索引中字段的顺序来使用，这么使用会导致存储引擎层只能使用 user_name 这个条件做筛选</p><p>使用 <code>EXPLAIN</code> 来查看执行计划，可以看到 <code>Extra</code> 列是 <code>Using Index Condition</code></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161256.png" alt=""></p><p>如果把索引条件下推关闭的话，可以看到 <code>Extra</code> 列是 <code>Using Where</code></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161335.png" alt=""></p></li></ul><p>从两个例子中我们可以看到，虽然使用索引的方式导致组合索引不奏效，但是开启索引条件下推后存储引擎还是能把索引条件用上，减少进行回表的次数，从而达到减少 IO 次数的目的。</p><p>参考链接：<a href="https://fighter3.blog.csdn.net/article/details/120199122" target="_blank" rel="noopener noreferrer">五分钟搞懂MySQL索引下推</a></p>',89),t=[l];function r(o,p){return i(),n("div",null,t)}const h=e(a,[["render",r],["__file","MySQL-index.html.vue"]]),g=JSON.parse('{"path":"/writings/MySQL/MySQL-index.html","title":"MySQL 索引学习","lang":"zh-CN","frontmatter":{"title":"MySQL 索引学习","icon":"article","category":["数据库","文章"],"tag":["MySQL","索引"],"description":"MySQL 索引 MySQL 的索引是一种帮助 MySQL 高效获取数据的结构。由于磁盘 IO 比较耗时，所以 MySQL 通过建立索引来减少磁盘 IO 的次数进而提升查询数据的效率。通过索引缩小获取数据的范围，减少数据筛选的过程的时间消耗。 索引结构探索 选择一种适合 MySQL 的索引结构，如何选择结构使得查询用最少的磁盘 IO 次数，获得目标数据...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/MySQL/MySQL-index.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"MySQL 索引学习"}],["meta",{"property":"og:description","content":"MySQL 索引 MySQL 的索引是一种帮助 MySQL 高效获取数据的结构。由于磁盘 IO 比较耗时，所以 MySQL 通过建立索引来减少磁盘 IO 的次数进而提升查询数据的效率。通过索引缩小获取数据的范围，减少数据筛选的过程的时间消耗。 索引结构探索 选择一种适合 MySQL 的索引结构，如何选择结构使得查询用最少的磁盘 IO 次数，获得目标数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230113214705.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-06T09:52:13.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"索引"}],["meta",{"property":"article:modified_time","content":"2023-03-06T09:52:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 索引学习\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230113214705.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230112161207.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230116145439.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230116154959.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213160931.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161118.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161256.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230213161335.png\\"],\\"dateModified\\":\\"2023-03-06T09:52:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"索引结构探索","slug":"索引结构探索","link":"#索引结构探索","children":[{"level":3,"title":"哈希表","slug":"哈希表","link":"#哈希表","children":[]},{"level":3,"title":"二叉查找树","slug":"二叉查找树","link":"#二叉查找树","children":[]},{"level":3,"title":"平衡二叉查找树（AVL Tree）","slug":"平衡二叉查找树-avl-tree","link":"#平衡二叉查找树-avl-tree","children":[]},{"level":3,"title":"多路平衡查找树（B Tree）","slug":"多路平衡查找树-b-tree","link":"#多路平衡查找树-b-tree","children":[]},{"level":3,"title":"加强版多路平衡查找树（B+ Tree）","slug":"加强版多路平衡查找树-b-tree","link":"#加强版多路平衡查找树-b-tree","children":[]},{"level":3,"title":"B+ Tree 和 B Tree 区别","slug":"b-tree-和-b-tree-区别","link":"#b-tree-和-b-tree-区别","children":[]},{"level":3,"title":"为什么 MySQL 选择 B+ Tree 作为索引的存储结构","slug":"为什么-mysql-选择-b-tree-作为索引的存储结构","link":"#为什么-mysql-选择-b-tree-作为索引的存储结构","children":[]}]},{"level":2,"title":"存储引擎的索引实现","slug":"存储引擎的索引实现","link":"#存储引擎的索引实现","children":[{"level":3,"title":"MyISAM","slug":"myisam","link":"#myisam","children":[]},{"level":3,"title":"InnoDB","slug":"innodb","link":"#innodb","children":[]}]},{"level":2,"title":"MySQL 索引分类","slug":"mysql-索引分类","link":"#mysql-索引分类","children":[]},{"level":2,"title":"索引创建规则","slug":"索引创建规则","link":"#索引创建规则","children":[]},{"level":2,"title":"索引失效场景","slug":"索引失效场景","link":"#索引失效场景","children":[]},{"level":2,"title":"索引进阶使用","slug":"索引进阶使用","link":"#索引进阶使用","children":[{"level":3,"title":"索引覆盖","slug":"索引覆盖","link":"#索引覆盖","children":[]},{"level":3,"title":"索引条件下推","slug":"索引条件下推","link":"#索引条件下推","children":[]}]}],"git":{"createdTime":1667639767000,"updatedTime":1678096333000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":7},{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":2}]},"readingTime":{"minutes":14.4,"words":4319},"filePathRelative":"writings/MySQL/MySQL-index.md","localizedDate":"2022年11月5日","autoDesc":true}');export{h as comp,g as data};
