const t=JSON.parse('{"key":"v-68ad4a81","path":"/writings/concurrency/is-thread-executed-in-executor.html","title":"判断线程池中的线程是否执行完毕","lang":"zh-CN","frontmatter":{"title":"判断线程池中的线程是否执行完毕","icon":"article","isOriginal":true,"category":["并发","文章"],"tag":["线程池","问题解决"],"description":"判断线程池中的线程是否执行完毕 问题引入 如果某一个线程池中执行任务都是比较重要的，我们希望这个线程池销毁前先正确执行完所有已提交的任务，有哪些方式可以进行销毁前的等待呢？ 定义线程池 private final ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor( 10,\\t\\t\\t\\t\\t\\t\\t\\t// 10个核心线程 20,\\t\\t\\t\\t\\t\\t\\t\\t// 线程池最大线程数量20个 0L, TimeUnit.SECONDS,\\t\\t\\t// 非核心线程一旦空闲，立马回收 new LinkedBlockingQueue&lt;&gt;(30)\\t// 任务队列最大容量30个任务 );","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/concurrency/is-thread-executed-in-executor.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"判断线程池中的线程是否执行完毕"}],["meta",{"property":"og:description","content":"判断线程池中的线程是否执行完毕 问题引入 如果某一个线程池中执行任务都是比较重要的，我们希望这个线程池销毁前先正确执行完所有已提交的任务，有哪些方式可以进行销毁前的等待呢？ 定义线程池 private final ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor( 10,\\t\\t\\t\\t\\t\\t\\t\\t// 10个核心线程 20,\\t\\t\\t\\t\\t\\t\\t\\t// 线程池最大线程数量20个 0L, TimeUnit.SECONDS,\\t\\t\\t// 非核心线程一旦空闲，立马回收 new LinkedBlockingQueue&lt;&gt;(30)\\t// 任务队列最大容量30个任务 );"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:46:06.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"线程池"}],["meta",{"property":"article:tag","content":"问题解决"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:46:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"判断线程池中的线程是否执行完毕\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:46:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"问题引入","slug":"问题引入","link":"#问题引入","children":[]},{"level":2,"title":"定义线程池","slug":"定义线程池","link":"#定义线程池","children":[]},{"level":2,"title":"定义线程任务","slug":"定义线程任务","link":"#定义线程任务","children":[]},{"level":2,"title":"isTerminated 方式","slug":"isterminated-方式","link":"#isterminated-方式","children":[]},{"level":2,"title":"getCompleteTaskCount 方式","slug":"getcompletetaskcount-方式","link":"#getcompletetaskcount-方式","children":[]},{"level":2,"title":"CountDownLatch 方式","slug":"countdownlatch-方式","link":"#countdownlatch-方式","children":[]}],"git":{"createdTime":1659199509000,"updatedTime":1677599166000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":2},{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":3.21,"words":962},"filePathRelative":"writings/concurrency/is-thread-executed-in-executor.md","localizedDate":"2022年7月30日","excerpt":"<h1> 判断线程池中的线程是否执行完毕</h1>\\n<h2> 问题引入</h2>\\n<p>如果某一个线程池中执行任务都是比较重要的，我们希望这个线程池销毁前先正确执行完所有<strong>已提交</strong>的任务，有哪些方式可以进行销毁前的等待呢？</p>\\n<h2> 定义线程池</h2>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">private</span> <span class=\\"token keyword\\">final</span> <span class=\\"token class-name\\">ThreadPoolExecutor</span> poolExecutor <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ThreadPoolExecutor</span><span class=\\"token punctuation\\">(</span>\\n    <span class=\\"token number\\">10</span><span class=\\"token punctuation\\">,</span>\\t\\t\\t\\t\\t\\t\\t\\t<span class=\\"token comment\\">// 10个核心线程</span>\\n    <span class=\\"token number\\">20</span><span class=\\"token punctuation\\">,</span>\\t\\t\\t\\t\\t\\t\\t\\t<span class=\\"token comment\\">// 线程池最大线程数量20个</span>\\n    <span class=\\"token number\\">0L</span><span class=\\"token punctuation\\">,</span> <span class=\\"token class-name\\">TimeUnit</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">SECONDS</span><span class=\\"token punctuation\\">,</span>\\t\\t\\t<span class=\\"token comment\\">// 非核心线程一旦空闲，立马回收</span>\\n    <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">LinkedBlockingQueue</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">30</span><span class=\\"token punctuation\\">)</span>\\t<span class=\\"token comment\\">// 任务队列最大容量30个任务</span>\\n<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{t as data};
