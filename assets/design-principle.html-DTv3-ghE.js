import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as i,a as n}from"./app-BLfEJaid.js";const l={},r=n('<h1 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则"><span>设计原则</span></a></h1><h2 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h2><p>开闭原则（Open Close Principal）定义：一个软件实体如类、模块和方法应该<strong>对扩展开放，对修改关闭</strong>，以降低代码修改的风险。</p><p>核心思想：<strong>用抽象构建框架，用实现扩展细节</strong></p><p>优点：</p><ol><li>有利于构建一个稳定的系统</li><li>提高软件系统的可复用性及可维护性</li></ol><h2 id="依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则"><span>依赖倒置原则</span></a></h2><p>依赖倒置原则（Dependence Inversion Principle）定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象</p><ol><li>抽象不应该依赖细节，细节应该依赖抽象</li><li><strong>针对接口编程，不要针对实现编程</strong></li></ol><p>核心思想：<strong>底层代码不改动，改动主要在应用层</strong></p><p>优点：</p><ol><li>可以减少类间的耦合度</li><li>提高系统稳定性</li><li>提高代码可读性和可维护性</li><li>可降低修改程序所造成的风险</li></ol><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h2><p>单一职责原则（Simple Responsibility Principle）定义：<strong>不要存在多于一个导致类变更的原因</strong></p><p>核心思想：一个类、接口、方法<strong>尽量</strong>只负责一项职责</p><p>优点：</p><ol><li>降低类的复杂度</li><li>提高类的可读性</li><li>提高系统的可维护性</li><li>降低变更引起的风险</li></ol><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h2><p>接口隔离原则（Interface Segregation Principle）定义：用<strong>多个专门的接口</strong>，而不是使用单一的总接口，客户端不应该依赖它不需要的接口</p><p>符合<strong>高内聚低耦合的思想</strong></p><p>注意：</p><ol><li>一个类对应一个类的依赖应该<strong>建立在最小的接口上</strong></li><li>建立单一接口，不要建立庞大臃肿的解耦</li><li>尽量细化接口，<strong>接口中的方法尽量少</strong></li><li>注意适度原则</li></ol><h3 id="单一职责原则与接口隔离原则对比" tabindex="-1"><a class="header-anchor" href="#单一职责原则与接口隔离原则对比"><span>单一职责原则与接口隔离原则对比</span></a></h3><p>平台支持多种登陆方式，包括微信、QQ、支付宝。现在把登陆方式都拆分成具体的微信登录、支付宝登录、QQ登录等单独的接口，这体现了单一职责原则；然后新的系统只支持微信登陆和支付宝登录，就只实现这两个接口，不支持的QQ登录接口就不依赖，这体现了接口隔离原则。<strong>先有单一职责原则再有接口隔离原则</strong></p><h2 id="迪米特法则" tabindex="-1"><a class="header-anchor" href="#迪米特法则"><span>迪米特法则</span></a></h2><p>迪米特法则（Law Of Demeter）定义：一个对象应该对其他对象保持最少的了解，又称<strong>最少知道原则</strong></p><p>核心：<strong>不要和陌生人说话</strong></p><p>出现在成员变量、方法的输入、输出参数中的类称为成员<strong>朋友类</strong></p><p>优点：降低类之间的耦合</p><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h2><p>里氏替换原则（Liskov Substitution Principle）定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</p><ul><li><strong>子类的参数列表比父类的参数列表更宽松</strong></li><li><strong>子类的返回值要比父类的返回值更加严格或相等</strong></li></ul><h2 id="合成复用原则" tabindex="-1"><a class="header-anchor" href="#合成复用原则"><span>合成复用原则</span></a></h2><p>合成复用原则（Composite &amp; Aggregate Reuse Principle）定义：<strong>尽量使用对象组合(has)、聚合(contains)，而不是继承(is)关系达到软件复用的目的</strong>。因为继承关系的依赖关系非常强，如果作为一个参数传入的话会更好</p><p>优点：使系统更加灵活，降低类与类之间的耦合度</p><p>使用场景：</p><ul><li>聚合：电脑与U盘，合成到一起可以一起工作，分开后也能独立存在，生命周期独立的个体</li><li>组合：独立的物体，合到一起之后形成一个具有相同生命周期的个体。如：人体的各个部分(手、脚)，缺一不可</li><li>继承：狗与动物，把一些特征都抽取出来放到顶层，让所有子类都具备这些特征、行为</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>不是非要遵循所有原则，只是在开发过程中<strong>尽可能地遵循</strong>，但<strong>也要联系实际情况</strong></p><table><thead><tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>减少维护带来新的风险</td></tr><tr><td>依赖倒置原则</td><td>底层不应该依赖应用层</td><td>更利于代码结构的升级和扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事</td><td>便于理解，提高代码可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事</td><td>功能解耦，高聚合，低耦合</td></tr><tr><td>迪米特法则</td><td>不该知道的事情不要知道</td><td>不和陌生人说话，减少代码臃肿</td></tr><tr><td>里氏替换原则</td><td>子类重新方法功能发生改变<br>不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>合成复用原则</td><td>尽量使用组合而非继承实现代码复用</td><td>降低代码耦合度</td></tr></tbody></table>',40),a=[r];function o(s,p){return i(),e("div",null,a)}const h=t(l,[["render",o],["__file","design-principle.html.vue"]]),g=JSON.parse('{"path":"/writings/pattern/design-principle.html","title":"设计原则","lang":"zh-CN","frontmatter":{"title":"设计原则","icon":"article","category":["设计模式"],"description":"设计原则 开闭原则 开闭原则（Open Close Principal）定义：一个软件实体如类、模块和方法应该对扩展开放，对修改关闭，以降低代码修改的风险。 核心思想：用抽象构建框架，用实现扩展细节 优点： 有利于构建一个稳定的系统 提高软件系统的可复用性及可维护性 依赖倒置原则 依赖倒置原则（Dependence Inversion Principl...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/pattern/design-principle.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"设计原则"}],["meta",{"property":"og:description","content":"设计原则 开闭原则 开闭原则（Open Close Principal）定义：一个软件实体如类、模块和方法应该对扩展开放，对修改关闭，以降低代码修改的风险。 核心思想：用抽象构建框架，用实现扩展细节 优点： 有利于构建一个稳定的系统 提高软件系统的可复用性及可维护性 依赖倒置原则 依赖倒置原则（Dependence Inversion Principl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"开闭原则","slug":"开闭原则","link":"#开闭原则","children":[]},{"level":2,"title":"依赖倒置原则","slug":"依赖倒置原则","link":"#依赖倒置原则","children":[]},{"level":2,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":2,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[{"level":3,"title":"单一职责原则与接口隔离原则对比","slug":"单一职责原则与接口隔离原则对比","link":"#单一职责原则与接口隔离原则对比","children":[]}]},{"level":2,"title":"迪米特法则","slug":"迪米特法则","link":"#迪米特法则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"合成复用原则","slug":"合成复用原则","link":"#合成复用原则","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":1677655655000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":4.52,"words":1356},"filePathRelative":"writings/pattern/design-principle.md","autoDesc":true}');export{h as comp,g as data};
