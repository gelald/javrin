const e=JSON.parse('{"key":"v-a7ade316","path":"/writings/RocketMQ/RocketMQ-interview.html","title":"RocketMQ 面试题","lang":"zh-CN","frontmatter":{"description":"RocketMQ 面试题 为什么使用消息队列 使用消息队列主要有三个作用 解耦 例如电商系统中客户完成下单，此时订单系统完成自己的业务后可能还需要调用其他服务，如库存服务修改库存等，在引入消息队列前，可能这两个系统是耦合的，引入消息队列后，订单服务只需要把订单下单的消息放入消息队列中，下游的所有服务就根据消息去调用自己的业务即可，使得一个业务上的各服务互相解耦 异步 当订单完成支付后，后续还有一系列的操作，比如扣除库存、发送消息等，显然这个操作链路太长了，会导致响应时间变长，引入消息队列后，订单服务只需要把消息放到消息队列中即可响应，其他操作可以异步去做，使得响应时间缩短 削峰 业务往往存在高峰、低谷，当处于业务高峰时，可能我们的服务器、MySQL 等各自的承受能力都不一样，如果全都照单全收，有可能大量请求导致宕机，引入消息队列后，我们可以把请求都放到消息队列中，只放出能处理的流量，这样就能扛住短时间的大流量","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/RocketMQ/RocketMQ-interview.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"RocketMQ 面试题"}],["meta",{"property":"og:description","content":"RocketMQ 面试题 为什么使用消息队列 使用消息队列主要有三个作用 解耦 例如电商系统中客户完成下单，此时订单系统完成自己的业务后可能还需要调用其他服务，如库存服务修改库存等，在引入消息队列前，可能这两个系统是耦合的，引入消息队列后，订单服务只需要把订单下单的消息放入消息队列中，下游的所有服务就根据消息去调用自己的业务即可，使得一个业务上的各服务互相解耦 异步 当订单完成支付后，后续还有一系列的操作，比如扣除库存、发送消息等，显然这个操作链路太长了，会导致响应时间变长，引入消息队列后，订单服务只需要把消息放到消息队列中即可响应，其他操作可以异步去做，使得响应时间缩短 削峰 业务往往存在高峰、低谷，当处于业务高峰时，可能我们的服务器、MySQL 等各自的承受能力都不一样，如果全都照单全收，有可能大量请求导致宕机，引入消息队列后，我们可以把请求都放到消息队列中，只放出能处理的流量，这样就能扛住短时间的大流量"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:49:34.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:49:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-04T10:49:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"为什么使用消息队列","slug":"为什么使用消息队列","link":"#为什么使用消息队列","children":[]},{"level":2,"title":"消息队列有哪些模型","slug":"消息队列有哪些模型","link":"#消息队列有哪些模型","children":[]},{"level":2,"title":"消费者有哪些消费模式","slug":"消费者有哪些消费模式","link":"#消费者有哪些消费模式","children":[]},{"level":2,"title":"为什么选择 RocketMQ","slug":"为什么选择-rocketmq","link":"#为什么选择-rocketmq","children":[]},{"level":2,"title":"RocketMQ 的基本架构","slug":"rocketmq-的基本架构","link":"#rocketmq-的基本架构","children":[]},{"level":2,"title":"RocketMQ 中 Broker、Topic、队列之间的关系","slug":"rocketmq-中-broker、topic、队列之间的关系","link":"#rocketmq-中-broker、topic、队列之间的关系","children":[]},{"level":2,"title":"RocketMQ 怎么保证顺序消费消息","slug":"rocketmq-怎么保证顺序消费消息","link":"#rocketmq-怎么保证顺序消费消息","children":[]},{"level":2,"title":"RocketMQ 怎么实现分布式事务","slug":"rocketmq-怎么实现分布式事务","link":"#rocketmq-怎么实现分布式事务","children":[]},{"level":2,"title":"RocketMQ 怎么实现延时消息","slug":"rocketmq-怎么实现延时消息","link":"#rocketmq-怎么实现延时消息","children":[]},{"level":2,"title":"RocketMQ 怎么保证消息可靠性/不丢失","slug":"rocketmq-怎么保证消息可靠性-不丢失","link":"#rocketmq-怎么保证消息可靠性-不丢失","children":[]},{"level":2,"title":"RocketMQ 怎么处理消息重复","slug":"rocketmq-怎么处理消息重复","link":"#rocketmq-怎么处理消息重复","children":[]},{"level":2,"title":"RocketMQ 怎么处理消息堆积","slug":"rocketmq-怎么处理消息堆积","link":"#rocketmq-怎么处理消息堆积","children":[]},{"level":2,"title":"RocketMQ 怎么保证高可用","slug":"rocketmq-怎么保证高可用","link":"#rocketmq-怎么保证高可用","children":[]}],"git":{"createdTime":1677926974000,"updatedTime":1677926974000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":6.71,"words":2013},"filePathRelative":"writings/RocketMQ/RocketMQ-interview.md","localizedDate":"2023年3月4日","excerpt":"<h1> RocketMQ 面试题</h1>\\n<h2> 为什么使用消息队列</h2>\\n<p>使用消息队列主要有三个作用</p>\\n<ul>\\n<li>\\n<p>解耦</p>\\n<p>例如电商系统中客户完成下单，此时订单系统完成自己的业务后可能还需要调用其他服务，如库存服务修改库存等，在引入消息队列前，可能这两个系统是耦合的，引入消息队列后，订单服务只需要把订单下单的消息放入消息队列中，下游的所有服务就根据消息去调用自己的业务即可，使得一个业务上的各服务互相解耦</p>\\n</li>\\n<li>\\n<p>异步</p>\\n<p>当订单完成支付后，后续还有一系列的操作，比如扣除库存、发送消息等，显然这个操作链路太长了，会导致响应时间变长，引入消息队列后，订单服务只需要把消息放到消息队列中即可响应，其他操作可以异步去做，使得响应时间缩短</p>\\n</li>\\n<li>\\n<p>削峰</p>\\n<p>业务往往存在高峰、低谷，当处于业务高峰时，可能我们的服务器、MySQL 等各自的承受能力都不一样，如果全都照单全收，有可能大量请求导致宕机，引入消息队列后，我们可以把请求都放到消息队列中，只放出能处理的流量，这样就能扛住短时间的大流量</p>\\n</li>\\n</ul>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
