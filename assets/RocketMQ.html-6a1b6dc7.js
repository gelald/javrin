const e=JSON.parse('{"key":"v-7e357de9","path":"/writings/RocketMQ/RocketMQ.html","title":"RocketMQ","lang":"zh-CN","frontmatter":{"description":"RocketMQ 本篇文章基于 RocketMQ 4.9.0 版本。 消息队列简介 开始学习 RocketMQ 前，先简单了解一下消息队列。 为什么使用消息队列 解耦 传统架构：系统间直接耦合，每接入一个系统，都需要修改代码。 引入中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统 A 不需要做任何修改。 异步 传统架构：一些非必要的业务逻辑以同步的方式运行，比较耗费时间。 引入中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。 削峰 传统架构：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。 引入中间件：系统 A 按照数据库能处理的并发量，从消息队列中拉取消息。在生产中，这个短暂的高峰期积压是允许的。","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/RocketMQ/RocketMQ.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"RocketMQ"}],["meta",{"property":"og:description","content":"RocketMQ 本篇文章基于 RocketMQ 4.9.0 版本。 消息队列简介 开始学习 RocketMQ 前，先简单了解一下消息队列。 为什么使用消息队列 解耦 传统架构：系统间直接耦合，每接入一个系统，都需要修改代码。 引入中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统 A 不需要做任何修改。 异步 传统架构：一些非必要的业务逻辑以同步的方式运行，比较耗费时间。 引入中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。 削峰 传统架构：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。 引入中间件：系统 A 按照数据库能处理的并发量，从消息队列中拉取消息。在生产中，这个短暂的高峰期积压是允许的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:49:34.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:49:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-04T10:49:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"消息队列简介","slug":"消息队列简介","link":"#消息队列简介","children":[{"level":3,"title":"为什么使用消息队列","slug":"为什么使用消息队列","link":"#为什么使用消息队列","children":[]},{"level":3,"title":"使用了消息队列会有什么缺点","slug":"使用了消息队列会有什么缺点","link":"#使用了消息队列会有什么缺点","children":[]},{"level":3,"title":"什么情况下的异步操作需要使用消息队列而不是多线程","slug":"什么情况下的异步操作需要使用消息队列而不是多线程","link":"#什么情况下的异步操作需要使用消息队列而不是多线程","children":[]}]},{"level":2,"title":"RocketMQ 简介","slug":"rocketmq-简介","link":"#rocketmq-简介","children":[]},{"level":2,"title":"核心组件","slug":"核心组件","link":"#核心组件","children":[]},{"level":2,"title":"相关概念","slug":"相关概念","link":"#相关概念","children":[]},{"level":2,"title":"同步消息","slug":"同步消息","link":"#同步消息","children":[{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":3,"title":"实现","slug":"实现","link":"#实现","children":[]}]},{"level":2,"title":"异步消息","slug":"异步消息","link":"#异步消息","children":[{"level":3,"title":"场景","slug":"场景-1","link":"#场景-1","children":[]},{"level":3,"title":"实现","slug":"实现-1","link":"#实现-1","children":[]}]},{"level":2,"title":"单向发送消息","slug":"单向发送消息","link":"#单向发送消息","children":[{"level":3,"title":"场景","slug":"场景-2","link":"#场景-2","children":[]},{"level":3,"title":"实现","slug":"实现-2","link":"#实现-2","children":[]}]},{"level":2,"title":"事务消息","slug":"事务消息","link":"#事务消息","children":[{"level":3,"title":"场景","slug":"场景-3","link":"#场景-3","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"实现","slug":"实现-3","link":"#实现-3","children":[]}]},{"level":2,"title":"顺序消息","slug":"顺序消息","link":"#顺序消息","children":[{"level":3,"title":"场景","slug":"场景-4","link":"#场景-4","children":[]},{"level":3,"title":"原理","slug":"原理-1","link":"#原理-1","children":[]},{"level":3,"title":"实现","slug":"实现-4","link":"#实现-4","children":[]}]}],"git":{"createdTime":1677926974000,"updatedTime":1677926974000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":14.48,"words":4343},"filePathRelative":"writings/RocketMQ/RocketMQ.md","localizedDate":"2023年3月4日","excerpt":"<h1> RocketMQ</h1>\\n<blockquote>\\n<p>本篇文章基于 RocketMQ 4.9.0 版本。</p>\\n</blockquote>\\n<h2> 消息队列简介</h2>\\n<blockquote>\\n<p>开始学习 RocketMQ 前，先简单了解一下消息队列。</p>\\n</blockquote>\\n<h3> 为什么使用消息队列</h3>\\n<ul>\\n<li>\\n<p>解耦</p>\\n<ul>\\n<li>传统架构：系统间直接耦合，每接入一个系统，都需要修改代码。</li>\\n<li>引入中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统 A 不需要做任何修改。</li>\\n</ul>\\n</li>\\n<li>\\n<p>异步</p>\\n<ul>\\n<li>传统架构：一些非必要的业务逻辑以同步的方式运行，比较耗费时间。</li>\\n<li>引入中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。</li>\\n</ul>\\n</li>\\n<li>\\n<p>削峰</p>\\n<ul>\\n<li>传统架构：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。</li>\\n<li>引入中间件：系统 A 按照数据库能处理的并发量，从消息队列中拉取消息。在生产中，这个短暂的高峰期积压是允许的。</li>\\n</ul>\\n</li>\\n</ul>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
