import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as t,a as n}from"./app-ztW5o0ZG.js";const o={},i=n('<h1 id="java物理内存模型" tabindex="-1"><a class="header-anchor" href="#java物理内存模型"><span>Java物理内存模型</span></a></h1><blockquote><p>本文从堆栈角度引入 JMM，然后介绍 JMM 和物理内存之间的关系</p></blockquote><h2 id="jmm-引入" tabindex="-1"><a class="header-anchor" href="#jmm-引入"><span>JMM 引入</span></a></h2><p>在学习 JMM 之前，先简单回顾一下 JVM 运行时内存结构</p><h3 id="jvm-堆栈内容" tabindex="-1"><a class="header-anchor" href="#jvm-堆栈内容"><span>JVM 堆栈内容</span></a></h3><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220406100824.png" alt=""></p><ul><li><p>Heap （堆）包含了程序中创建的所有对象。无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上，其次对象上的成员变量，无论是基本类型还是引用类型也是存储在堆上。静态类变量也与类定义一起存储在堆上。</p></li><li><p>Thread Stack（线程栈）包含了每个方法的所有局部变量。基本类型的局部变量完全存储在线程栈中，一个线程可以将一个基本类型变量的<strong>副本传递</strong>给另一个线程，但它不能共享原始局部变量本身。引用类型的局部变量，引用存储在线程栈中，指向的对象存储在堆上。</p></li></ul><h3 id="java-内存模型" tabindex="-1"><a class="header-anchor" href="#java-内存模型"><span>Java 内存模型</span></a></h3><p>在学习了 JVM 运行时内存结构后，为了进一步学习 JVM 怎么和计算机硬件内存进行交互的，需要再学习 JMM(Java Memory Modal，Java 内存模型)</p><p>JVM 为了屏蔽各个硬件平台和操作系统对内存访问机制的差异，提出了 JMM 的概念</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220411162526.png" alt=""></p><p>现代计算机硬件内存结构大致可以分为这几个区域</p><ul><li>CPU：现代计算机通常有 2 个或更多的 CPU（其中一些 CPU 有可能有多个内核），可以同时运行多个线程，支持多线程程序。 <ul><li>CPU 寄存器：每个 CPU 基本上包含一组在 CPU 内存中的寄存器，CPU 在这些寄存器上的操作比在主存储器的操作要更快。</li></ul></li><li>CPU 高速缓存存储器：CPU 可以比主存储器更快地访问其告诉缓存存储器</li><li>主存储器：主要存储的是 Java 实例对象，所有线程创建的实例对象都存放在主内存中</li></ul><p>JMM 规定了主存储器所有线程都可以访问，但是线程对变量的操作必须在其工作内存（线程栈）中进行，操作完成后再写回主存储器中，不能直接操作主存储器中的变量，工作内存中存储着主存储器的变量副本</p><h2 id="jmm-与硬件内存结构关系" tabindex="-1"><a class="header-anchor" href="#jmm-与硬件内存结构关系"><span>JMM 与硬件内存结构关系</span></a></h2><h3 id="jmm-与硬件内存连接" tabindex="-1"><a class="header-anchor" href="#jmm-与硬件内存连接"><span>JMM 与硬件内存连接</span></a></h3><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413162651.png" alt=""></p><p>硬件架构是不区分线程栈和堆的，线程栈和堆都位于主存储器中，有一部分可能会位于 CPU 高速缓存和 CPU 内部寄存器中</p><p>当对象和变量可以存储在不同的存储区域中，可能会引发某些问题：</p><ul><li>线程更新（写）共享变量时的可见性</li><li>检查和读写共享变量时的竞态条件</li></ul><p>所以 JMM 规范了 JVM 与计算机内存是如何协同工作的：</p><ul><li>规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值</li><li>规定了一个线程在必须时如何同步地访问共享变量</li></ul><p>通过这种方式来保证多线程下变量的缓存一致性问题</p><h3 id="对象共享后的可见性" tabindex="-1"><a class="header-anchor" href="#对象共享后的可见性"><span>对象共享后的可见性</span></a></h3><blockquote><p>如果多个线程共享一个对象，那么其中一个线程对这个对象的更新可能对其他线程不可见。</p></blockquote><p>共享对象最初是放在了主存储器中，然后在 CPU 上运行的线程把共享对象读入到其 CPU 高速缓存中，然后对其进行了修改。只要 CPU 高速缓存还没更新到主存储器中，这个对象的改动对其他线程是不可见的，每一个线程都拥有了这个共享对象副本，每个副本都位于不同的 CPU 高速缓存中</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413163651.png" alt=""></p><blockquote><p>上图中，第一个线程对共享对象 obj 的 count 属性修改为 2，但其 CPU 高速缓存并未刷到主存储器中，导致另一个线程无法感知这个改动</p></blockquote><p>解决方案：<strong>使用 <code>volatile</code> 关键字来声明这个对象</strong>。这个关键字可以保证直接从主内存器读取给定变量，<strong>并在更新时始终写回主内存</strong></p><h3 id="竞态条件" tabindex="-1"><a class="header-anchor" href="#竞态条件"><span>竞态条件</span></a></h3><blockquote><p>如果多个线程共享一个对象，并且多个线程更新该共享对象中的变量，可能会出现竞态</p></blockquote><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413165751.png" alt=""></p><blockquote><p>上图中，假设 A 线程把共享对象 obj 读入自己的 CPU 高速缓存中并对 obj 的 count 属性 +1，并且 B 线程也在做同样的事情</p><p>如果这个加法操作有序进行了，那么这个属性最终写入到主存储器中应该是要 +2 的</p><p>但是这两个加法操作没有做到同步的控制，无论哪一个线程把自己 CPU 高速缓存中的对象写入到主存储器中时，最终这个属性也只是相较原来 +1</p></blockquote><p>解决方案：<strong>使用 <code>synchronized</code> 关键字包含这个加法操作</strong>。被 <code>synchronized</code> 包住的代码块可以保证在同一时间只能有一个线程进入代码块中，<strong>保证了代码块中的变量都从主存中读取</strong>，并且不管变量是否被 <code>volatile</code> 修饰，<strong>所有更新都始终写入到主存储器中</strong></p>',34),s=[i];function l(p,c){return t(),a("div",null,s)}const m=e(o,[["render",l],["__file","物理内存模型.html.vue"]]),h=JSON.parse('{"path":"/writings/JVM/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html","title":"Java物理内存模型","lang":"zh-CN","frontmatter":{"description":"Java物理内存模型 本文从堆栈角度引入 JMM，然后介绍 JMM 和物理内存之间的关系 JMM 引入 在学习 JMM 之前，先简单回顾一下 JVM 运行时内存结构 JVM 堆栈内容 Heap （堆）包含了程序中创建的所有对象。无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上，其次对象上的成员变量，无论是基本类型...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/JVM/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"Java物理内存模型"}],["meta",{"property":"og:description","content":"Java物理内存模型 本文从堆栈角度引入 JMM，然后介绍 JMM 和物理内存之间的关系 JMM 引入 在学习 JMM 之前，先简单回顾一下 JVM 运行时内存结构 JVM 堆栈内容 Heap （堆）包含了程序中创建的所有对象。无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上，其次对象上的成员变量，无论是基本类型..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220406100824.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:20:13.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java物理内存模型\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220406100824.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220411162526.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413162651.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413163651.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413165751.png\\"],\\"dateModified\\":\\"2023-02-28T15:20:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"JMM 引入","slug":"jmm-引入","link":"#jmm-引入","children":[{"level":3,"title":"JVM 堆栈内容","slug":"jvm-堆栈内容","link":"#jvm-堆栈内容","children":[]},{"level":3,"title":"Java 内存模型","slug":"java-内存模型","link":"#java-内存模型","children":[]}]},{"level":2,"title":"JMM 与硬件内存结构关系","slug":"jmm-与硬件内存结构关系","link":"#jmm-与硬件内存结构关系","children":[{"level":3,"title":"JMM 与硬件内存连接","slug":"jmm-与硬件内存连接","link":"#jmm-与硬件内存连接","children":[]},{"level":3,"title":"对象共享后的可见性","slug":"对象共享后的可见性","link":"#对象共享后的可见性","children":[]},{"level":3,"title":"竞态条件","slug":"竞态条件","link":"#竞态条件","children":[]}]}],"git":{"createdTime":null,"updatedTime":1677597613000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":4.71,"words":1412},"filePathRelative":"writings/JVM/物理内存模型.md","autoDesc":true}');export{m as comp,h as data};
