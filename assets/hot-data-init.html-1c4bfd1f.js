import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e}from"./app-f9042815.js";const t={},p=e(`<h1 id="热点数据初始化" tabindex="-1"><a class="header-anchor" href="#热点数据初始化" aria-hidden="true">#</a> 热点数据初始化</h1><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h2><p>热点数据或字典数据初始化的思路：</p><ul><li>尽可能在程序启动时就把数据放到缓存中（比如：redis），不希望在第一次查询时让用户等待时间较长</li><li>如果说在程序启动时就把数据加载到内存中，那么我们应该要把握好程序启动完成的时机</li></ul><h2 id="如何选择加载时机" tabindex="-1"><a class="header-anchor" href="#如何选择加载时机" aria-hidden="true">#</a> 如何选择加载时机</h2><h3 id="main-方法" tabindex="-1"><a class="header-anchor" href="#main-方法" aria-hidden="true">#</a> main 方法</h3><p>最简单粗暴的方法：写在 SpringBoot 程序的 main 方法中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">UserApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;加载热点数据到内存中&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种做法不够优雅，要是项目组其他成员效仿这种做法，会污染程序的启动方法</p><h3 id="利用-bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#利用-bean-的生命周期" aria-hidden="true">#</a> 利用 Bean 的生命周期</h3><p>升级一下，把数据字典的加载工作放到 Bean 的初始化方法执行</p><p>设置 Bean 的初始化方法有三种：</p><ul><li>使用 <code>@PostConstruct</code> 注解</li><li>Bean 实现 InitializingBean 接口</li><li>如果使用 <code>@Bean</code> 实现自定义的话，配置 <code>init-method</code> 方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@PostConstruct</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;========Bean初始化后加载热点数据========&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式还算可以，但是不太推荐，因为数据预热这个操作超出了 Bean 的生命周期这个范畴，这是项目级别的工作</p><h3 id="优雅的方法" tabindex="-1"><a class="header-anchor" href="#优雅的方法" aria-hidden="true">#</a> 优雅的方法</h3><p>这里简单讲讲两种优雅的方法：</p><ul><li><p>订阅 <code>ApplicationReadyEvent</code> 事件</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationReaderEventListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationReadyEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationReadyEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;========应用启动完成后加载热点数据========&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>实现 <code>ApplicationRunner</code> 接口</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationReaderRunner</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationRunner</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ApplicationArguments</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;========应用启动完成后加载热点数据========&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>总的来说这两种方法都很好地抓住了程序启动完成的时机，是一种较为优雅的方式，从功能实现上也没有和其他内容耦合，强烈推荐</p><p>启动时机：<code>ApplicationRunner</code> 优先于 <code>ApplicationListener</code></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230612235828.png" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>数据预热是一件老生常谈的事情，如何选择预热的时机其实不算是技术难题，应该要更多地考量如何把这件事情做得优雅、合理，保证代码的可读性、可维护性。</p>`,23),i=[p];function o(c,l){return a(),s("div",null,i)}const r=n(t,[["render",o],["__file","hot-data-init.html.vue"]]);export{r as default};
