import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as d,e as c}from"./app-f9042815.js";const a={},i=c('<h1 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</h1><p>随着移动互联网的兴起，传统基于 <code>Session+Cookie</code> 的Web网站认证方式转变成了基于 <code>OAuth2</code> 等开放授权协议的单点登录模式（SSO，Single Sign On），相应的基于服务器 <code>Session+Cookie</code> 的 <code>Auth</code> 手段也转变成 <code>JWT(Json Web Token)</code> 为代表<code>Token Auth</code>机制。</p><p><code>JWT</code>是一个非常轻巧的规范，这个规范允许我们使用 <code>JWT</code> 在两个组织之间传递安全可靠的信息。<code>Session+Cookie</code>的方式把认证信息放在了服务端，<code>JWT</code>把认证信息放在了客户端，减轻了服务端的内存压力</p><ul><li><code>JWS</code>：签名过的 <code>JWT</code></li><li><code>JWE</code>：部分 Payload 经过加密的 <code>JWT</code></li><li><code>JWA</code>： <code>JWT</code> 用到的密码学算法</li><li><code>JWK</code>：<code>JWT</code> 的密钥</li></ul><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ul><li><code>JWT</code> 是无状态的</li><li><code>JWT</code> 不仅可以用于认证，也可以用于交换信息，因为 Payload 部分可以自定义内容</li><li><code>JWT</code> 可以防止篡改，因为 <code>JWT</code> 包含了签名</li><li><code>JWT</code> 不能存放敏感数据，因为 Payload 部分只进行了base64编码</li><li><code>JWT</code> 是一次性的，如果想修改内容，必须重新颁发一个</li></ul><p><code>JWT(Json Web Token)</code> 有两种实现方式：<code>JWS(Json Web Signature)</code> 与 <code>JWE(Json Web Encryption)</code></p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210227182347.png" style="zoom:67%;"><h2 id="jws" tabindex="-1"><a class="header-anchor" href="#jws" aria-hidden="true">#</a> JWS</h2><p><code>JWS(JSON Web Signature)</code>：<code>Signed JWT</code><strong>签名过的<code>JWT</code></strong>，是一个<strong>统一表达形式的字符串</strong></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210227182556.png" alt=""></p><h3 id="header-头部" tabindex="-1"><a class="header-anchor" href="#header-头部" aria-hidden="true">#</a> Header 头部</h3><p>头部用于描述关于该 <code>JWT</code> 的最基本的信息，例如其类型以及签名所用的算法等</p><ul><li>alg：签名所用的算法，如 HMAC 或 RSA 等</li><li>typ：令牌的类型</li><li>jti(可选)：【<code>JWT</code> ID】代表正在使用 <code>JWT</code> 的编号，这个编号对应服务端应当唯一，也可以放在 Payload 中</li><li>cty(可选)：【Content Type】这个比较少见。当 Payload 中为任意数据时，这个值无需设置；但是当 Payload 中也有 <code>JWT</code> 的时候，也就是<strong>嵌套</strong> <code>JWT</code> 时，这个值必须设定为 <code>JWT</code></li></ul><p>JSON 内容要经 Base64 编码生成字符串成为 Header</p><h3 id="payload-负载" tabindex="-1"><a class="header-anchor" href="#payload-负载" aria-hidden="true">#</a> Payload 负载</h3><ul><li>iss：【issuer】发布者的 url</li><li>sub：【subject】该 <code>JWT</code> 面向的用户</li><li>aud：【audience】接收者的 url</li><li>exp：【expiration】过期时间，unix时间戳</li><li>nbf：【not before】使用时间不能早于这个时间，unix时间戳</li><li>iat：【issued at】签发时间，时间戳</li><li>jti：【<code>JWT</code> ID】该 <code>JWT</code> 的唯一编号</li></ul><p>负载的内容还可以<strong>自定义追加</strong></p><p>JSON 内容要经 Base64 编码生成字符串成为 Payload</p><h3 id="signature-签名" tabindex="-1"><a class="header-anchor" href="#signature-签名" aria-hidden="true">#</a> Signature 签名</h3><p>拥有该部分的 <code>JWT</code> 被称为 <code>JWS</code> ；没有则称为 <code>nonsecure JWT</code> 也就是不安全的 <code>JWT</code> ，此时 Header 中声明的签名算法为 None</p><p>这个部分 Header 与 Payload 先进行 Base64 编码再通过 Header 中声明的加密方式，使用密钥 secret 进行加密，生成签名</p><p><code>JWS</code> 的主要目的是<strong>保证了数据</strong>在传输过程中<strong>不被修改</strong>，验证数据的完整性。但由于仅采用 Base64 对消息内容编码(Header与Payload)，因此<strong>不保证数据的不可泄露性，所以不适合用于传输敏感数据</strong></p><h2 id="jwe" tabindex="-1"><a class="header-anchor" href="#jwe" aria-hidden="true">#</a> JWE</h2><p><code>JWE(JSON Web Encrypted)</code>：<code>Encrypted JWT</code>部分Payload<strong>经过加密的<code>JWT</code></strong>，相对于 <code>JWS</code>，<code>JWE</code> 则<strong>同时保证了安全性与数据完整性</strong></p><p><code>JWE</code>由五部分组成</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210228102124.png" alt=""></p><h3 id="生成步骤" tabindex="-1"><a class="header-anchor" href="#生成步骤" aria-hidden="true">#</a> 生成步骤</h3><ol><li><code>JOSE Header</code> 与 <code>JWS</code> 的 Header 含义相同</li><li>生成一个随机的 <code>Content Encryption Key （CEK）</code></li><li>使用 RSAES-OAEP 加密算法，用公钥加密CEK，生成<code>JWE Encrypted Key</code></li><li>生成<code>JWE</code>初始化向量 <code>Initialization Vector</code></li><li>使用 AES-GCM 加密算法对明文部分进行加密生成密文 <code>Ciphertext</code></li><li>算法会随之生成一个128位的认证标记 <code>Authentication Tag</code></li><li>对5个部分分别进行 Base64 编码</li></ol><p>JWE的计算过程相对繁琐，不够轻量级，因此<strong>适合与数据传输而非Token认证</strong>，但该协议也足够安全可靠，用简短字符串描述了传输内容，<strong>兼顾数据的安全性与完整性</strong></p><h2 id="jwt流程" tabindex="-1"><a class="header-anchor" href="#jwt流程" aria-hidden="true">#</a> JWT流程</h2><p>Client：客户端</p><p>Auth Server：认证服务器</p><p>Resource Server：资源服务器</p><p>JWT签名算法一般会有两个选择：HS256（HMACSHA256、对称算法）和RS256（RSASHA256、非对称算法）</p><h3 id="hmac流程" tabindex="-1"><a class="header-anchor" href="#hmac流程" aria-hidden="true">#</a> HMAC流程</h3><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210801193743.png" style="zoom:45%;"><p>Auth Server需要与Resource Server提前商定好用于签名、校验的密钥secret，并且<strong>必须保证secret不能泄漏</strong>，否则不安全，攻击者可以利用这个secret来伪造令牌</p><h3 id="rsa流程" tabindex="-1"><a class="header-anchor" href="#rsa流程" aria-hidden="true">#</a> RSA流程</h3><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210801193801.png" style="zoom:45%;"><p>Auth Server在生成JWT的时候使用私钥进行加密，Resource Server在校验JWT的时候使用公钥进行解密。<strong>RSA方式更加安全</strong>，secret需要Auth Server和Resource Server双方都保密，私钥只存在于Auth Server，只需保证私钥不被泄漏即可</p>',41),r=[i];function n(s,t){return o(),d("div",null,r)}const u=e(a,[["render",n],["__file","JWT.html.vue"]]);export{u as default};
