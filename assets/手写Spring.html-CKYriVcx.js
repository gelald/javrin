import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-BH1OTr4j.js";const l={};function t(h,i){return e(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="手写spring" tabindex="-1"><a class="header-anchor" href="#手写spring"><span>手写Spring</span></a></h1><p>这个专题是手写 Spring 框架，准确点来说是用自己的理解去仿照 Spring 框架实现它的核心功能点，包括 IoC、DI、MVC、AOP、JDBC 这几个核心的模块。手写框架是理解框架其中一个有效的途径，毕竟”好记性不如烂笔头“。</p><p>很多初学者去看源码的时候容易陷入一个误区，拿到程序直接 Ctrl 点进去看，看着看着就被困在里面了。其实点进去看不是不行，而是需要一定的前提条件，前提条件就是需要先理解这个模块的时序图，有哪些关键的类，因为框架的封装程度是很高的，心里面始终会有一个清晰的主线，不至于绕晕。</p><p>对我个人来说，学习源码比较有效的方式还是两点</p><ol><li>先学会使用。如何使用框架，相信往上也有不少优质的资源。先从搭建一个 Demo 开始，再到一些典型场景演练，理解框架的使用方式，使用场景。</li><li>深入理解，70%时间猜想，30%时间验证。花大额时间去猜想这个框架的核心工作原理是很有必要的，这样可以帮助我们尽可能站在设计者的角度去看这个框架。当然这也需要一定的基础积累，手写 Spring 下来，本人最大的体会就是框架离不开反射、正则和设计模式，所以有效理解框架是需要我们有足够殷实的基础知识，这些基础知识往往单独看比较难以理解，但是组合使用下来，我相信会有更深层次的理解！</li></ol><h2 id="spring解决了什么问题" tabindex="-1"><a class="header-anchor" href="#spring解决了什么问题"><span>Spring解决了什么问题</span></a></h2><p>开始手写之前，我们要先达到会用这一层次，需要知道 Spring 框架解决了什么问题，我们为什么要去用它。</p><ul><li><p>IoC 功能解决了创建对象的问题（工厂模式、原型模式、单例模式）</p></li><li><p>DI 功能解决了给对象自动赋值的问题（组合复用原则）</p></li><li><p>MVC 功能解决了响应用户请求的问题（委派模式、策略模式、解释器模式）</p></li><li><p>AOP功能提供了面向切面的设计，解耦程序与通知回调（责任链模式、动态代理模式）</p></li><li><p>Jdbc提供了一个ORM框架（模板方法模式、建造者模式）</p></li></ul><h2 id="了解spring基本工作原理" tabindex="-1"><a class="header-anchor" href="#了解spring基本工作原理"><span>了解Spring基本工作原理</span></a></h2><p>使用一个非常简易版的 DispatcherServlet 了解 IoC、DI、MVC 的工作原理。</p><p>Java Web 项目的入口在 web.xml，并且 Servlet 的 init 方法、doPost 方法可以实现 Spring 的初始化阶段、运行阶段的工作，所以我们使用 Servlet 作为程序的入口，并实现大部分的逻辑</p><h3 id="实现基本思路" tabindex="-1"><a class="header-anchor" href="#实现基本思路"><span>实现基本思路</span></a></h3><ul><li>配置阶段 <ul><li>入口：web.xml，在 web.xml 中配置 DispatcherServlet</li><li>配置 Spring 主配置文件（需要扫描的包路径）</li><li>配置注解到具体类上</li></ul></li><li>初始化阶段 触发 MVC、IoC、DI 核心组件的启动 <ul><li>init 方法，加载配置文件</li><li>初始化 IoC 容器（可以简单看成是 Map ）</li><li>扫描包路径下的相关类</li><li>通过反射的手段将类实例化并保存到 IoC 容器中（需要交给 Spring IoC 容器管理的类）</li><li>扫描 IoC 容器中的类进行自动赋值</li><li>将 url 和 Method 进行一对一关联（可以简单看成是 Map）</li></ul></li><li>运行阶段 <ul><li>调用 doPost、doGet 方法，获取 Request、Response 对象</li><li>从 Request 对象中获取用户输入的 url ，根据之前保存的映射关系找到具体 Method</li><li>根据 Method 上的参数列表（参数名字与参数位置的映射关系）与url 中的参数（参数名字与参数值的映射关系），构建调用方法时的需要的参数列表</li><li>通过反射的方式调用这个 Method，并返回结果</li><li>将返回结果输出到浏览器</li></ul></li></ul><h2 id="实现-ioc-功能" tabindex="-1"><a class="header-anchor" href="#实现-ioc-功能"><span>实现 IoC 功能</span></a></h2><p>第一版的手写 Spring 用一个大类完成了所有的功能，从单一职责原则来看，这是不合理的，也不符合开闭原则，所以接下来会逐步把 Spring 对应的功能拆分出来，优化整个代码结构</p><p>这一节我们来关注 Spring IoC 功能，这个功能关注工厂怎么把对象创建出来然后交给用户。使用了工厂模式、原型模式、单例模式。</p><h3 id="核心角色简述" tabindex="-1"><a class="header-anchor" href="#核心角色简述"><span>核心角色简述</span></a></h3><ul><li>ApplicationContext：上下文，开放给用户进行使用，持有 BeanFactory 的引用。使用了门面模式，封装了许多实用的功能。</li><li>BeanFactory：Spring IoC 模块中负责创建对象的最顶层的工厂接口。</li><li>BeanDefinitionReader：一个负责读取并解析配置文件的工具类。因为 Bean 的配置信息来自不同的配置文件，如：xml、yml、properties，甚至是注解，它们的语法都不尽相同，Spring 定义了这个顶层的读取配置的接口，不同配置信息有各自的实现。</li><li>BeanDefinitoin：保存类的配置信息（BeanName、是否延时加载等），后续 BeanFactory 根据它来进行 Bean 的创建。Bean 的配置可能来自不同的配置文件，经过 BeanDefinitionReader 读取解析后创建统一的 BeanDefinition。</li><li>BeanWrapper：对创建出来的 Bean 进行了封装，持有着 Bean 的引用。因为 BeanFactory 根据 BeanDefinition 对 Bean 进行实例化后，这些 Bean 有可能是原生的，也有可能是代理的，Spring 为了统一操作，都把 Bean 封装到 BeanWrapper 对象中，最终缓存到 IoC 容器中的是 BeanWrapper 对象。</li></ul><h3 id="实现基本思路-1" tabindex="-1"><a class="header-anchor" href="#实现基本思路-1"><span>实现基本思路</span></a></h3><ol><li>DispatcherServlet 中持有着 ApplicationContext 的引用，调用 init 方法时，交给 ApplicationContext 进行配置文件的加载</li><li>ApplicationContext 中持有着 BeanDefinitionReader 和 BeanFactory 的引用，配置文件的加载交给 BeanDefinitionReader 进行，创建对象交给 BeanFactory 进行</li><li>BeanDefinitionReader 加载配置文件，根据配置文件扫描包路径下的相关类</li><li>BeanDefinitionReader 根据所有需要被注册的 class 文件创建 BeanDefinition 并缓存起来</li><li>BeanFactory 拿到这些 BeanDefinition 后进行 BeanName 与 BeanDefinition 的映射，方便后续实例化</li><li>BeanFactory 根据 BeanName 与 BeanDefinition 的映射进行非延时加载 Bean 的实例化</li><li>创建 Bean 后，把 Bean 封装成 BeanWrapper</li><li>分别缓存 Bean 与 BeanWrapper</li><li>执行依赖注入</li></ol><h2 id="实现-di-功能" tabindex="-1"><a class="header-anchor" href="#实现-di-功能"><span>实现 DI 功能</span></a></h2><p>上一节我们实现了 IoC 功能，但是其中的依赖注入目前写得不是那么优雅，而且也无法解决一个老生常谈的问题——循环依赖，所以这一节我们重点关注 Spring 如何完成自动赋值和通过三级缓存解决循环依赖的问题。遵循组合复用原则。</p><h3 id="什么是循环依赖" tabindex="-1"><a class="header-anchor" href="#什么是循环依赖"><span>什么是循环依赖</span></a></h3><p>在开始之前，先了解一下什么是循环依赖，方便后续理解。</p><ol><li><p>自己依赖自己的直接依赖</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155738.png" alt=""></p></li><li><p>两个对象之间互相依赖</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155836.png" alt=""></p></li><li><p>多个对象之间的间接依赖</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155859.png" alt=""></p></li></ol><h3 id="循环依赖的情况" tabindex="-1"><a class="header-anchor" href="#循环依赖的情况"><span>循环依赖的情况</span></a></h3><ul><li><p>单例的 setter 注入（能解决）</p></li><li><p>多例的 setter 注入 （不能解决）</p><blockquote><p>多例的 Bean 使用一次就创建一次，不需要缓存起来。不使用缓存也就无法解决循环引用，程序启动会报错。</p></blockquote></li><li><p>构造器注入（不能解决）</p><blockquote><p>使用构造器注入时，需要在延时加载的情况下才能解决循环依赖。</p><p>因为加入singletonFactories三级缓存的前提是执行了构造器（反射调用），缓存中没有需要引入的对象，所以构造器的循环依赖没法解决。</p></blockquote></li><li><p>单例的代理对象 setter 注入（有可能解决）</p><blockquote><p>Bean 初始化完成后，后面还需要进行一步二级缓存中的对象和原始对象是否相等的检查。如果被注入的 Bean 是代理对象，那么这一步检查无法通过。</p><p>为什么说有可能解决，因为<strong>类加载顺序会影响 Bean 的实例化过程</strong>，默认情况下 Spring 是根据路径+文件名进行扫描，如果说这个被注入的代理 Bean 比当前正在实例化的 Bean 要后加载，那么不会出现在二级缓存中，也就不需要进行检查</p></blockquote></li><li><p>DependsOn循环依赖（不能解决）</p><blockquote><p><code>AbstractBeanFactory</code> 中的 <code>doGetBean</code> 方法会检查 dependsOn 的实例有没有循环依赖，如果有循环依赖则抛异常。</p></blockquote><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//如果当前Bean有依赖Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (dependsOn </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> dep </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dependsOn) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isDependent</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dep)) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">			throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BeanCreationException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">mbd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getResourceDescription</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Circular depends-on relationship between &#39;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;&#39; and &#39;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dep </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;&#39;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">		}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //递归调用getBean方法，获取当前Bean的依赖Bean</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        registerDependentBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(dep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //把被依赖Bean注册给当前依赖的Bean</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        getBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(dep)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="spring如何检测是否存在循环依赖" tabindex="-1"><a class="header-anchor" href="#spring如何检测是否存在循环依赖"><span>Spring如何检测是否存在循环依赖</span></a></h3><p>在实例化 Bean 的时候，会给 Bean 进行标记（把这个 Bean 放到一个 Set 容器中），后面在依赖注入的时候会发生递归调用实例化，如果发现处于创建中的状态，说明有循环依赖。</p><h3 id="核心角色简述-1" tabindex="-1"><a class="header-anchor" href="#核心角色简述-1"><span>核心角色简述</span></a></h3><p>singletonObjects：一级缓存，保存完成实例化、注入、初始化的 Bean 实例</p><p>earlySingletonObjects：二级缓存，保存完成实例化的 Bean 实例</p><p>singletonFactories：三级缓存，保存 Bean 的创建工厂，便于后面扩展有机会创建代理对象，在 AOP 模块中实现动态代理发挥作用</p><p>singletonsCurrentlyInCreation：保存正在创建的 Bean 的 BeanName，为了标记这个 Bean 正在创建</p><h3 id="实现基本思路-2" tabindex="-1"><a class="header-anchor" href="#实现基本思路-2"><span>实现基本思路</span></a></h3><p>加一个容器，只要是正在实例化的 Bean ，就把它的 BeanName 缓存下来</p><ol><li>根据 beanName 从 BeanDefinitionMap 中拿到自己的 BeanDefinition</li><li>去一级缓存中检查这个 Bean 是否已经完成实例化 <ol><li>如果返回不是 <code>null</code> 说明已经完成实例化，就返回这个Bean</li><li>如果返回是 <code>null</code> 说明还没完成，就往下走</li></ol></li><li>使用反射的方式进行实例化</li><li>把创建 Bean 的工厂添加到三级缓存中，为了考虑后面有可能需要一个代理对象，可以从里面拿到代理对象。创建工厂的时候是利用了上面实例化后的 Bean 的，所以当不需要动态代理的情况下，这个工厂创建出来的 Bean 和完成实例化后的 Bean 是同一个引用</li><li>执行依赖注入，依赖注入的逻辑就是递归调用上述步骤</li><li>把创建好、完成依赖注入的 Bean 放入一级缓存</li></ol><hr><p>检查这个 Bean 是否完成实例化的具体逻辑</p><ol><li>检查一级缓存 <ol><li>如果一级缓存有，就返回一级缓存中的值</li><li>如果一级缓存没有，且这个 Bean 不是正在实例化的，就返回 <code>null</code></li><li>如果一级缓存没有，且这个 Bean 正在进行实例化，<strong>说明有循环依赖</strong>，往下走</li></ol></li><li>检查二级缓存 <ol><li>如果二级缓存有，就返回二级缓存中的值</li><li>如果二级缓存没有，往下走</li></ol></li><li>检查三级缓存 <ol><li>如果三级缓存没有这个对象的工厂，就返回 <code>null</code></li><li>如果三级缓存有这个对象的工厂，从三级缓存中拿到对象工厂并创建这个对象，把 Bean 放入二级缓存，移除三级缓存中的工厂对象，这样不用每次都要去三级缓存中创建对象，提升性能</li></ol></li></ol><h2 id="实现-mvc-功能" tabindex="-1"><a class="header-anchor" href="#实现-mvc-功能"><span>实现 MVC 功能</span></a></h2><p>关注前端页面、用户请求如何与后台逻辑建立映射关系</p><h3 id="前端九大组件介绍" tabindex="-1"><a class="header-anchor" href="#前端九大组件介绍"><span>前端九大组件介绍</span></a></h3><table><thead><tr><th style="text-align:center;">组件名</th><th style="text-align:center;">解释</th></tr></thead><tbody><tr><td style="text-align:center;">MultipartResolver</td><td style="text-align:center;">支持多文件上传的组件<br>把request内部的文件流解析成MultipartFile</td></tr><tr><td style="text-align:center;">LocaleResolver</td><td style="text-align:center;">本地语言环境，国际化</td></tr><tr><td style="text-align:center;">ThemeResolver</td><td style="text-align:center;">主题模板处理器<br>简单来说是对换皮肤功能进行支持</td></tr><tr><td style="text-align:center;"><strong>HandlerMapping</strong></td><td style="text-align:center;">保存url和Method的映射关系</td></tr><tr><td style="text-align:center;"><strong>HandlerAdapter</strong></td><td style="text-align:center;">动态参数适配器</td></tr><tr><td style="text-align:center;">HandlerExceptionResolver</td><td style="text-align:center;">异常拦截器</td></tr><tr><td style="text-align:center;">RequestToViewNameTranslator</td><td style="text-align:center;">视图提取器，从request中提取viewName</td></tr><tr><td style="text-align:center;"><strong>ViewResolver</strong></td><td style="text-align:center;">视图转换器，模板引擎</td></tr><tr><td style="text-align:center;">FlashMapManager</td><td style="text-align:center;">参数缓存器<br>缓存url中的参数（请求参数）</td></tr></tbody></table><p>FlashMapManager的作用：<code>request.forward()</code> 转发，能自动携带上一次请求的所有参数；<code>request.redirect()</code> 重定向，会丢失上一次请求的参数，这时候就需要 FlashMapManager 把参数找回来</p><h3 id="实现基本思路-3" tabindex="-1"><a class="header-anchor" href="#实现基本思路-3"><span>实现基本思路</span></a></h3><p>为了方便理解，九大组件抽取其中的 HandlerMapping、HandlerAdapter、ViewResolver 这三个组件进行实现</p><ul><li><p>初始化阶段，主要完成三大组件的初始化</p><ul><li><p>初始化 HandlerMapping 容器，使用 HandlerMapping 对象来记录 Controller 对象、Method 及其定义的 mapping 规则，其中 mapping 规则支持正则表达式</p></li><li><p>初始化 HandlerAdapter 容器，每一个 HandlerMapping 对应一个方法，也就对应一个 HandlerAdapter</p></li><li><p>初始化 ViewResovler ，记录模板文件的路径</p></li></ul></li><li><p>运行阶段，主要完成请求委派、方法调用、页面渲染并返回的工作</p><ul><li>遍历 HandlerMapping 容器，根据 handlerMapping 中的 pattern 进行 url 的匹配，拿到对应的 handlerMapping</li><li>根据 HandlerAdapter 与 HandlerMapping 的映射关系，拿到对应的 HandlerAdapter</li><li>HandlerAdapter 进行处理，拿到 ModelAndView。Handler 可以看成是需要执行的 Controller 对象，HandlerAdapter 主要完成的是建立参数列表、反射调用 Handler 中对应的方法、根据返回值构建 ModelAndView 对象</li><li>ViewResolver 模板引擎根据 ModelAndView 拿到 View 对象，并将其渲染返回</li></ul></li></ul><h2 id="实现-aop-功能" tabindex="-1"><a class="header-anchor" href="#实现-aop-功能"><span>实现 AOP 功能</span></a></h2><p>关注面向切面编程，解耦代码增强与实际逻辑，通知回调。使用了责任链模式、代理模式。</p><p>AOP常用于：日志监控、权限控制、事务管理等</p><h3 id="核心角色简述-2" tabindex="-1"><a class="header-anchor" href="#核心角色简述-2"><span>核心角色简述</span></a></h3><p>AdvisedSupport：解析AOP配置信息，构建切面与切点之间的关系的工具类</p><p>AopConfig：保存AOP的配置信息</p><p>Advice：通知，完成切面回调的封装</p><p>JdkDynamicAopProxy：使用Jdk生成代理类的工具</p><p>CglibAopProxy：使用Cglib生成代理类的工具</p><p>DefaultAopProxyFactory：创建生成代理类工具的工厂的默认实现</p><h3 id="实现基本思路-4" tabindex="-1"><a class="header-anchor" href="#实现基本思路-4"><span>实现基本思路</span></a></h3><p>在手写 DI 功能的时候我们可以了解到，三级缓存的设计是为了可以方便创建代理对象，所以 AOP 的功能也就从这里开始</p><ol><li>反射创建对象时，初始化 AopConfig 对象</li><li>把切面表达式转换成正则表达式，与目标类全限定类名进行匹配</li><li>如果匹配上就构建目标对象方法与切面对象方法的关系（一对多关系）</li></ol><hr><p>其中精华所在是增强方法执行链和目标方法的执行过程</p><p>MethodInterceptor 是所有通知类型类的顶层接口，其中有一个 invoke 方法，代表执行该类通知的通知方法。需要增加新的通知类型，只需要执行这个接口即可</p><p>MethodInvocation 负责递归调度增强方法与目标方法，其中内部维护了一个索引，这个索引用于在执行链上进行移动</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSMethodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">currentInterceptorIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">interceptorsAndDynamicMethodMatchers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 如果把链中的方法执行完了，那就执行目标类自己的方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">target</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">arguments</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 从执行链中获取一个通知回调方法</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> interceptorOrInterceptionAdvice</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">interceptorsAndDynamicMethodMatchers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(++</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">currentInterceptorIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (interceptorOrInterceptionAdvice </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">instanceof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> MSMethodInterceptor) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 判断类型并强转</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            MSMethodInterceptor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> methodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (MSMethodInterceptor) interceptorOrInterceptionAdvice;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> methodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设这个执行链上有三个类型通知的拦截器：before、after、afterThrowing</p><p>他们各自的实现分别是</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSMethodBeforeAdviceInterceptor</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSMethodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MSMethodInvocation</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 先执行了before的逻辑，再执行其他的</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">before</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(invocation);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSAfterReturningAdviceInterceptor</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSMethodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MSMethodInvocation</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 等到其他的执行完成后得到返回值再执行after方法</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> returnValue</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">after</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(invocation, returnValue);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> returnValue;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSAspectJAfterThrowingAdvice</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MSMethodInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MSMethodInvocation</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 正常执行，如果捕获到异常，就执行afterThrowing方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> invocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Throwable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">afterThrowing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(invocation, throwable);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> throwable;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的递归链是连接了两个对象，递归着 MethodInvocation#proceed、MethodInterceptor#invoke 这个循环</p>`,72)])])}const k=s(l,[["render",t]]),d=JSON.parse('{"path":"/writings/Spring/%E6%89%8B%E5%86%99Spring.html","title":"手写Spring","lang":"zh-CN","frontmatter":{"description":"手写Spring 这个专题是手写 Spring 框架，准确点来说是用自己的理解去仿照 Spring 框架实现它的核心功能点，包括 IoC、DI、MVC、AOP、JDBC 这几个核心的模块。手写框架是理解框架其中一个有效的途径，毕竟”好记性不如烂笔头“。 很多初学者去看源码的时候容易陷入一个误区，拿到程序直接 Ctrl 点进去看，看着看着就被困在里面了。...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"手写Spring\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155738.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155836.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155859.png\\"],\\"dateModified\\":\\"2022-08-01T15:56:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Spring/%E6%89%8B%E5%86%99Spring.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"手写Spring"}],["meta",{"property":"og:description","content":"手写Spring 这个专题是手写 Spring 框架，准确点来说是用自己的理解去仿照 Spring 框架实现它的核心功能点，包括 IoC、DI、MVC、AOP、JDBC 这几个核心的模块。手写框架是理解框架其中一个有效的途径，毕竟”好记性不如烂笔头“。 很多初学者去看源码的时候容易陷入一个误区，拿到程序直接 Ctrl 点进去看，看着看着就被困在里面了。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220220155738.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-08-01T15:56:59.000Z"}],["meta",{"property":"article:modified_time","content":"2022-08-01T15:56:59.000Z"}]]},"git":{"createdTime":1659199509000,"updatedTime":1659369419000,"contributors":[{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":2,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":13.5,"words":4050},"filePathRelative":"writings/Spring/手写Spring.md","autoDesc":true}');export{k as comp,d as data};
