import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as o,o as i}from"./app-CsQTLbug.js";const t={};function r(p,e){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="spring-ioc-整体脉络" tabindex="-1"><a class="header-anchor" href="#spring-ioc-整体脉络"><span>Spring IoC 整体脉络</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>我们做 Web 后台开发的，其实也可以说是 Spring 开发，因为 Spring 框架在整个 Web 开发中扮演着非常重要的角色。Spring 的引入，完全改变了开发方式，从以前的 new 关键字创建对象到如今由 Spring 容器统一管理所有对象，而后者就是 IoC （Inversion of Control）控制反转这么一种设计思想：把对象的控制权（包括创建、初始化）都交给 Spring 来处理。</p><p>此外 Spring 还有其他功能，但是种种诸如 DI、AOP，都是围绕着 IoC 来开展的，所以了解清楚 IoC 对我们学习 Spring 有极大的帮助。</p><h2 id="spring-ioc-核心角色" tabindex="-1"><a class="header-anchor" href="#spring-ioc-核心角色"><span>Spring IoC 核心角色</span></a></h2><h3 id="bean" tabindex="-1"><a class="header-anchor" href="#bean"><span>Bean</span></a></h3><p>Bean 其实就是包装过的 Object，Bean 是 Spring 中的核心角色，由 Spring 管理和创建的对象我们都称之为 Bean。</p><h3 id="beandefinition" tabindex="-1"><a class="header-anchor" href="#beandefinition"><span>BeanDefinition</span></a></h3><p>既然 Spring 帮助我们管理所有的对象，那么这些对象长什么样，比如说全路径、类名、需要什么属性，这是 Spring 需要知道的，而这些信息我们<strong>称为 Bean 的元数据</strong>，用于描述创建 Bean 所需要的信息。</p><p>Spring 使用了 <code>BeanDefinition</code> 来表示这些 Bean 的元数据，在 <code>BeanDefinition</code> 中我们可以看到比较熟悉的配置 <code>isSingleton()</code> 是否单例、<code>isPrototype()</code> 是否多例、<code>setInitMethodName()</code> 设置初始化方法等等。</p><h3 id="beandefinitionreader" tabindex="-1"><a class="header-anchor" href="#beandefinitionreader"><span>BeanDefinitionReader</span></a></h3><p>既然 Spring 使用了 <code>BeanDefinition</code> 来描述 Bean 的元数据，那么这些 Bean 的元数据从哪里来呢？在以前我们会写 XML 配置文件来定义 Bean 的各种属性，现在开发我们都会用注解来进行配置这些元数据，甚至配置文件的格式也不局限于 .xml 格式，还可能有 .properties 格式，为了适配各种渠道，Spring 使用 <code>BeanDefinitionReader</code> 这个接口统一了读取各种配置的行为，他有两个常见的实现类 <code>XmlBeanDefinitionReader</code> 读取 XML 配置文件、<code>PropertiesBeanDefinitionReader</code> 读取 Properties 配置文件。</p><p>此外，注解和配置文件差异挺大的，所以读取注解配置的 <code>AnnotatedBeanDefinitionReader</code> 没有去实现 <code>BeanDefinitionReader</code> 接口，专门做基于注解的 <code>BeanDefinition</code> 的读取和注册。</p><h3 id="beanfactory" tabindex="-1"><a class="header-anchor" href="#beanfactory"><span>BeanFactory</span></a></h3><p>使用 <code>BeanDefinitionReader</code> 读取到的这些 <code>BeanDefinition</code> 后，最终拿去按其要求创建 Bean ，而创建 Bean 的角色就是 <code>BeanFactory</code>，可以说 <code>BeanFactory</code> 是一个工厂也是一个容器，他负责生产和管理各个 Bean 的实例，也对外提供获取 Bean 的接口。，1这是 Spring IoC 容器的顶层接口，</p><h3 id="beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#beanfactorypostprocessor"><span>BeanFactoryPostProcessor</span></a></h3><h3 id="applicationcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext"><span>ApplicationContext</span></a></h3><p><code>BeanFactory</code> 是 Spring IoC 容器的顶层接口，<code>ApplicationContext</code> 是它的子接口，拥有更加丰富的功能</p><h2 id="ioc-容器初始化过程" tabindex="-1"><a class="header-anchor" href="#ioc-容器初始化过程"><span>IoC 容器初始化过程</span></a></h2><p>介绍了以上核心角色后，把他们串起来看，<code>BeanFactory</code> 通过 <code>BeanDefinitionReader</code> 使用描述 <code>Bean</code> 的元数据的 <code>BeanDefinition</code> 来创建 <code>Bean</code></p><h2 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖"><span>循环依赖</span></a></h2><p>概念：两个单例的 Bean，彼此依赖着对方，比如 A 依赖 B，B 依赖 A，在 Spring 程序启动的时候会抛出循环依赖的异常</p><p>关键词：「三级」缓存、提前「暴露」对象</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230611000200.png" alt=""></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230610235912.png" alt=""></p><p>解决的核心手段：把实例化和初始化分开执行，先用半成品赋值，所以构造器注入的方式，无法解决循环依赖的问题</p><h3 id="三级缓存" tabindex="-1"><a class="header-anchor" href="#三级缓存"><span>三级缓存</span></a></h3><p>三个 map 结构，在 <code>DefaultSingletonBeanRegistry</code> 中</p><ul><li>一级缓存：<code>Map&lt;String, Object&gt; singletonObjects</code> 存储</li><li>二级缓存：<code>Map&lt;String, Object&gt; earlySingletonObjects</code> 存储 BeanName</li><li>三级缓存：<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code></li></ul><blockquote><p>ObjectFactory：getBean 的逻辑，为 AOP 准备</p></blockquote><p>AbstractApplicationContext#refresh</p>',31)])])}const d=n(t,[["render",r]]),g=JSON.parse('{"path":"/writings/Spring/Spring-IoC.html","title":"Spring IoC 整体脉络","lang":"zh-CN","frontmatter":{"description":"Spring IoC 整体脉络 前言 我们做 Web 后台开发的，其实也可以说是 Spring 开发，因为 Spring 框架在整个 Web 开发中扮演着非常重要的角色。Spring 的引入，完全改变了开发方式，从以前的 new 关键字创建对象到如今由 Spring 容器统一管理所有对象，而后者就是 IoC （Inversion of Control）...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring IoC 整体脉络\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230611000200.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230610235912.png\\"],\\"dateModified\\":\\"2023-07-27T12:37:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Spring/Spring-IoC.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"Spring IoC 整体脉络"}],["meta",{"property":"og:description","content":"Spring IoC 整体脉络 前言 我们做 Web 后台开发的，其实也可以说是 Spring 开发，因为 Spring 框架在整个 Web 开发中扮演着非常重要的角色。Spring 的引入，完全改变了开发方式，从以前的 new 关键字创建对象到如今由 Spring 容器统一管理所有对象，而后者就是 IoC （Inversion of Control）..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20230611000200.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-27T12:37:11.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-27T12:37:11.000Z"}]]},"git":{"createdTime":1690461431000,"updatedTime":1690461431000,"contributors":[{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":1,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":2.91,"words":872},"filePathRelative":"writings/Spring/Spring-IoC.md","autoDesc":true}');export{d as comp,g as data};
