import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e as t}from"./app-859571d0.js";const e={},p=t(`<h1 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h1><blockquote><p>为 String 单独拆分一个模块出来，可以看出 String 的特殊性及重要性。此外 String 也是面试题的「常客」。</p></blockquote><h2 id="不可变" tabindex="-1"><a class="header-anchor" href="#不可变" aria-hidden="true">#</a> 不可变</h2><p>String 类型最大的特点就是不可变，因为内部是使用一个被 <code>final</code> 关键字修饰的 <code>char[]</code> 存储数据，初始化后就不能引用其他数组，并且内部没有改变这个数组的方法，因此它是不可变的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不可变的优点：</p><ul><li><p>可以用于 <code>HashMap</code> 中的 key 。因为作为 key 是需要使用 hashcode 的，而 String 类型数据不可变，所以 hashcode 不需要重新计算，效率更高。</p></li><li><p>可以使用常量池的设计。如果一个字符串已经被创建过了，那么就会从 String 常量池中取得引用。</p></li><li><p>安全性。不可变让它具备线程安全的特点，可以在多个线程中使用。再比如可以作为类的全限定类名，在框架中往往大量使用反射，如果这个字符串是可以改变的，那么就无法使用反射的特性。</p></li></ul><h2 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h2><p>String 类型的数据常用的创建方式有两种</p><ul><li>构造方法创建</li><li>通过字面量创建</li></ul><p>两种方式的区别是</p><ul><li>构造方法创建每次都会在堆中创建一个新的对象，无论两个字符串内容是否相同</li><li>通过字面量创建的话，第一次创建会把字符串对象放在常量池中，下一次再创建相同内容的字符串时会引用常量池中相同的对象</li></ul><p>我们通过一个小例子来感受一下两种创建方式的区别</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// false</span>

<span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中字面量创建还可以和编译器优化碰撞新的火花</p><blockquote><p>String s = &quot;123&quot; + &quot;456&quot;内存中产生几个字符串对象?</p><p>由于等号右边都是常量的运算，所以编译器在编译的时候会进行优化。把&quot;123&quot;、&quot;456&quot;拼接成&quot;123456&quot;，如果此时常量池中没有&quot;123456&quot;，则产生1个，如果有，则产生0个。</p></blockquote><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h2><blockquote><p>关于 String 的方法有很多，这里简单介绍一些值得注意的</p></blockquote><h3 id="boolean-equals-object-object" tabindex="-1"><a class="header-anchor" href="#boolean-equals-object-object" aria-hidden="true">#</a> boolean equals(Object object)</h3><p>这是比较两个字符串的内容是否一样的方法，通过比较底层数组中的每一个字符是否相等。</p><p>值得注意的是：一般推荐把能确定的非空字符串甚至是常量写在方法左边，这样可以有效避免空指针异常。</p><h3 id="string-concat-string-str" tabindex="-1"><a class="header-anchor" href="#string-concat-string-str" aria-hidden="true">#</a> String concat(String str)</h3><p>拼接字符串，返回新字符串。</p><h3 id="string-substring-int-begin-int-end" tabindex="-1"><a class="header-anchor" href="#string-substring-int-begin-int-end" aria-hidden="true">#</a> String substring(int begin, int end)</h3><p>以一个左闭右开的区间截断字符串，返回新字符串。</p><p>这两个方法重点不是介绍功能，而是因为 String 是不可变的，所以每一次对 String 进行一些内容上的增减操作时，都会返回一个新的 String ，保证了 String 的不可变的特点。</p><h3 id="native-string-intern" tabindex="-1"><a class="header-anchor" href="#native-string-intern" aria-hidden="true">#</a> native String intern()</h3><p>着重讲一下这个方法，这个方法把字符串对象放到常量池中并返回它的引用。</p><p>我们通过一个小例子来演示这个方法的功能</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// false</span>
<span class="token class-name">String</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>讲讲这个过程到底发生了什么事情</p><ol><li><p>s1 采用构造方法的方式创建了一个字符串对象，这个对象是在堆上的；s2 采用字面量的方式创建了一个字符串对象，这个对象是在字符串常量池中的。</p></li><li><p>所以当判断 s1 == s2 的时候，结果自然是 false 的，因为这两个对象不是同一个对象。</p></li><li><p>s3 使用 intern 方法获得了一个字符串对象，这个 intern 方法具体是先把 s1 引用的对象放到字符串常量池中，然后返回这个对象的引用。</p></li><li><p>但是现在 &quot;aaa&quot; 这个字符串在字符串常量池中已存在，所以使用了同一个对象，所以判断 s3 == s2 的时候，结果自然是 true 的。</p></li></ol><h2 id="stringbuilder-和-stringbuffer" tabindex="-1"><a class="header-anchor" href="#stringbuilder-和-stringbuffer" aria-hidden="true">#</a> StringBuilder 和 StringBuffer</h2><blockquote><p>介绍完 String，接下来介绍一下它的两个「兄弟」类型</p></blockquote><p>可以把它们看成是长度可以变化的字符串，也就是没有 String 的不可变的特性。</p><p>现在从各个角度对比一下 String、StringBuilder、StringBuffer</p><ul><li><p>可变性：String 是不可变的；StringBuilder 和 StringBuffer 是可变的。原因：String 底层的字符数组是被 final 修饰的，一旦赋值不可以修改;而 StringBuilder 和 StringBuffer 的都没有。</p></li><li><p>线程安全性：String 是不可变的，多个线程可以共享同一个 String，所以是线程安全的；StringBuffer 的方法中加了同步锁，所以是线程安全的；StringBuilder 没有加锁，是线程不安全的。</p></li><li><p>性能方面：StringBuffer 加了锁，导致性能变差；StringBuilder 没有加锁，性能相对来说比较好；String 每次都会生成新的对象，性能更差一点。StringBuffer 和 StringBuilder 都不会生成新的对象，所以比 String 来说效率更高。</p></li><li><p>从使用场景来说：操作少量数据使用 String；单线程操作大量数据使用 StringBuilder；多线程操作大量数据使用 StringBuffer。</p></li></ul>`,37),i=[p];function o(c,l){return a(),s("div",null,i)}const d=n(e,[["render",o],["__file","String.html.vue"]]);export{d as default};
