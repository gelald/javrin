import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,e}from"./app-f9042815.js";const t={},o=e(`<h1 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h1><p><strong>底层是对象数组</strong>，和普通数组相比，它的容量能动态地增长。</p><p>属于线性表的存储结构，<strong>插入</strong>、<strong>删除</strong>的时间复杂度为O(n)，求<strong>表长度</strong>、<strong>增加元素(增加到尾部)</strong>、<strong>查询第i个元素</strong>时间复杂度为O(1)</p><p>ArrayList <strong>继承了AbstractList，实现了List</strong>。提供了相关的<strong>添加、删除、修改、遍历</strong>等功能。</p><p>ArrayList 实现了<strong>RandomAccess 接口</strong>， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p><p>ArrayList 实现了<strong>Cloneable 接口</strong>，即覆盖了函数 clone()，<strong>能被克隆</strong>。</p><p>ArrayList 实现了<strong>Serializable 接口</strong>，这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p><p>和 Vector 不同，<strong>ArrayList 中的操作不是线程安全的</strong>！所以，建议在<strong>单线程中才使用</strong> ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</p><p>length：数组长度，初始默认大小为<strong>10</strong>；size：元素个数</p><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h3><ul><li>ArrayList(int initialCapacity) <ul><li>创建一个指定容量的ArrayList，如果容量为0，<code>this.elementData = EMPTY_ELEMENTDATA</code></li></ul></li><li>ArrayList() <ul><li>默认构造方法，初始化一个空数组<code>this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，当插入第一个元素的时候容量才变成10</li></ul></li><li>ArrayList(Collection&lt;? extends E&gt; c) <ul><li>构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序，传入集合元素个数大于0，否则用空数组代替<code>this.elementData = EMPTY_ELEMENTDATA</code></li></ul></li></ul><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制" aria-hidden="true">#</a> 扩容机制</h3><p>为避免频繁插入导致频繁的拷贝、导致性能降低，所以不能每次扩容一个</p><p><strong>ensureCapacityInternal(int) 每次插入前都执行 （自动扩容）</strong></p><ol><li>计算最小扩容量 <ol><li>如果是空数组，比较默认最小长度和需要的最小容量，取较大值</li><li>如果不是，最小扩容量就是所需最小容量</li></ol></li><li>判断是否需要扩容 <ol><li>如果最小扩容量比原数组容量要大，则扩容</li></ol></li><li><strong>扩容核心方法</strong><ol><li>旧容量：原数组容量</li><li>新容量：旧容量*1.5</li><li>检查下限。如果新容量比最小扩容量小，那么新容量等于最小扩容量</li><li>检查上限。如果新容量比ArrayList所定义的最大容量大，那么判断最小扩容量和最大容量的关系 <ol><li>如果最小扩容量比最大容量大，那么新容量等于Integer.MAX_VALUE</li><li>如果最小扩容量比最大容量小，那么新容量等于最大容量</li></ol></li><li>调用Arrays.copyOf(elementData, 新容量)，将原有数据复制到一个具有新容量这么大的数组中</li></ol></li></ol><p><strong>ensureCapacity(int) 手动扩容 （插入数据时一次性扩容）</strong></p><ol><li>通过默认最小容量和最小需求容量来判断是否有必要扩容。 <ol><li>空数组，比较最小需求容量和10，需求容量大于10，下一步；小雨10，不需扩容</li><li>有内容，直接下一步</li></ol></li><li>判断是否需要扩容 <ol><li>如果最小扩容量比原数组容量大，则扩容</li></ol></li><li>扩容</li></ol><h3 id="其他方法" tabindex="-1"><a class="header-anchor" href="#其他方法" aria-hidden="true">#</a> 其他方法</h3><p>IndexOf(Object) 和 lastIndexOf(Object)</p><ul><li>相同： <ol><li>如果找到元素，返回对应索引；如果没有找到，返回-1</li><li>能接受传入的参数为null，那就去寻找null值出现的<strong>位置</strong></li><li>同样是返回第一次出现的位置</li></ol></li><li>差异： <ol><li>indexOf是从前往后寻找；lastIndexOf是从后往前寻找；</li></ol></li></ul><p>trimToSize 修剪方法</p><p>修改这个ArrayList实例的容量为列表的当前大小。 用此操作来最小化ArrayList实例的存储。如果列表长度为0，修改为空数组EMPTY_ELEMENTDATA，否则使用Arrays.copyOf(elementData, size)，创建一个长度为size，元素和elementData一样长的数组</p><p>toArray() 和 toArray(T[] a)</p><p>toArray() 以正确的顺序返回一个安全的（列表不保留对其元素的引用，分配的是一个新的数组）和ArrayList具有相同元素的对象数组，数组长度为元素个数</p><p>Arrays.copyOf() 和 Systems.arrayCopy()</p><p>联系：</p><p>copyOf内部调用了arrayCopy</p><p>区别：</p><ol><li>arraycopy()<strong>需要目标数组</strong>，将原数组拷贝到你自己定义的数组里，而且可以选择<strong>拷贝的起点</strong>和<strong>长度</strong>以及放入新数组中的<strong>位置</strong></li><li>copyOf()是系统自动在内部<strong>新建一个数组</strong>，并返回该数组。</li></ol><p><em>Arrays.toList</em></p><h3 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h3><ul><li><strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>， <strong>next()</strong>， <strong>remove()</strong> 等方法</li><li><strong>ListItr</strong> 继承 <strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法</li></ul><h1 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h1><h3 id="关心两个问题-流水线、自动并行" tabindex="-1"><a class="header-anchor" href="#关心两个问题-流水线、自动并行" aria-hidden="true">#</a> 关心两个问题：流水线、自动并行</h3><h2 id="操作分类" tabindex="-1"><a class="header-anchor" href="#操作分类" aria-hidden="true">#</a> 操作分类</h2><h3 id="中间操作-中间操作只是一种标记" tabindex="-1"><a class="header-anchor" href="#中间操作-中间操作只是一种标记" aria-hidden="true">#</a> 中间操作:中间操作只是一种标记</h3><h4 id="无状态-元素的处理不受前面元素的影响-操作的次序可以交换" tabindex="-1"><a class="header-anchor" href="#无状态-元素的处理不受前面元素的影响-操作的次序可以交换" aria-hidden="true">#</a> 无状态:元素的处理不受前面元素的影响(操作的次序可以交换)</h4><p><code>unordered()</code><code>filter()</code><code>peek()</code><code>map()</code><code>mapToInt()</code><code>mapToLong()</code><code>mapToDouble()</code><code>flatMap()</code><code>flatMapToInt()</code><code>flatMapToLong()</code><code>flatMapToDouble()</code></p><h4 id="有状态-必须等到所有元素处理之后才知道最终结果-操作的次数不可以交换-一旦交换则产生影响" tabindex="-1"><a class="header-anchor" href="#有状态-必须等到所有元素处理之后才知道最终结果-操作的次数不可以交换-一旦交换则产生影响" aria-hidden="true">#</a> 有状态:必须等到所有元素处理之后才知道最终结果(操作的次数不可以交换，一旦交换则产生影响)</h4><p><code>sorted()</code><code>district()</code><code>limit()</code><code>skip()</code></p><h3 id="结束操作-结束操作才会触发实际计算" tabindex="-1"><a class="header-anchor" href="#结束操作-结束操作才会触发实际计算" aria-hidden="true">#</a> 结束操作:结束操作才会触发实际计算</h3><h4 id="非短路操作-处理全部元素才可以返回结果" tabindex="-1"><a class="header-anchor" href="#非短路操作-处理全部元素才可以返回结果" aria-hidden="true">#</a> 非短路操作:处理全部元素才可以返回结果</h4><p><code>forEach()</code><code>forEachOrdered()</code><code>toArray()</code><code>reduce()</code><code>collect()</code><code>max()</code><code>min()</code><code>count()</code></p><h4 id="短路操作-不用处理全部元素就可以返回结果" tabindex="-1"><a class="header-anchor" href="#短路操作-不用处理全部元素就可以返回结果" aria-hidden="true">#</a> 短路操作:不用处理全部元素就可以返回结果</h4><p><code>anyMatch()</code><code>allMatch()</code><code>noneMatch()</code><code>findFirst()</code><code>findAny()</code></p><h2 id="例子理解" tabindex="-1"><a class="header-anchor" href="#例子理解" aria-hidden="true">#</a> 例子理解</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;\\nA&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>A1B1C1
A2B2C2
A3B3C3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1、peek、limit方法都是懒惰的中间操作，不会立马执行，只有执行到热情的结束操作，才会执行。
2、执行结束操作时会回溯上面所有的中间操作
3、peek相当于为这个stream提供一个消费者
4、limit规定了forEach遍历的次数(forEach执行需要回溯，正常执行是执行10次)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="stream流水线应避免过多的迭代-结束操作-产生大量的中间结果-否则空间时间的开销都很大" tabindex="-1"><a class="header-anchor" href="#stream流水线应避免过多的迭代-结束操作-产生大量的中间结果-否则空间时间的开销都很大" aria-hidden="true">#</a> Stream流水线应避免过多的迭代(结束操作)产生大量的中间结果，否则空间时间的开销都很大</h3>`,52),r=[o];function i(l,c){return n(),s("div",null,r)}const u=a(t,[["render",i],["__file","集合.html.vue"]]);export{u as default};
