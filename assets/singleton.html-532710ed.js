const e=JSON.parse('{"key":"v-d2ff0028","path":"/writings/pattern/singleton.html","title":"单例模式","lang":"zh-CN","frontmatter":{"title":"单例模式","icon":"article","category":["设计模式"],"description":"单例模式 定义：确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点getInstance()，隐藏（私有）其所有的构造方法 适用场景： 需要频繁实例化然后销毁的对象，特别是设计IO操作的对象 创建的对象消耗的资源或时间过多，但是又经常使用的对象 有状态的对象 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 例子：ServletContext、ServletConfig、ApplicationContext、电脑回收站、数据库连接池","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/pattern/singleton.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"单例模式"}],["meta",{"property":"og:description","content":"单例模式 定义：确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点getInstance()，隐藏（私有）其所有的构造方法 适用场景： 需要频繁实例化然后销毁的对象，特别是设计IO操作的对象 创建的对象消耗的资源或时间过多，但是又经常使用的对象 有状态的对象 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 例子：ServletContext、ServletConfig、ApplicationContext、电脑回收站、数据库连接池"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单例模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"饿汉式单例","slug":"饿汉式单例","link":"#饿汉式单例","children":[]},{"level":2,"title":"懒汉式单例","slug":"懒汉式单例","link":"#懒汉式单例","children":[{"level":3,"title":"懒汉式简单写法","slug":"懒汉式简单写法","link":"#懒汉式简单写法","children":[]},{"level":3,"title":"加锁写法","slug":"加锁写法","link":"#加锁写法","children":[]},{"level":3,"title":"双重检查锁写法","slug":"双重检查锁写法","link":"#双重检查锁写法","children":[]},{"level":3,"title":"静态内部类写法","slug":"静态内部类写法","link":"#静态内部类写法","children":[]}]},{"level":2,"title":"注册式单例","slug":"注册式单例","link":"#注册式单例","children":[{"level":3,"title":"枚举式写法","slug":"枚举式写法","link":"#枚举式写法","children":[]},{"level":3,"title":"容器式写法","slug":"容器式写法","link":"#容器式写法","children":[]}]},{"level":2,"title":"ThreadLocal单例","slug":"threadlocal单例","link":"#threadlocal单例","children":[]},{"level":2,"title":"反射被破坏的场景","slug":"反射被破坏的场景","link":"#反射被破坏的场景","children":[{"level":3,"title":"反射破坏单例","slug":"反射破坏单例","link":"#反射破坏单例","children":[]},{"level":3,"title":"反序列化破坏单例","slug":"反序列化破坏单例","link":"#反序列化破坏单例","children":[]},{"level":3,"title":"clone 破坏单例","slug":"clone-破坏单例","link":"#clone-破坏单例","children":[]},{"level":3,"title":"多线程破坏单例","slug":"多线程破坏单例","link":"#多线程破坏单例","children":[]}]}],"git":{"createdTime":1677655655000,"updatedTime":1677655655000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":7.43,"words":2228},"filePathRelative":"writings/pattern/singleton.md","localizedDate":"2023年3月1日","excerpt":"<h1> 单例模式</h1>\\n<p>定义：确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点<code>getInstance()</code>，隐藏（私有）其所有的构造方法</p>\\n<p>适用场景：</p>\\n<ol>\\n<li>需要频繁实例化然后销毁的对象，特别是设计IO操作的对象</li>\\n<li>创建的对象消耗的资源或时间过多，但是又经常使用的对象</li>\\n<li>有状态的对象</li>\\n<li>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。</li>\\n<li>控制资源的情况下，方便资源之间的互相通信。如线程池等。</li>\\n</ol>\\n<p>例子：<code>ServletContext</code>、<code>ServletConfig</code>、<code>ApplicationContext</code>、电脑回收站、数据库连接池</p>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
