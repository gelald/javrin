const e=JSON.parse('{"key":"v-6e4141da","path":"/writings/RocketMQ/RocketMQ-theory-1.html","title":"RocketMQ 原理分析-1","lang":"zh-CN","frontmatter":{"title":"RocketMQ 原理分析-1","icon":"article","category":["干货","消息队列"],"tag":["原理","RocketMQ"],"description":"RocketMQ 原理分析-1 本篇原理分析主要讲解消息原理方面 RocketMQ 如何保证消息不丢失/保证可靠性 消息在 RocketMQ 流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。 生产者发送消息时主要依靠发送确认来确保消息可靠性的。同步异步发送都可以获取到发送状态，通过这个发送状态来判断本次消息是否成功发送。另外，发送消息时还可以指定一个超时时间，如果超出这个超时时间可以再次发送。 消费者消费消息时也存在一个消费确认机制，当消费者消费消息成功或失败都会给 Broker 返回消费状态，消费成功则结束本次流程；消费失败 Broker 则会重新发送消息。如果停电、宕机 Broker 都不会认为消费成功，也会继续重新投递。 Broker 存储阶段保证消息不丢失的手段就是把消息记录到 CommitLog 中，保证消息不会丢失。关于消息刷盘在下篇会进一步剖析：RocketMQ 原理分析（下）","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/RocketMQ/RocketMQ-theory-1.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"RocketMQ 原理分析-1"}],["meta",{"property":"og:description","content":"RocketMQ 原理分析-1 本篇原理分析主要讲解消息原理方面 RocketMQ 如何保证消息不丢失/保证可靠性 消息在 RocketMQ 流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。 生产者发送消息时主要依靠发送确认来确保消息可靠性的。同步异步发送都可以获取到发送状态，通过这个发送状态来判断本次消息是否成功发送。另外，发送消息时还可以指定一个超时时间，如果超出这个超时时间可以再次发送。 消费者消费消息时也存在一个消费确认机制，当消费者消费消息成功或失败都会给 Broker 返回消费状态，消费成功则结束本次流程；消费失败 Broker 则会重新发送消息。如果停电、宕机 Broker 都不会认为消费成功，也会继续重新投递。 Broker 存储阶段保证消息不丢失的手段就是把消息记录到 CommitLog 中，保证消息不会丢失。关于消息刷盘在下篇会进一步剖析：RocketMQ 原理分析（下）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:49:34.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"原理"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:49:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 原理分析-1\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-04T10:49:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"RocketMQ 如何保证消息不丢失/保证可靠性","slug":"rocketmq-如何保证消息不丢失-保证可靠性","link":"#rocketmq-如何保证消息不丢失-保证可靠性","children":[]},{"level":2,"title":"RocketMQ 中消息重复的问题","slug":"rocketmq-中消息重复的问题","link":"#rocketmq-中消息重复的问题","children":[]},{"level":2,"title":"RocketMQ 消息堆积问题","slug":"rocketmq-消息堆积问题","link":"#rocketmq-消息堆积问题","children":[]},{"level":2,"title":"RocketMQ 中顺序消息的问题","slug":"rocketmq-中顺序消息的问题","link":"#rocketmq-中顺序消息的问题","children":[]},{"level":2,"title":"RocketMQ 延时消息原理","slug":"rocketmq-延时消息原理","link":"#rocketmq-延时消息原理","children":[{"level":3,"title":"SCHEDULE_TOPIC_XXXX 介绍","slug":"schedule-topic-xxxx-介绍","link":"#schedule-topic-xxxx-介绍","children":[]},{"level":3,"title":"ScheduleMessageService 介绍","slug":"schedulemessageservice-介绍","link":"#schedulemessageservice-介绍","children":[]},{"level":3,"title":"延时消息在 Broker 的流转过程","slug":"延时消息在-broker-的流转过程","link":"#延时消息在-broker-的流转过程","children":[]}]},{"level":2,"title":"RocketMQ 事务消息原理","slug":"rocketmq-事务消息原理","link":"#rocketmq-事务消息原理","children":[{"level":3,"title":"实现事务消息核心","slug":"实现事务消息核心","link":"#实现事务消息核心","children":[]},{"level":3,"title":"事务消息的流程","slug":"事务消息的流程","link":"#事务消息的流程","children":[]},{"level":3,"title":"事务消息应用场景","slug":"事务消息应用场景","link":"#事务消息应用场景","children":[]}]},{"level":2,"title":"死信队列原理","slug":"死信队列原理","link":"#死信队列原理","children":[{"level":3,"title":"死信消息的产生","slug":"死信消息的产生","link":"#死信消息的产生","children":[]},{"level":3,"title":"死信队列的特点","slug":"死信队列的特点","link":"#死信队列的特点","children":[]}]}],"git":{"createdTime":1677926974000,"updatedTime":1677926974000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":10.39,"words":3116},"filePathRelative":"writings/RocketMQ/RocketMQ-theory-1.md","localizedDate":"2023年3月4日","excerpt":"<h1> RocketMQ 原理分析-1</h1>\\n<blockquote>\\n<p>本篇原理分析主要讲解消息原理方面</p>\\n</blockquote>\\n<h2> RocketMQ 如何保证消息不丢失/保证可靠性</h2>\\n<p>消息在 RocketMQ 流转大概可以分为三个阶段：发送阶段、存储阶段、消费阶段，那么可靠性就要从这三个阶段考虑。</p>\\n<ul>\\n<li>生产者发送消息时主要依靠<strong>发送确认</strong>来确保消息可靠性的。同步异步发送都可以获取到发送状态，通过这个发送状态来判断本次消息是否成功发送。另外，发送消息时还可以指定一个超时时间，如果超出这个超时时间可以再次发送。</li>\\n<li>消费者消费消息时也存在一个<strong>消费确认机制</strong>，当消费者消费消息成功或失败都会给 Broker 返回消费状态，消费成功则结束本次流程；消费失败 Broker 则会重新发送消息。如果停电、宕机 Broker 都不会认为消费成功，也会继续重新投递。</li>\\n<li>Broker 存储阶段保证消息不丢失的手段就是<strong>把消息记录到 CommitLog 中</strong>，保证消息不会丢失。关于消息刷盘在下篇会进一步剖析：<a href=\\"/javrin/docs/writings/RocketMQ/RocketMQ-theory-2.html\\" target=\\"blank\\">RocketMQ 原理分析（下）</a></li>\\n</ul>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
