import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as e,e as i}from"./app-85442c0b.js";const r={},n=i('<p>接口调用包含两个方面：</p><ul><li>序列化：json、xml、hession、protobuf、thrift、text、bytes</li><li>通信协议：http、soap、websockect</li></ul><h1 id="soa架构设计模式" tabindex="-1"><a class="header-anchor" href="#soa架构设计模式" aria-hidden="true">#</a> SOA架构设计模式</h1><p>三种构建规范</p><ol><li>SOAP: http+xml的形式</li><li>REST: http+json的形式</li><li>RPC: 基于socket的形式 三种典型框架</li><li>CXF: SOAP/REST框架</li><li>dubbo: RPC框架</li><li>SpringCloud: REST规范的生态系统</li></ol><h1 id="soap" tabindex="-1"><a class="header-anchor" href="#soap" aria-hidden="true">#</a> SOAP</h1><h1 id="rest" tabindex="-1"><a class="header-anchor" href="#rest" aria-hidden="true">#</a> REST</h1><ul><li><p>概念：REST即表现层状态转变（Representational State Transfer，简称REST）。<strong>表现层状态</strong>，是指(在某个瞬间状态的)资源数据的快照，包括资源数据的内容、表现格式(XML、JSON)等信息</p></li><li><p>原则：</p><ul><li>网络上所有事物都抽象为资源</li><li>每个资源都有一个唯一的资源标识符（uri）</li><li>同一个资源有多种表现形式（json、xml）</li><li>对资源的各种操作不会改变资源标识符，只是请求方法的区别</li><li>所有操作都是无状态的。是指服务端不保存任何与特定HTTP请求相关的资源，应用状态必须由请求方在请求过程中提供。要求在网络通信过程中，任意一个Web请求必须与其他请求隔离，当请求端提出请求时，请求本身包含了响应端为响应这一请求所需的全部信息。</li></ul></li><li><p>RESTful风格的体现，在你使用了get请求，就是查询；使用post请求,就是新增的请求；使用put请求，就是修改的请求；使用delete请求，就是删除的请求。这样做就完全没有必要对crud做具体的描述。</p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrjsyshpj30p20hi7jn.jpg" alt=""></p></li><li><p>幂等性：对同一Rest接口多次访问，得到资源的状态是相同的</p></li><li><p>安全性：对该Rest接口访问，不会使服务端资源的状态发生变化</p></li><li></li></ul><table><thead><tr><th>http方法</th><th>资源操作</th><th>幂等</th><th>安全</th></tr></thead><tbody><tr><td>GET</td><td>SELECT</td><td>是</td><td>是</td></tr><tr><td>POST</td><td>INSERT</td><td>否</td><td>否</td></tr><tr><td>PUT</td><td>UPDATE</td><td>是</td><td>否</td></tr><tr><td>DELETE</td><td>DELETE</td><td>是</td><td>否</td></tr></tbody></table><ul><li><p>局限</p><ul><li>把所有内容定义为<strong>资源</strong></li><li>只能对资源作有限的<strong>四种操作</strong></li><li>例子：删除分为物理删除、标记删除；登陆登出</li></ul></li></ul><h2 id="判断接口是否restful" tabindex="-1"><a class="header-anchor" href="#判断接口是否restful" aria-hidden="true">#</a> 判断接口是否restful</h2><ul><li>看<code>url</code>就知道要什么</li><li>看<code>http method</code>就知道干什么</li><li>看<code>http status code</code>就知道结果如何</li></ul><h1 id="rpc" tabindex="-1"><a class="header-anchor" href="#rpc" aria-hidden="true">#</a> RPC</h1><ul><li>概念：<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all (远程调用过程)</li><li>解决两个问题： <ol><li>解决<strong>分布式</strong>系统中，服务之间的调用问题</li><li>远程调用时，<strong>要能够像本地调用一样方便</strong>，让调用者感知不到远程调用的逻辑</li></ol></li><li>数据格式 <ul><li>XML-RPC</li><li>JSON-RPC</li></ul></li><li>响应方式 <ul><li>同步调用：<strong>客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作</strong>。实现方式： <ul><li>WebService：基于web容器的，底层使用http协议</li><li>RMI：Java语言的RPC实现，允许方法返回 Java 对象以及基本数据类型</li></ul></li><li>异步调用：**客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。**实现方式： <ul><li>Java Message Service。JMS中间件有Kafka等消息中间件</li></ul></li></ul></li><li>架构中的内容 <ul><li>客户端</li><li>客户端存根：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方</li><li>服务器存根：接受客户端发送过来的消息并解包，再调用本地服务</li><li>服务端</li></ul></li><li>架构图<img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrjsayt4j30v10u0kjl.jpg" alt=""></li><li>需要考虑的问题 <ul><li>通讯：长连接、短连接</li><li>寻址：服务端的地址、端口、方法名。<strong>如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址</strong></li><li>序列化与反序列化</li></ul></li></ul><h1 id="rpc和rest对比" tabindex="-1"><a class="header-anchor" href="#rpc和rest对比" aria-hidden="true">#</a> RPC和REST对比</h1><p>从使用上来看</p><ul><li>Rest接口（面向资源）只关注服务提供方（服务端），客户端使用Http方式进行调用时，只要将内容进行传输即可，这样客户端在使用时，需要更关注网络方面的传输，比较不适用与业务方面的开发；（restful是服务端把方法写好，客户端通过http方式调用，直接定位到方法上面去。通过url）</li><li>RPC服务（面向方法）<strong>需要客户端接口与服务端保持一致</strong>，服务端提供一个方法，客户端通过接口直接发起调用，业务开发人员仅需要关注业务方法的调用即可，不再关注网络传输的细节，在开发上更为高效。（PRC是服务端提供好方法给客户端调用。定位到类，然后通过类去调用方法。通过服务的类名和方法名）</li></ul><h1 id="等幂" tabindex="-1"><a class="header-anchor" href="#等幂" aria-hidden="true">#</a> 等幂</h1><h2 id="http方法的等幂性" tabindex="-1"><a class="header-anchor" href="#http方法的等幂性" aria-hidden="true">#</a> HTTP方法的等幂性</h2><table><thead><tr><th style="text-align:center;">方法</th><th style="text-align:center;">幂等</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">Get</td><td style="text-align:center;">√</td><td style="text-align:center;">Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的</td></tr><tr><td style="text-align:center;">Post</td><td style="text-align:center;">×</td><td style="text-align:center;">Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的</td></tr><tr><td style="text-align:center;">Put</td><td style="text-align:center;">-</td><td style="text-align:center;">Put 方法一般用于修改资源。更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等</td></tr><tr><td style="text-align:center;">Delete</td><td style="text-align:center;">-</td><td style="text-align:center;">Delete 方法一般用于删除资源。当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除</td></tr></tbody></table><h2 id="引入幂等性后对系统的影响" tabindex="-1"><a class="header-anchor" href="#引入幂等性后对系统的影响" aria-hidden="true">#</a> 引入幂等性后对系统的影响</h2><p>优点：使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题</p><p>缺点：</p><ul><li>把并行执行的功能改为串行执行，降低了执行效率</li><li>增加了额外控制幂等的业务逻辑，复杂化了业务功能</li></ul><p>所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，<strong>一般情况下不需要引入的接口幂等性</strong></p><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h2><h3 id="数据库唯一主键" tabindex="-1"><a class="header-anchor" href="#数据库唯一主键" aria-hidden="true">#</a> 数据库唯一主键</h3><p>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，保证一张表中只能存在一条带该唯一主键的记录。</p><p>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能<strong>保证在分布式环境下 ID 的全局唯一性</strong>。</p><p><strong>适用范围</strong></p><ul><li>插入操作</li><li>删除操作</li></ul><p><strong>使用限制</strong></p><ul><li>需要生成全局唯一ID</li></ul><p><strong>主要流程</strong></p><ul><li>客户端执行创建请求，调用服务端接口</li><li>服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句</li><li>服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端</li></ul><h3 id="数据库乐观锁" tabindex="-1"><a class="header-anchor" href="#数据库乐观锁" aria-hidden="true">#</a> 数据库乐观锁</h3><p>可以提前在对应的数据表中多添加一个字段，<strong>充当当前数据的版本标识</strong>。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值</p><p><strong>适用范围</strong></p><ul><li>更新操作</li></ul><p><strong>使用限制</strong></p><ul><li>需要数据库对应业务表中添加额外字段</li></ul><p><strong>使用流程</strong></p><ul><li>在业务表中新建字段，如：Version</li><li>每次执行更新时，都要带上版本，也就是Version字段</li><li>在更新业务字段时，需要把版本也一并更新</li></ul><p><code>UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5</code></p><p>因为版本字段随着每次更新都会更新，所以重复执行这条SQL语句不会产生影响</p><h3 id="防重token令牌" tabindex="-1"><a class="header-anchor" href="#防重token令牌" aria-hidden="true">#</a> 防重Token令牌</h3><p>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，<strong>如果 Key 存在且 Value 匹配就执行删除命令</strong>，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。</p><p><strong>适用范围</strong></p><ul><li>插入操作</li><li>删除操作</li><li>更新操作</li></ul><p><strong>使用限制</strong></p><ul><li>需要生成全局唯一的Token串</li><li>需要使用Redis进行数据校验</li></ul><p><strong>使用流程</strong></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210430163529.png" alt=""></p><ul><li>服务端提供获取Token的接口，该Token可以是一个序列号，也可以是一个分布式ID</li><li>客户端向服务端发送获取Token的请求</li><li>服务端生成Token，并将其设定过其时间存储到Redis中</li><li>将Token返回给客户端</li><li>客户端发送业务请求，把Token放到请求头上，一并发送给服务端</li><li>服务端接收到请求后，从请求头中拿到Token，在Redis中检查Token是否存在。注意：<strong>在并发的情况下，执行查询和删除操作要保证原子性</strong></li><li>服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们<strong>需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式</strong></p><ul><li>对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。</li><li>对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。</li><li>对于上下游这种，下游请求上游，上游服务可以使用“下游传递唯一序列号方案”更为合理。</li><li>类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。</li></ul>',57),a=[n];function s(d,o){return l(),e("div",null,a)}const p=t(r,[["render",s],["__file","接口.html.vue"]]);export{p as default};
