const e=JSON.parse('{"key":"v-3c148bc6","path":"/writings/JavaEE/EE%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E4%BA%8B%E5%90%8E.html","title":"","lang":"zh-CN","frontmatter":{"description":"封装BaseServlet 因为在HttpServlet中的service方法就是对请求方式做了一个分发，分发到doGet方法或doPost方法。如果我们想达到一个模块的功能都在同一个Servlet，那么我们的做法是： 新建一个BaseServlet，继承HttpServlet 只重写service方法，不重写doGet、doPost，因为我们旨在修改对方法进行分发的策略 先获取uri，uri中有请求的方法 使用反射，获取对应的Method对象，参数默认还是request、response，并执行 因为后续自定义的Servlet都是继承自BaseServlet的，所以在BaseServlet中通过获取Method来执行的话实际上是自定义的Servlet来执行","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/JavaEE/EE%E6%A1%88%E4%BE%8B/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E4%BA%8B%E5%90%8E.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:description","content":"封装BaseServlet 因为在HttpServlet中的service方法就是对请求方式做了一个分发，分发到doGet方法或doPost方法。如果我们想达到一个模块的功能都在同一个Servlet，那么我们的做法是： 新建一个BaseServlet，继承HttpServlet 只重写service方法，不重写doGet、doPost，因为我们旨在修改对方法进行分发的策略 先获取uri，uri中有请求的方法 使用反射，获取对应的Method对象，参数默认还是request、response，并执行 因为后续自定义的Servlet都是继承自BaseServlet的，所以在BaseServlet中通过获取Method来执行的话实际上是自定义的Servlet来执行"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-14T05:20:02.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2022-07-14T05:20:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-07-14T05:20:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"封装BaseServlet","slug":"封装baseservlet","link":"#封装baseservlet","children":[]},{"level":2,"title":"使用Ajax","slug":"使用ajax","link":"#使用ajax","children":[]},{"level":2,"title":"为什么使用html而不使用jsp","slug":"为什么使用html而不使用jsp","link":"#为什么使用html而不使用jsp","children":[]},{"level":2,"title":"验证码","slug":"验证码","link":"#验证码","children":[]},{"level":2,"title":"BeanUtils","slug":"beanutils","link":"#beanutils","children":[]},{"level":2,"title":"BeanPropertyRowMapper","slug":"beanpropertyrowmapper","link":"#beanpropertyrowmapper","children":[]}],"git":{"createdTime":null,"updatedTime":1657776002000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":1.52,"words":456},"filePathRelative":"writings/JavaEE/EE案例/综合案例事后.md","excerpt":"<h2> 封装BaseServlet</h2>\\n<p>因为在HttpServlet中的service方法就是对请求方式做了一个分发，分发到doGet方法或doPost方法。如果我们想达到一个模块的功能都在同一个Servlet，那么我们的做法是：</p>\\n<ol>\\n<li>新建一个BaseServlet，继承HttpServlet</li>\\n<li>只重写service方法，不重写doGet、doPost，因为我们旨在修改对方法进行分发的策略</li>\\n<li>先获取uri，uri中有请求的方法</li>\\n<li>使用反射，获取对应的Method对象，参数默认还是request、response，并执行</li>\\n<li>因为后续自定义的Servlet都是继承自BaseServlet的，所以在BaseServlet中通过获取Method来执行的话实际上是自定义的Servlet来执行</li>\\n</ol>","autoDesc":true}');export{e as data};
