import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e}from"./app-85442c0b.js";const t={},p=e(`<h1 id="java-线程基本知识" tabindex="-1"><a class="header-anchor" href="#java-线程基本知识" aria-hidden="true">#</a> Java 线程基本知识</h1><h2 id="在-java-中如何创建线程" tabindex="-1"><a class="header-anchor" href="#在-java-中如何创建线程" aria-hidden="true">#</a> 在 Java 中如何创建线程</h2><h3 id="继承-thread-类" tabindex="-1"><a class="header-anchor" href="#继承-thread-类" aria-hidden="true">#</a> 继承 Thread 类</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadDemo线程运行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadDemo</span> threadDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadDemo<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过调用 <code>start</code> 方法，JVM 会创建出一个线程，等到这个线程得到 CPU 时间片后，会调用 <code>run</code> 方法真正执行</p><h3 id="实现-runnable-接口" tabindex="-1"><a class="header-anchor" href="#实现-runnable-接口" aria-hidden="true">#</a> 实现 Runnable 接口</h3><p>JDK8 提供了 Lambda 表达式和函数式接口这两个特性，可以快速实现，无需创建真正的实现类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;实现Runnable线程运行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="thread-和-runnable-对比" tabindex="-1"><a class="header-anchor" href="#thread-和-runnable-对比" aria-hidden="true">#</a> Thread 和 Runnable 对比</h3><ul><li>设计原则中有一条：合成复用原则，能使用接口(组合关系)就不要使用子类(继承关系)，使用接口耦合度更低</li><li>如果使用线程时，不需要使用 Thread 类中其他的方法，显然使用 Runnable 接口会更为轻量，因为只需要实现关键的 <code>run</code> 方法</li></ul><p><strong>所以优先使用实现 Runnable 接口这种方式来创建线程</strong></p><h3 id="callable-future" tabindex="-1"><a class="header-anchor" href="#callable-future" aria-hidden="true">#</a> Callable + Future</h3><p>如果我们希望这个线程任务在执行完成后能有一个返回值，那么 Thread 和 Runnable 的做法就不够用了，JDK 提供了 Callable 和 FutrueTask 解决这个问题</p><p>Callable 接口和 Runnable 接口类似，同样只有一个抽象方法，不同的是 Callable 中的方法有返回值，还支持泛型，并且还能抛出异常</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Callable 一般很少和 Thread 来配合使用，一般都是配合线程池来使用</p></blockquote><p>Future 接口代表一个异步计算的结果，提供了检查计算是否完成、是否取消，获取计算结果的方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>执行 get 方法时，当前线程会进入阻塞状态，直到等到结果返回</p></blockquote><p>Callable 和 Future 各司其职，Callable 负责产生数据，Future 负责接收结果</p><h3 id="callable-futuretask" tabindex="-1"><a class="header-anchor" href="#callable-futuretask" aria-hidden="true">#</a> Callable + FutureTask</h3><p>FutureTask 是 Future 的一个实现类，使用 Callable + FutureTask 区别不会太大，使用 FutureTask 的话，就把定义任务、获取结果这两步都包装起来了，结果没有差别</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="java-线程的状态及转换" tabindex="-1"><a class="header-anchor" href="#java-线程的状态及转换" aria-hidden="true">#</a> Java 线程的状态及转换</h2><h3 id="操作系统中线程状态转换" tabindex="-1"><a class="header-anchor" href="#操作系统中线程状态转换" aria-hidden="true">#</a> 操作系统中线程状态转换</h3><p>操作系统中的线程主要有以下三种状态</p><ul><li>就绪状态（ready）：线程正在等待使用 CPU，等待调度后可以进入执行状态</li><li>执行状态（running）：线程正在使用 CPU 资源</li><li>等待状态（waiting）：线程等待事件调用或者等待其他资源（IO 资源）</li><li>结束状态（terminated）：线程任务执行完毕后退出</li></ul><h3 id="java-线程的-6-个状态" tabindex="-1"><a class="header-anchor" href="#java-线程的-6-个状态" aria-hidden="true">#</a> Java 线程的 6 个状态</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Thread.State</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
    <span class="token constant">NEW</span><span class="token punctuation">,</span>
    <span class="token constant">RUNNABLE</span><span class="token punctuation">,</span>
    <span class="token constant">BLOCKED</span><span class="token punctuation">,</span>
    <span class="token constant">WAITING</span><span class="token punctuation">,</span>
    <span class="token constant">TIMED_WAITING</span><span class="token punctuation">,</span>
    <span class="token constant">TERMINATED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>NEW，位于这个状态的</li></ul>`,30),c=[p];function l(o,u){return a(),s("div",null,c)}const d=n(t,[["render",l],["__file","thread-base.html.vue"]]);export{d as default};
