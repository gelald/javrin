const e=JSON.parse('{"key":"v-7660a357","path":"/writings/RocketMQ/MessageQueue.html","title":"消息队列基本概念","lang":"zh-CN","frontmatter":{"description":"消息队列基本概念 为什么使用消息队列 解耦 传统：系统间直接耦合，每接入一个系统，都需要修改代码 中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改 异步 传统：一些非必要的业务逻辑以同步的方式运行，比较耗费时间 中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度 削峰 传统：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常 中间件：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/RocketMQ/MessageQueue.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"消息队列基本概念"}],["meta",{"property":"og:description","content":"消息队列基本概念 为什么使用消息队列 解耦 传统：系统间直接耦合，每接入一个系统，都需要修改代码 中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改 异步 传统：一些非必要的业务逻辑以同步的方式运行，比较耗费时间 中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度 削峰 传统：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常 中间件：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T10:49:34.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-04T10:49:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列基本概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-04T10:49:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"为什么使用消息队列","slug":"为什么使用消息队列","link":"#为什么使用消息队列","children":[]},{"level":2,"title":"使用了消息队列会有什么缺点","slug":"使用了消息队列会有什么缺点","link":"#使用了消息队列会有什么缺点","children":[]},{"level":2,"title":"如何保证消息队列是高可用的","slug":"如何保证消息队列是高可用的","link":"#如何保证消息队列是高可用的","children":[]},{"level":2,"title":"什么情况下的异步操作需要使用消息队列而不是多线程","slug":"什么情况下的异步操作需要使用消息队列而不是多线程","link":"#什么情况下的异步操作需要使用消息队列而不是多线程","children":[]},{"level":2,"title":"ActiveMQ","slug":"activemq","link":"#activemq","children":[]},{"level":2,"title":"RabbitMQ","slug":"rabbitmq","link":"#rabbitmq","children":[]},{"level":2,"title":"RocketMQ","slug":"rocketmq","link":"#rocketmq","children":[]},{"level":2,"title":"Kafka","slug":"kafka","link":"#kafka","children":[]}],"git":{"createdTime":1677926974000,"updatedTime":1677926974000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":2.21,"words":663},"filePathRelative":"writings/RocketMQ/MessageQueue.md","localizedDate":"2023年3月4日","excerpt":"<h1> 消息队列基本概念</h1>\\n<h2> 为什么使用消息队列</h2>\\n<ul>\\n<li>\\n<p>解耦</p>\\n<ul>\\n<li>\\n<p>传统：系统间直接耦合，每接入一个系统，都需要修改代码</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzlaeqd1qj30fl0a7wf7.jpg\\" alt=\\"img\\"></p>\\n</li>\\n<li>\\n<p>中间件：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzlang3m1j30dl0a7t9a.jpg\\" alt=\\"img\\"></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>异步</p>\\n<ul>\\n<li>\\n<p>传统：一些非必要的业务逻辑以同步的方式运行，比较耗费时间</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzlcld8bfj30i408bwev.jpg\\" alt=\\"img\\"></p>\\n</li>\\n<li>\\n<p>中间件：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzlcs8ebdj30hp09fwf3.jpg\\" alt=\\"img\\"></p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>削峰</p>\\n<ul>\\n<li>\\n<p>传统：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzldnsbj9j30e90dwaao.jpg\\" alt=\\"img\\"></p>\\n</li>\\n<li>\\n<p>中间件：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的</p>\\n<p><img src=\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1ggzldxkusnj30if0dwgme.jpg\\" alt=\\"img\\"></p>\\n</li>\\n</ul>\\n</li>\\n</ul>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
