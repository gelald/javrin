import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as o,b as l,e,d as s,w as c,a as n,o as p}from"./app-R_JIpTO7.js";const r={},d=n('<h1 id="mysql优化" tabindex="-1"><a class="header-anchor" href="#mysql优化"><span>MySQL优化</span></a></h1><blockquote><p>这一节我们来看 MySQL 优化。一谈到 MySQL 优化，我们往往第一时间就想到了加索引，加索引确实是优化的其中一个手段，但是也要加「对」索引，更重要的是还有其他有效但少有提及的做法。</p><p>快速的查询，不光光是体验的友好，更是技术的彰显。</p></blockquote><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h2><p>显而易见地，在数据量不是很大的情况下，用索引往往可以提升查询的效率，而大多慢查询也和索引不合理产生。</p><h3 id="组合索引" tabindex="-1"><a class="header-anchor" href="#组合索引"><span>组合索引</span></a></h3><p>有些时候我们会尽可能地去建一些组合索引，能有效提升查询的效率，我们希望出现这两种情况：</p><p>索引下推：如果查询条件包含在了组合索引中，比如存在组合索引（a,b)，查询到满足 a 的记录后会直接在索引内部判断 b 是否满足，减少回表次数。</p><p>覆盖索引：如果查询的列恰好包含在组合索引中，就无需回表。</p><h3 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效"><span>索引失效</span></a></h3><p>加索引可以提高查询效率，但是往往会出现加了索引查询还是慢的情况。原因多半还是索引失效（未命中索引），是否使用上索引可以通过 <code>explain</code> 关键字进行分析。</p>',10),u=n(`<h2 id="select-惹的祸" tabindex="-1"><a class="header-anchor" href="#select-惹的祸"><span>select * 惹的祸</span></a></h2><p>很多时候为了图方便，就直接使用 <code>select *</code> 一次性查出表中所有的列，无论是否用上。</p><p>实际上在真正的业务场景下，需要的可能只是其中某几列，查了很多数据，实际上白白浪费了宝贵的内存和 CPU 资源，查询出来的数据 进行 IO 传输时也会<strong>消耗更多时间</strong>，这就是慢的原因！</p><p>此外，使用 <code>select *</code> 也就无法达到覆盖索引的条件，会造成<strong>大量回表操作</strong>，导致性能很低！</p><blockquote><p>所以在开发的时候需要严格遵循需要什么列就查什么列的规则。</p></blockquote><h2 id="union-和-union-all" tabindex="-1"><a class="header-anchor" href="#union-和-union-all"><span>union 和 union all</span></a></h2><p>在 MySQL 中，<code>union</code> 和 <code>union all</code> 都可以实现取并集的功能，只不过两者有一些小区别</p><ul><li>对重复结果的处理：<code>union</code> 会进行去重操作，而 <code>union all</code> 只是简单地合并两个结果集</li><li>对结果排序的处理：<code>union</code> 会根据字段进行排序，而 <code>union all</code> 只是简单地合并两个结果集</li></ul><p>从以上来看，<code>union</code> 显然不是简单地完成并集的工作，还包含了筛选和排序，换言之效率要比 <code>union all</code> 要低。</p><blockquote><p>所以除非是特殊的场景，不允许有重复值，那么尽量使用 <code>union all</code> 进行合并结果集。</p></blockquote><h2 id="分页优化" tabindex="-1"><a class="header-anchor" href="#分页优化"><span>分页优化</span></a></h2><p>t 表中包含 100w 条数据，现在按每页 20 条数据分页查询 serllerid 为 100 的第 10w 页数据，索引是 serllerid。</p><p>普通做法：<code>limit M, N</code></p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select * from t where serllerid = 100 limit 100000, 20;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>!-- 20 rows in set(90 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到时间成本巨大，在普通的 <code>limit M, N</code> 翻页写法，往往在越往后翻页的过程中速度越慢，原因是MySQL会读取表中的前 M+N 条数据，M 越大，性能越差。</p><p>优化做法：先查询翻页中需要的 N 条数据的主键，再根据 id 回表查询所需要的N条数据。查询 N 条数据的主键在索引中完成的，所以速度更快。</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select * from t t1, (select id from t where serllerid = 100 limit 100000, 20) t2 where t1.id = t2.id;</span></span>
<span class="line"><span>!-- 20 rows in set(4.25 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到由于走了索引后再回表，速度大大提升。</p><h2 id="不要过于频繁执行-count" tabindex="-1"><a class="header-anchor" href="#不要过于频繁执行-count"><span>不要过于频繁执行 count(*)</span></a></h2><p>在 MySQL 中 count(*) 负责统计表中记录总数，count(*) 的性能和存储引擎息息相关</p><p>MySQL 中最常用的两个存储引擎：MyISAM、Innodb</p><ul><li>MyISAM：由于 MyISAM 会把总行数记录到磁盘中，所以当使用 count(*) 获取总数时，只需要从磁盘中返回这个数值即可，没有额外的计算，效率相对较高，无论表中数据量有多大。</li><li>Innodb：因为 Innodb 支持事务，有 MVCC 的存在，在同一时间不同的事务中，使用 count(*) 获取到的数值可能是不确定的。在 Innodb 中使用 count(*) 时，需要从存储引擎中一行一行地读取出数据，然后累加起来，效率相对较低，特别当表中的数据量很大时。</li></ul><p>可以使用缓存 + 适当的过期时间来完成总数的缓存；或者是使用多线程来完成总数的查询的工作。</p><p>既然说到 count(*)，就不能不说一下 count 家族的其他成员，比如：count(1)、count(主键)、count(普通索引列)、count(未加索引列)。</p><p>那么它们有什么区别呢？</p><ul><li>count(*) ：它会获取所有行的数据，不做任何处理，行数加1。</li><li>count(1)：它会获取所有行的数据，每行固定值1，也是行数加1。</li><li>count(主键)：它需要从所有行的数据中解析出主键字段，其中主键肯定都不为NULL，行数加1。</li><li>count(普通索引列)：它需要从所有行的数据中解析出普通索引列，然后判断是否为NULL，如果不是NULL，则行数+1。</li><li>count(未加索引列)：它会全表扫描获取所有数据，解析中未加索引列，然后判断是否为NULL，如果不是NULL，则行数+1。</li></ul><p>由此，最后count的性能从高到低是：</p><blockquote><p>count(*) ≈ count(1) &gt; count(主键) &gt; count(普通索引列) &gt; count(未加索引列)</p></blockquote><p>在统计总数时尽量使用 count(*) 和 count(1)</p><h2 id="建立索引规则" tabindex="-1"><a class="header-anchor" href="#建立索引规则"><span>建立索引规则</span></a></h2><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20221102112736.png" alt=""></p><p><img src="https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20221102144957.png" alt=""></p>`,32);function h(m,g){const t=a("RouteLink");return p(),o("div",null,[d,l("p",null,[e("索引失效原因可以看这篇文章："),s(t,{to:"/writings/MySQL/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF.html"},{default:c(()=>[e("为什么加了索引，查询还是慢？")]),_:1})]),u])}const L=i(r,[["render",h],["__file","MySQL-optimization-2.html.vue"]]),M=JSON.parse('{"path":"/writings/MySQL/MySQL-optimization-2.html","title":"MySQL 优化","lang":"zh-CN","frontmatter":{"title":"MySQL 优化","icon":"article","category":["数据库"],"tag":["MySQL","优化"],"description":"MySQL优化 这一节我们来看 MySQL 优化。一谈到 MySQL 优化，我们往往第一时间就想到了加索引，加索引确实是优化的其中一个手段，但是也要加「对」索引，更重要的是还有其他有效但少有提及的做法。 快速的查询，不光光是体验的友好，更是技术的彰显。 索引 显而易见地，在数据量不是很大的情况下，用索引往往可以提升查询的效率，而大多慢查询也和索引不合理...","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/MySQL/MySQL-optimization-2.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"MySQL 优化"}],["meta",{"property":"og:description","content":"MySQL优化 这一节我们来看 MySQL 优化。一谈到 MySQL 优化，我们往往第一时间就想到了加索引，加索引确实是优化的其中一个手段，但是也要加「对」索引，更重要的是还有其他有效但少有提及的做法。 快速的查询，不光光是体验的友好，更是技术的彰显。 索引 显而易见地，在数据量不是很大的情况下，用索引往往可以提升查询的效率，而大多慢查询也和索引不合理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20221102112736.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"优化"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 优化\\",\\"image\\":[\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20221102112736.png\\",\\"https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20221102144957.png\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"索引","slug":"索引","link":"#索引","children":[{"level":3,"title":"组合索引","slug":"组合索引","link":"#组合索引","children":[]},{"level":3,"title":"索引失效","slug":"索引失效","link":"#索引失效","children":[]}]},{"level":2,"title":"select * 惹的祸","slug":"select-惹的祸","link":"#select-惹的祸","children":[]},{"level":2,"title":"union 和 union all","slug":"union-和-union-all","link":"#union-和-union-all","children":[]},{"level":2,"title":"分页优化","slug":"分页优化","link":"#分页优化","children":[]},{"level":2,"title":"不要过于频繁执行 count(*)","slug":"不要过于频繁执行-count","link":"#不要过于频繁执行-count","children":[]},{"level":2,"title":"建立索引规则","slug":"建立索引规则","link":"#建立索引规则","children":[]}],"git":{"createdTime":null,"updatedTime":1677655655000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":1},{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":4.91,"words":1474},"filePathRelative":"writings/MySQL/MySQL-optimization-2.md","autoDesc":true}');export{L as comp,M as data};
