const e=JSON.parse('{"key":"v-0cd905a6","path":"/writings/algorithm/moore-voting.html","title":"摩尔投票法","lang":"zh-CN","frontmatter":{"title":"摩尔投票法","icon":"article","category":["算法"],"tag":["统计"],"description":"摩尔投票法 一般用法 概念 解决的问题：在任意多的候选人中选出票数超过一半的那个人。和哈希法相比，只有常量级的空间复杂度，哈希表需要开辟额外的空间，需要线性空间复杂度 前提：票数要超过一半，这样就可以得到一个结论就是票数超过一半的人至多只有一个 大致过程： 投票阶段：从前往后统计候选人的票数，如果票相同，那么票数+1；如果票不同，那么票数-1，当票数为0时需要更换候选人 计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/algorithm/moore-voting.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"摩尔投票法"}],["meta",{"property":"og:description","content":"摩尔投票法 一般用法 概念 解决的问题：在任意多的候选人中选出票数超过一半的那个人。和哈希法相比，只有常量级的空间复杂度，哈希表需要开辟额外的空间，需要线性空间复杂度 前提：票数要超过一半，这样就可以得到一个结论就是票数超过一半的人至多只有一个 大致过程： 投票阶段：从前往后统计候选人的票数，如果票相同，那么票数+1；如果票不同，那么票数-1，当票数为0时需要更换候选人 计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:55:52.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:tag","content":"统计"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:55:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"摩尔投票法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:55:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"一般用法","slug":"一般用法","link":"#一般用法","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}]},{"level":2,"title":"推广用法","slug":"推广用法","link":"#推广用法","children":[{"level":3,"title":"概念","slug":"概念-1","link":"#概念-1","children":[]},{"level":3,"title":"代码实现","slug":"代码实现-1","link":"#代码实现-1","children":[]}]},{"level":2,"title":"leetcode169.多数元素","slug":"leetcode169-多数元素","link":"#leetcode169-多数元素","children":[]},{"level":2,"title":"leetcode229.多数元素Ⅱ","slug":"leetcode229-多数元素ii","link":"#leetcode229-多数元素ii","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1659199509000,"updatedTime":1677599752000,"contributors":[{"name":"gelald","email":"yb.ng@foxmail.com","commits":2},{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":8.75,"words":2624},"filePathRelative":"writings/algorithm/moore-voting.md","localizedDate":"2022年7月30日","excerpt":"<h1> 摩尔投票法</h1>\\n<h2> 一般用法</h2>\\n<h3> 概念</h3>\\n<p>解决的问题：在任意多的候选人中选出<strong>票数超过一半</strong>的那个人。和哈希法相比，只有<strong>常量级的空间复杂度</strong>，哈希表需要开辟额外的空间，需要线性空间复杂度</p>\\n<p>前提：票数要超过一半，这样就可以得到一个结论就是<strong>票数超过一半的人至多只有一个</strong></p>\\n<p>大致过程：</p>\\n<ul>\\n<li>投票阶段：从前往后统计候选人的票数，如果票相同，那么票数+1；如果票不同，那么票数-1，当票数为0时需要更换候选人</li>\\n<li>计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定</li>\\n</ul>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
