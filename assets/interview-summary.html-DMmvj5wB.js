import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as i}from"./app-Svu5x8lo.js";const n={};function l(s,a){return i(),t("div",null,[...a[0]||(a[0]=[r('<h2 id="java-语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#java-语言有哪些特点"><span>Java 语言有哪些特点</span></a></h2><ol><li>面向对象（封装、继承、多态）</li><li>跨平台（ Java 虚拟机实现了平台无关性）</li><li>支持多线程</li></ol><p>「一次编写，随处运行」这句口号非常经典，直到今天依然有很多人都认为 Java 的跨平台特性是其最大的优点，但其实现在跨平台技术也相当成熟了，比如通过 Docker 也可以轻松实现跨平台，因为有 Docker Engine 帮它实现了跨平台的特性，在我看来，Java 最大的优势是前期跨平台的优势而积累下来的强大的生态。</p><h2 id="面向对象的三大特性" tabindex="-1"><a class="header-anchor" href="#面向对象的三大特性"><span>面向对象的三大特性</span></a></h2><p>封装</p><p>继承</p><p>多态</p><h2 id="jvm-jre-jdk-区别" tabindex="-1"><a class="header-anchor" href="#jvm-jre-jdk-区别"><span>JVM JRE JDK 区别</span></a></h2><ul><li><p>JVM：Java 虚拟机，Java 源代码编译后生成 Java 字节码文件，由 Java 虚拟机运行。字节码文件和不同操作系统上的JVM是实现跨平台特性的关键</p></li><li><p>JRE：Java 运行环境，JRE 是运行 Java 程序所需内容的集合，包括 JVM 和 Java 类库等</p></li><li><p>JDK：Java 开发工具包，能够创建、编译、运行程序。除了包含 JRE，还提供了一系列的开发工具，如编译器 javac、查看 Java 程序进程工具 jps、反编译工具 javap 等</p></li></ul><h2 id="什么是字节码-采用字节码的好处" tabindex="-1"><a class="header-anchor" href="#什么是字节码-采用字节码的好处"><span>什么是字节码，采用字节码的好处</span></a></h2><p>Java 源代码经过 Java 编译器后就生成了 JVM 能理解的字节码</p><p>采用字节码的好处</p><ul><li>实现跨平台特性：Java 源代码经过编译后生成的字节码是由不同操作系统的 JVM 来运行的，所以 Java 程序无须重新编译便可在多种不同操作系统的计算机上运行</li><li>编译和解释并存：Java 源代码经过 Java 编译器后生成字节码，运行时由 Java 解释器生成机器码（热点代码问题由 JIT 编译器处理），同时具备了编译型语言和解释型语言的特点，所以能同时保证开发和机器执行的速度</li></ul><h2 id="方法重写和方法重载的区别" tabindex="-1"><a class="header-anchor" href="#方法重写和方法重载的区别"><span>方法重写和方法重载的区别</span></a></h2><p>方法重写和方法重载是 Java 多态性的不同表现</p><ul><li><p>方法重写</p><ul><li>方法重写存在于<strong>继承体系</strong>中</li><li>需要在<strong>运行期</strong>根据具体对象的类型才能确定使用的方法</li><li>方法重写需要遵循【<strong>两同两小一大</strong>】的规则 <ul><li>两同：方法名相同、参数列表相同</li><li>两小：子类方法返回值要<strong>小于等于</strong>父类方法返回值类型、子类方法声明抛出的异常类型和比父类声明抛出的异常类型<strong>应该相等或抛出更少、更具体的异常，甚至不抛出</strong></li><li>一大：子类方法的访问权限要比父类方法的访问权限更大或相等</li></ul></li></ul></li><li><p>方法重载</p><ul><li>方法重载存在于同一个类中，也可以放生在继承体系中（重载父类的方法）</li><li>在<strong>编译期</strong>根据参数列表就可以确定使用哪一个方法</li><li>方法重载可以是参数类型不同、个数不同、顺序不同、声明抛出异常不同，但是<strong>返回值类型必须相同</strong></li></ul></li></ul><h2 id="包装类型与基本类型的区别" tabindex="-1"><a class="header-anchor" href="#包装类型与基本类型的区别"><span>包装类型与基本类型的区别</span></a></h2><ol><li><p>从类型上来看：<strong>包装类型可用于泛型，而基本类型不可以</strong>。因为泛型在编译时会进行<strong>类型擦除</strong>，最后只保留<strong>原始类型</strong>，而原始类型只能是 <strong>Object 类及其子类</strong>。包装类型的都是Object的子类，而基本类型没有所谓的原始类型。</p></li><li><p>从值来看：<strong>包装类型可以为 null，基本类型不可以</strong>。包装类型可以应用于 POJO 的属性类型，基本一般来说不太推荐。因为数据库的查询结果可能是 null，如果使用基本类型的话，就可能会抛出 <code>NullPointerException</code> 的异常。</p></li><li><p>从比较环节来看：<strong>基本类型使用 == 进行比较；包装类型需要使用 equals 方法进行比较，用 == 比较的是地址值</strong>。此外，<strong>包装类型和基本类型进行 == 比较的时候会自动拆箱。</strong></p></li><li><p>总体上来说：<strong>基本类型比包装类型更高效</strong>。基本类型在栈中直接存储的具体数值，而包装类型在栈中存储的是堆中的引用。很显然，相比较于基本类型而言，<strong>包装类型需要占用更多的内存空间</strong>。</p></li></ol><h2 id="成员变量和局部变量的区别" tabindex="-1"><a class="header-anchor" href="#成员变量和局部变量的区别"><span>成员变量和局部变量的区别</span></a></h2><ol><li>从语法上看：成员变量是定义在类里面的，并且有访问修饰符；局部变量是定义在方法或者代码块里面的，不能使用访问修饰符</li><li>从存储位置来看：对象存储在堆中，所以成员变量也是存储在堆中；局部变量随着方法入栈而创建，所以局部变量存储在栈中</li><li>从默认值来看：成员变量在定义时如果没有赋予初始值，则自动以类型的默认值进行复制；局部变量则不会自动赋值</li></ol><h2 id="接口和抽象类的共同点和区别" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的共同点和区别"><span>接口和抽象类的共同点和区别</span></a></h2><h2 id="深拷贝和浅拷贝的区别" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝的区别"><span>深拷贝和浅拷贝的区别</span></a></h2><h2 id="string、stringbuffer、stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer、stringbuilder-的区别"><span>String、StringBuffer、StringBuilder 的区别</span></a></h2><h2 id="hashcode-方法与-equals-方法" tabindex="-1"><a class="header-anchor" href="#hashcode-方法与-equals-方法"><span>hashCode 方法与 equals 方法</span></a></h2><p>hashCode 方法返回对象的哈希码</p><p>HashSet等容器会根据两个对象的 hashCode 是否相等来决定两个对象是否相同</p><p>但是两个对象 hashCode 相等，不一定代表两个对象相同，因为会存在【哈希冲突】，也就是说使用的哈希算法刚好让两个对象返回了相同的哈希码</p><p>如果两个对象 hashCode 相等会继续调用其 equals 方法来进一步判断，也就是说使用 hashCode 能帮助我们减少对比的成本</p><p>结论：</p><ul><li>如果两个对象 hashCode 相等，那这两个对象不一定相等（存在哈希冲突）</li><li>如果两个对象 hashCode 相等，而且 equals 方法也返回 true，那么这两个对象可以认为是相等的</li><li>如果两个对象 hashCode 不相等，那么可以直接认为这个对象是不相等的</li></ul><p>重写 equals 方法必须重写 hashCode 方法的原因</p><p>因为两个对象 equals 方法返回 true，那么它们的 hashCode 必须要相等</p>',32)])])}const h=e(n,[["render",l]]),d=JSON.parse('{"path":"/writings/Java-base/interview-summary.html","title":"Java 基础面试题总结","lang":"zh-CN","frontmatter":{"title":"Java 基础面试题总结","icon":"article","category":["Java基础"],"tag":["面试题"],"description":"Java 语言有哪些特点 面向对象（封装、继承、多态） 跨平台（ Java 虚拟机实现了平台无关性） 支持多线程 「一次编写，随处运行」这句口号非常经典，直到今天依然有很多人都认为 Java 的跨平台特性是其最大的优点，但其实现在跨平台技术也相当成熟了，比如通过 Docker 也可以轻松实现跨平台，因为有 Docker Engine 帮它实现了跨平台的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 基础面试题总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-28T15:46:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/Java-base/interview-summary.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"Java 基础面试题总结"}],["meta",{"property":"og:description","content":"Java 语言有哪些特点 面向对象（封装、继承、多态） 跨平台（ Java 虚拟机实现了平台无关性） 支持多线程 「一次编写，随处运行」这句口号非常经典，直到今天依然有很多人都认为 Java 的跨平台特性是其最大的优点，但其实现在跨平台技术也相当成熟了，比如通过 Docker 也可以轻松实现跨平台，因为有 Docker Engine 帮它实现了跨平台的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T15:46:06.000Z"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2023-02-28T15:46:06.000Z"}]]},"git":{"createdTime":1677597613000,"updatedTime":1677599166000,"contributors":[{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":2,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":5.37,"words":1612},"filePathRelative":"writings/Java-base/interview-summary.md","autoDesc":true}');export{h as comp,d as data};
