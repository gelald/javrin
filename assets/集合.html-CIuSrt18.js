import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as t}from"./app-DVmJHiRi.js";const n={};function r(l,s){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h1><p><strong>底层是对象数组</strong>，和普通数组相比，它的容量能动态地增长。</p><p>属于线性表的存储结构，<strong>插入</strong>、<strong>删除</strong>的时间复杂度为O(n)，求<strong>表长度</strong>、<strong>增加元素(增加到尾部)</strong>、<strong>查询第i个元素</strong>时间复杂度为O(1)</p><p>ArrayList <strong>继承了AbstractList，实现了List</strong>。提供了相关的<strong>添加、删除、修改、遍历</strong>等功能。</p><p>ArrayList 实现了<strong>RandomAccess 接口</strong>， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p><p>ArrayList 实现了<strong>Cloneable 接口</strong>，即覆盖了函数 clone()，<strong>能被克隆</strong>。</p><p>ArrayList 实现了<strong>Serializable 接口</strong>，这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p><p>和 Vector 不同，<strong>ArrayList 中的操作不是线程安全的</strong>！所以，建议在<strong>单线程中才使用</strong> ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</p><p>length：数组长度，初始默认大小为<strong>10</strong>；size：元素个数</p><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法"><span>构造方法</span></a></h3><ul><li>ArrayList(int initialCapacity) <ul><li>创建一个指定容量的ArrayList，如果容量为0，<code>this.elementData = EMPTY_ELEMENTDATA</code></li></ul></li><li>ArrayList() <ul><li>默认构造方法，初始化一个空数组<code>this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，当插入第一个元素的时候容量才变成10</li></ul></li><li>ArrayList(Collection&lt;? extends E&gt; c) <ul><li>构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序，传入集合元素个数大于0，否则用空数组代替<code>this.elementData = EMPTY_ELEMENTDATA</code></li></ul></li></ul><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制"><span>扩容机制</span></a></h3><p>为避免频繁插入导致频繁的拷贝、导致性能降低，所以不能每次扩容一个</p><p><strong>ensureCapacityInternal(int) 每次插入前都执行 （自动扩容）</strong></p><ol><li>计算最小扩容量 <ol><li>如果是空数组，比较默认最小长度和需要的最小容量，取较大值</li><li>如果不是，最小扩容量就是所需最小容量</li></ol></li><li>判断是否需要扩容 <ol><li>如果最小扩容量比原数组容量要大，则扩容</li></ol></li><li><strong>扩容核心方法</strong><ol><li>旧容量：原数组容量</li><li>新容量：旧容量*1.5</li><li>检查下限。如果新容量比最小扩容量小，那么新容量等于最小扩容量</li><li>检查上限。如果新容量比ArrayList所定义的最大容量大，那么判断最小扩容量和最大容量的关系 <ol><li>如果最小扩容量比最大容量大，那么新容量等于Integer.MAX_VALUE</li><li>如果最小扩容量比最大容量小，那么新容量等于最大容量</li></ol></li><li>调用Arrays.copyOf(elementData, 新容量)，将原有数据复制到一个具有新容量这么大的数组中</li></ol></li></ol><p><strong>ensureCapacity(int) 手动扩容 （插入数据时一次性扩容）</strong></p><ol><li>通过默认最小容量和最小需求容量来判断是否有必要扩容。 <ol><li>空数组，比较最小需求容量和10，需求容量大于10，下一步；小雨10，不需扩容</li><li>有内容，直接下一步</li></ol></li><li>判断是否需要扩容 <ol><li>如果最小扩容量比原数组容量大，则扩容</li></ol></li><li>扩容</li></ol><h3 id="其他方法" tabindex="-1"><a class="header-anchor" href="#其他方法"><span>其他方法</span></a></h3><p>IndexOf(Object) 和 lastIndexOf(Object)</p><ul><li>相同： <ol><li>如果找到元素，返回对应索引；如果没有找到，返回-1</li><li>能接受传入的参数为null，那就去寻找null值出现的<strong>位置</strong></li><li>同样是返回第一次出现的位置</li></ol></li><li>差异： <ol><li>indexOf是从前往后寻找；lastIndexOf是从后往前寻找；</li></ol></li></ul><p>trimToSize 修剪方法</p><p>修改这个ArrayList实例的容量为列表的当前大小。 用此操作来最小化ArrayList实例的存储。如果列表长度为0，修改为空数组EMPTY_ELEMENTDATA，否则使用Arrays.copyOf(elementData, size)，创建一个长度为size，元素和elementData一样长的数组</p><p>toArray() 和 toArray(T[] a)</p><p>toArray() 以正确的顺序返回一个安全的（列表不保留对其元素的引用，分配的是一个新的数组）和ArrayList具有相同元素的对象数组，数组长度为元素个数</p><p>Arrays.copyOf() 和 Systems.arrayCopy()</p><p>联系：</p><p>copyOf内部调用了arrayCopy</p><p>区别：</p><ol><li>arraycopy()<strong>需要目标数组</strong>，将原数组拷贝到你自己定义的数组里，而且可以选择<strong>拷贝的起点</strong>和<strong>长度</strong>以及放入新数组中的<strong>位置</strong></li><li>copyOf()是系统自动在内部<strong>新建一个数组</strong>，并返回该数组。</li></ol><p><em>Arrays.toList</em></p><h3 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h3><ul><li><strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>， <strong>next()</strong>， <strong>remove()</strong> 等方法</li><li><strong>ListItr</strong> 继承 <strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法</li></ul><h1 id="stream" tabindex="-1"><a class="header-anchor" href="#stream"><span>Stream</span></a></h1><h3 id="关心两个问题-流水线、自动并行" tabindex="-1"><a class="header-anchor" href="#关心两个问题-流水线、自动并行"><span>关心两个问题：流水线、自动并行</span></a></h3><h2 id="操作分类" tabindex="-1"><a class="header-anchor" href="#操作分类"><span>操作分类</span></a></h2><h3 id="中间操作-中间操作只是一种标记" tabindex="-1"><a class="header-anchor" href="#中间操作-中间操作只是一种标记"><span>中间操作:中间操作只是一种标记</span></a></h3><h4 id="无状态-元素的处理不受前面元素的影响-操作的次序可以交换" tabindex="-1"><a class="header-anchor" href="#无状态-元素的处理不受前面元素的影响-操作的次序可以交换"><span>无状态:元素的处理不受前面元素的影响(操作的次序可以交换)</span></a></h4><p><code>unordered()</code><code>filter()</code><code>peek()</code><code>map()</code><code>mapToInt()</code><code>mapToLong()</code><code>mapToDouble()</code><code>flatMap()</code><code>flatMapToInt()</code><code>flatMapToLong()</code><code>flatMapToDouble()</code></p><h4 id="有状态-必须等到所有元素处理之后才知道最终结果-操作的次数不可以交换-一旦交换则产生影响" tabindex="-1"><a class="header-anchor" href="#有状态-必须等到所有元素处理之后才知道最终结果-操作的次数不可以交换-一旦交换则产生影响"><span>有状态:必须等到所有元素处理之后才知道最终结果(操作的次数不可以交换，一旦交换则产生影响)</span></a></h4><p><code>sorted()</code><code>district()</code><code>limit()</code><code>skip()</code></p><h3 id="结束操作-结束操作才会触发实际计算" tabindex="-1"><a class="header-anchor" href="#结束操作-结束操作才会触发实际计算"><span>结束操作:结束操作才会触发实际计算</span></a></h3><h4 id="非短路操作-处理全部元素才可以返回结果" tabindex="-1"><a class="header-anchor" href="#非短路操作-处理全部元素才可以返回结果"><span>非短路操作:处理全部元素才可以返回结果</span></a></h4><p><code>forEach()</code><code>forEachOrdered()</code><code>toArray()</code><code>reduce()</code><code>collect()</code><code>max()</code><code>min()</code><code>count()</code></p><h4 id="短路操作-不用处理全部元素就可以返回结果" tabindex="-1"><a class="header-anchor" href="#短路操作-不用处理全部元素就可以返回结果"><span>短路操作:不用处理全部元素就可以返回结果</span></a></h4><p><code>anyMatch()</code><code>allMatch()</code><code>noneMatch()</code><code>findFirst()</code><code>findAny()</code></p><h2 id="例子理解" tabindex="-1"><a class="header-anchor" href="#例子理解"><span>例子理解</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">IntStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">A&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">limit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;B&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forEach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;C&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>A1B1C1</span></span>
<span class="line"><span>A2B2C2</span></span>
<span class="line"><span>A3B3C3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1、peek、limit方法都是懒惰的中间操作，不会立马执行，只有执行到热情的结束操作，才会执行。</span></span>
<span class="line"><span>2、执行结束操作时会回溯上面所有的中间操作</span></span>
<span class="line"><span>3、peek相当于为这个stream提供一个消费者</span></span>
<span class="line"><span>4、limit规定了forEach遍历的次数(forEach执行需要回溯，正常执行是执行10次)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="stream流水线应避免过多的迭代-结束操作-产生大量的中间结果-否则空间时间的开销都很大" tabindex="-1"><a class="header-anchor" href="#stream流水线应避免过多的迭代-结束操作-产生大量的中间结果-否则空间时间的开销都很大"><span>Stream流水线应避免过多的迭代(结束操作)产生大量的中间结果，否则空间时间的开销都很大</span></a></h3>`,52)])])}const p=i(n,[["render",r]]),d=JSON.parse('{"path":"/writings/archive/%E9%9B%86%E5%90%88.html","title":"ArrayList","lang":"zh-CN","frontmatter":{"description":"ArrayList 底层是对象数组，和普通数组相比，它的容量能动态地增长。 属于线性表的存储结构，插入、删除的时间复杂度为O(n)，求表长度、增加元素(增加到尾部)、查询第i个元素时间复杂度为O(1) ArrayList 继承了AbstractList，实现了List。提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandomA...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ArrayList\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-07-30T16:21:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"],["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/archive/%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"ArrayList"}],["meta",{"property":"og:description","content":"ArrayList 底层是对象数组，和普通数组相比，它的容量能动态地增长。 属于线性表的存储结构，插入、删除的时间复杂度为O(n)，求表长度、增加元素(增加到尾部)、查询第i个元素时间复杂度为O(1) ArrayList 继承了AbstractList，实现了List。提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandomA..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-30T16:21:52.000Z"}],["meta",{"property":"article:modified_time","content":"2022-07-30T16:21:52.000Z"}]]},"git":{"createdTime":1657786542000,"updatedTime":1659198112000,"contributors":[{"name":"wuyingbin","username":"wuyingbin","email":"yb.ng@foxmail.com","commits":1,"url":"https://github.com/wuyingbin"},{"name":"gelald","username":"gelald","email":"yb.ng@foxmail.com","commits":2,"url":"https://github.com/gelald"}]},"readingTime":{"minutes":5.09,"words":1526},"filePathRelative":"writings/archive/集合.md","autoDesc":true}');export{p as comp,d as data};
