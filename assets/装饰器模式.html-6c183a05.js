const t=JSON.parse('{"key":"v-5a356370","path":"/writings/pattern/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html","title":"装饰器模式","lang":"zh-CN","frontmatter":{"description":"装饰器模式 定义：在不改变原有对象的基础上，在运行过程中将功能附加到对象上，动态、透明地扩展对象功能，提供了比继承更有弹性的替代方案 适用场景： 用于扩展一个类的功能或给一个类添加附加职责 动态地给一个对象添加功能，这些功能还可以动态地撤销 优点： 装饰器是对继承的有力补充，比继承灵活，耦合度更低，在不需要改变对象的情况下动态地给一个对象扩展功能 可以通过不同的装饰器以及这些装饰器的排列组合，实现不同的效果 装饰器完全遵循开闭原则","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/pattern/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"装饰器模式"}],["meta",{"property":"og:description","content":"装饰器模式 定义：在不改变原有对象的基础上，在运行过程中将功能附加到对象上，动态、透明地扩展对象功能，提供了比继承更有弹性的替代方案 适用场景： 用于扩展一个类的功能或给一个类添加附加职责 动态地给一个对象添加功能，这些功能还可以动态地撤销 优点： 装饰器是对继承的有力补充，比继承灵活，耦合度更低，在不需要改变对象的情况下动态地给一个对象扩展功能 可以通过不同的装饰器以及这些装饰器的排列组合，实现不同的效果 装饰器完全遵循开闭原则"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"装饰器模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":2,"title":"装饰器模式在源码中的体现","slug":"装饰器模式在源码中的体现","link":"#装饰器模式在源码中的体现","children":[{"level":3,"title":"Spring","slug":"spring","link":"#spring","children":[]},{"level":3,"title":"MyBatis","slug":"mybatis","link":"#mybatis","children":[]}]},{"level":2,"title":"装饰器模式和代理模式的区别","slug":"装饰器模式和代理模式的区别","link":"#装饰器模式和代理模式的区别","children":[]}],"git":{"createdTime":1677655655000,"updatedTime":1677655655000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":3.6,"words":1079},"filePathRelative":"writings/pattern/装饰器模式.md","localizedDate":"2023年3月1日","excerpt":"<h1> 装饰器模式</h1>\\n<p>定义：在不改变原有对象的基础上，在运行过程中将功能附加到对象上，动态、透明地扩展对象功能，提供了比继承更有弹性的替代方案</p>\\n<p>适用场景：</p>\\n<ol>\\n<li>用于扩展一个类的功能或给一个类添加附加职责</li>\\n<li>动态地给一个对象添加功能，这些功能还可以动态地撤销</li>\\n</ol>\\n<p>优点：</p>\\n<ol>\\n<li>装饰器是对继承的有力补充，比继承灵活，耦合度更低，在不需要改变对象的情况下动态地给一个对象扩展功能</li>\\n<li>可以通过不同的装饰器以及这些装饰器的排列组合，实现不同的效果</li>\\n<li>装饰器完全遵循开闭原则</li>\\n</ol>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{t as data};
