const e=JSON.parse('{"key":"v-4e456548","path":"/writings/pattern/strategy.html","title":"策略模式","lang":"zh-CN","frontmatter":{"title":"策略模式","icon":"article","category":["设计模式"],"description":"策略模式 定义：将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。可以避免多重分支的 if else 和 switch 语句 理解：策略模式使用的就是面向对象的继承和多态机制，从而实现同一行为在不同场景下具体不同的实现 适用场景： 系统中有很多类，但他们的区别仅仅在于他们的行为不同 一个系统需要动态地在几种算法中选择一种 优点： 符合开闭原则 避免使用多重提交转换语句 提高算法的保密性和安全性，因为客户端无序依赖这些具体算法","head":[["meta",{"property":"og:url","content":"https://gelald.github.io/javrin/javrin/writings/pattern/strategy.html"}],["meta",{"property":"og:site_name","content":"Javrin"}],["meta",{"property":"og:title","content":"策略模式"}],["meta",{"property":"og:description","content":"策略模式 定义：将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。可以避免多重分支的 if else 和 switch 语句 理解：策略模式使用的就是面向对象的继承和多态机制，从而实现同一行为在不同场景下具体不同的实现 适用场景： 系统中有很多类，但他们的区别仅仅在于他们的行为不同 一个系统需要动态地在几种算法中选择一种 优点： 符合开闭原则 避免使用多重提交转换语句 提高算法的保密性和安全性，因为客户端无序依赖这些具体算法"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-01T07:27:35.000Z"}],["meta",{"property":"article:author","content":"gelald"}],["meta",{"property":"article:modified_time","content":"2023-03-01T07:27:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"策略模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-01T07:27:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gelald\\",\\"url\\":\\"https://github.com/gelald\\"}]}"]]},"headers":[{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":2,"title":"策略模式在源码中的体现","slug":"策略模式在源码中的体现","link":"#策略模式在源码中的体现","children":[{"level":3,"title":"JDK","slug":"jdk","link":"#jdk","children":[]},{"level":3,"title":"Spring","slug":"spring","link":"#spring","children":[]}]},{"level":2,"title":"策略模式和委派模式的区别","slug":"策略模式和委派模式的区别","link":"#策略模式和委派模式的区别","children":[]}],"git":{"createdTime":1677655655000,"updatedTime":1677655655000,"contributors":[{"name":"wuyingbin","email":"yb.ng@foxmail.com","commits":1}]},"readingTime":{"minutes":3.36,"words":1009},"filePathRelative":"writings/pattern/strategy.md","localizedDate":"2023年3月1日","excerpt":"<h1> 策略模式</h1>\\n<p>定义：将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。可以避免多重分支的 <code>if else</code> 和 <code>switch</code> 语句</p>\\n<p>理解：策略模式使用的就是面向对象的继承和多态机制，从而实现同一行为在不同场景下具体不同的实现</p>\\n<p>适用场景：</p>\\n<ol>\\n<li>系统中有很多类，但他们的区别仅仅在于他们的行为不同</li>\\n<li>一个系统需要动态地在几种算法中选择一种</li>\\n</ol>\\n<p>优点：</p>\\n<ol>\\n<li>符合开闭原则</li>\\n<li>避免使用多重提交转换语句</li>\\n<li>提高算法的保密性和安全性，因为客户端无序依赖这些具体算法</li>\\n</ol>","copyright":{"author":"gelald","license":"MIT Licensed"},"autoDesc":true}');export{e as data};
