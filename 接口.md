接口调用包含两个方面：

- 序列化：json、xml、hession、protobuf、thrift、text、bytes
- 通信协议：http、soap、websockect

# SOA架构设计模式
三种构建规范
1. SOAP: http+xml的形式
2. REST: http+json的形式
3. RPC: 基于socket的形式
三种典型框架
1. CXF: SOAP/REST框架
2. dubbo: RPC框架
3. SpringCloud: REST规范的生态系统

# SOAP

# REST
- 概念：REST即表现层状态转变（Representational State Transfer，简称REST）。**表现层状态**，是指(在某个瞬间状态的)资源数据的快照，包括资源数据的内容、表现格式(XML、JSON)等信息

- 原则：

  - 网络上所有事物都抽象为资源
  - 每个资源都有一个唯一的资源标识符（uri）
  - 同一个资源有多种表现形式（json、xml）
  - 对资源的各种操作不会改变资源标识符，只是请求方法的区别
  - 所有操作都是无状态的。是指服务端不保存任何与特定HTTP请求相关的资源，应用状态必须由请求方在请求过程中提供。要求在网络通信过程中，任意一个Web请求必须与其他请求隔离，当请求端提出请求时，请求本身包含了响应端为响应这一请求所需的全部信息。

- RESTful风格的体现，在你使用了get请求，就是查询；使用post请求,就是新增的请求；使用put请求，就是修改的请求；使用delete请求，就是删除的请求。这样做就完全没有必要对crud做具体的描述。![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfsrjsyshpj30p20hi7jn.jpg)

- 幂等性：对同一Rest接口多次访问，得到资源的状态是相同的

- 安全性：对该Rest接口访问，不会使服务端资源的状态发生变化

-  

  | http方法 | 资源操作 | 幂等 | 安全 |
  | -------- | -------- | ---- | ---- |
  | GET      | SELECT   | 是   | 是   |
  | POST     | INSERT   | 否   | 否   |
  | PUT      | UPDATE   | 是   | 否   |
  | DELETE   | DELETE   | 是   | 否   |

- 局限

  - 把所有内容定义为**资源**
  - 只能对资源作有限的**四种操作**
  - 例子：删除分为物理删除、标记删除；登陆登出

## 判断接口是否restful
- 看`url`就知道要什么
- 看`http method`就知道干什么
- 看`http status code`就知道结果如何

# RPC
- 概念：**R**emote **P**rocedure **C**all (远程调用过程)
- 解决两个问题：
  1. 解决**分布式**系统中，服务之间的调用问题
  2. 远程调用时，**要能够像本地调用一样方便**，让调用者感知不到远程调用的逻辑
- 数据格式
  - XML-RPC
  - JSON-RPC
- 响应方式
  - 同步调用：**客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作**。实现方式：
    - WebService：基于web容器的，底层使用http协议
    - RMI：Java语言的RPC实现，允许方法返回 Java 对象以及基本数据类型
  - 异步调用：**客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。**实现方式：
    - Java Message Service。JMS中间件有Kafka等消息中间件
- 架构中的内容
  - 客户端
  - 客户端存根：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方
  - 服务器存根：接受客户端发送过来的消息并解包，再调用本地服务
  - 服务端
- 架构图![](https://gitee.com/ngyb/pic/raw/master/007S8ZIlgy1gfsrjsayt4j30v10u0kjl.jpg)
- 需要考虑的问题
  - 通讯：长连接、短连接
  - 寻址：服务端的地址、端口、方法名。**如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址**
  - 序列化与反序列化



# RPC和REST对比

从使用上来看

- Rest接口（面向资源）只关注服务提供方（服务端），客户端使用Http方式进行调用时，只要将内容进行传输即可，这样客户端在使用时，需要更关注网络方面的传输，比较不适用与业务方面的开发；（restful是服务端把方法写好，客户端通过http方式调用，直接定位到方法上面去。通过url）
- RPC服务（面向方法）**需要客户端接口与服务端保持一致**，服务端提供一个方法，客户端通过接口直接发起调用，业务开发人员仅需要关注业务方法的调用即可，不再关注网络传输的细节，在开发上更为高效。（PRC是服务端提供好方法给客户端调用。定位到类，然后通过类去调用方法。通过服务的类名和方法名）



# 等幂

## HTTP方法的等幂性

|  方法  | 幂等 |                             描述                             |
| :----: | :--: | :----------------------------------------------------------: |
|  Get   |  √   | Get 方法用于获取资源。其一般不会也不应当对系统资源进行改变，所以是幂等的 |
|  Post  |  ×   | Post 方法一般用于创建新的资源。其每次执行都会新增数据，所以不是幂等的 |
|  Put   |  -   | Put 方法一般用于修改资源。更新操作中直接根据某个值进行更新，也能保持幂等。不过执行累加操作的更新是非幂等 |
| Delete |  -   | Delete 方法一般用于删除资源。当根据唯一值进行删除时，删除同一个数据多次执行效果一样。不过需要注意，带查询条件的删除则就不一定满足幂等了。例如在根据条件删除一批数据后，这时候新增加了一条数据也满足条件，然后又执行了一次删除，那么将会导致新增加的这条满足条件数据也被删除 |

## 引入幂等性后对系统的影响

优点：使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题

缺点：

- 把并行执行的功能改为串行执行，降低了执行效率
- 增加了额外控制幂等的业务逻辑，复杂化了业务功能

所以在使用时候需要考虑是否引入幂等性的必要性，根据实际业务场景具体分析，除了业务上的特殊要求外，**一般情况下不需要引入的接口幂等性**

## 实现方式

### 数据库唯一主键

数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能**保证在分布式环境下 ID 的全局唯一性**。

**适用范围**

- 插入操作
- 删除操作

**使用限制**

- 需要生成全局唯一ID

**主要流程**

- 客户端执行创建请求，调用服务端接口
- 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句
- 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端

### 数据库乐观锁

可以提前在对应的数据表中多添加一个字段，**充当当前数据的版本标识**。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值

**适用范围**

- 更新操作

**使用限制**

- 需要数据库对应业务表中添加额外字段

**使用流程**

- 在业务表中新建字段，如：Version
- 每次执行更新时，都要带上版本，也就是Version字段
- 在更新业务字段时，需要把版本也一并更新

`UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5`

因为版本字段随着每次更新都会更新，所以重复执行这条SQL语句不会产生影响

### 防重Token令牌

针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，**如果 Key 存在且 Value 匹配就执行删除命令**，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。

**适用范围**

- 插入操作
- 删除操作
- 更新操作

**使用限制**

- 需要生成全局唯一的Token串
- 需要使用Redis进行数据校验

**使用流程**

![](https://gitee.com/ngyb/pic/raw/master/20210430163529.png)

- 服务端提供获取Token的接口，该Token可以是一个序列号，也可以是一个分布式ID
- 客户端向服务端发送获取Token的请求
- 服务端生成Token，并将其设定过其时间存储到Redis中
- 将Token返回给客户端
- 客户端发送业务请求，把Token放到请求头上，一并发送给服务端
- 服务端接收到请求后，从请求头中拿到Token，在Redis中检查Token是否存在。注意：**在并发的情况下，执行查询和删除操作要保证原子性**
- 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息

## 总结

幂等性是开发当中很常见也很重要的一个需求，尤其是支付、订单等与金钱挂钩的服务，保证接口幂等性尤其重要。在实际开发中，我们**需要针对不同的业务场景我们需要灵活的选择幂等性的实现方式**

- 对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。
- 对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。
- 对于上下游这种，下游请求上游，上游服务可以使用“下游传递唯一序列号方案”更为合理。
- 类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。

