**最重要的目的：解耦**。开发时区分开，运行时合并用

# 总览

## 创建型

### 工厂模式

#### 简单工厂模式（产品的工厂）

**不属于23种设计模式之一**

**定义**：由一个工厂对象决定创建出哪一种产品类的实例

**理解**：不主动地调用经常需要创建的对象的构造方法，而是使用一个工厂来调用其方法帮助我们创建这个需要创建的对象

**适用场景**：***创建对象较少且数量确定的场景***。例如：Calendar，明确地知道所有子类且逻辑与数目不会被改变

**优点**：只需传入一个正确的参数或不传入也可以，就可以获取所需对象，无须知道创建细节

**缺点**：增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则，不易于扩展过于复杂的产品结构

#### 工厂方法模式（工厂的工厂）

**定义**：定义一个创建对象的工厂**接口**（定义所有工厂的规范，一般不会用抽象类），让实现这个工厂接口的工厂实现类来决定实例化哪个类。工厂方法模式让类的实例化推迟到工厂实现类中进行

**理解**：不同的类由不同的工厂来创建，这些工厂都实现了原始的工厂接口。

**适用场景**：创建对象需要大量重复的代码。客户端不依赖于产品类实例如何被创建、实现等细节。***一个类通过其子类来指定创建哪个对象***

**优点**：用户只需要关系所需产品对应的工厂，无须关心创建细节。且新加入产品符合开闭原则，提高系统的可扩展性（加入新的工厂即可，无须修改原有工厂）

**缺点**：类的个数容易过多（新加一个对象，需要新加一个类和一个负责创建它的工厂类），增加代码结构复杂度，增加系统的抽象性和理解难度

#### 抽象工厂模式（复杂产品的工厂）

**定义**：提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类

**理解**：抽象的工厂，创建抽象的对象；具体的工厂继承抽象的工厂，创建的对象实现抽象的对象。相当于定义一个*具有标准的*产品制作的标准，不同的工厂创建不同的产品。例如：格力公司制作格力冰箱、格力空调；美的公司制作美的冰箱、美的空调 --> I工厂制作I冰箱、I空调。**不光需要实现工厂，也需要实现具体产品**

**适用场景**：客户端不依赖于产品类实例如何被创建、实现的细节。强调一系列属于同一产品族的产品对象一起使用创建对象需要大量重复的代码。***提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现***

**优点**：具体产品在应用层代码隔离，无须关心创建细节。将一个系列的产品族统一到一起创建。

**缺点**：规定了所有的被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。类非常多，增加系统的理解难度

**和工厂方法模式的区别**：

**Spring中的抽象工厂**：`AbstractFactory` --> `AnnotationApplicationContext`、`XmlApplicationContext`

### 单例模式

**定义**：确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点（如：getInstance()）。隐藏其所有的构造方法（私有构造方法）

**适用场景**：确保任何情况下都绝对只有一个实例。例：ServletContext、ApplicationContext

**常见写法**：

1. 饿汉式单例
2. 懒汉式单例
3. 注册式单例
4. ThreadLocal单例

**例子**：

1. Spring中的`AbstractFactoryBean`类中的`getObject`方法，检查这个bean是否单例，如果是单例则继续判断是否已初始化，如果已经初始化，那么就返回这个单例对象，否则再创建这个对象
2. MyBatis中的`ErrorContext`类中的`instance`方法，先通过ThreadLocal对象来get获取对象，然后判断这个对象是否为null，如果是null，就实例化且存入ThreadLocal对象中，否则直接返回。隔离了每一个线程的错误信息

**优点**：

1. 在内存中只有一个实例，减少内存开销
2. 可以避免对资源的多重占用
3. 设置全局访问点，严格控制访问

**缺点**：没有接口，扩展困难，只能修改源代码

#### 重点知识点

1. 私有化构造方法
2. 保证线程安全（参考懒汉式单例）
3. 延迟加载（目的是为了避免大量单例对象在系统初始化时一并创建给内存带来巨大的压力）
4. 防止序列化和反序列化破坏单例（编写readResolve方法）
5. 防止反射破坏单例（参考枚举式单例）

#### 饿汉式单例

**在单例类首次加载时就创建实例**

```java
public class HungrySingleton {

    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton() {}

    public static HungrySingleton getInstance() { return hungrySingleton; }
}
```

**优点**：执行效率高，没有任何锁

**缺点**：在类加载的时候就创建对象，在某些情况下（系统中存在大量饿汉式单例类），**可能会造成内存浪费**。

#### 懒汉式单例

**被外部类调用时才创建单例**

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {}

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

**优点**：调用时才创建，节省了内存

**缺点**：可能造成线程不安全的问题。**有可能**多个线程同时抢占到资源，进入了`getInstance`方法，通过判断条件，**同时创建了多个实例**

**解决方案**：

1. 在`getInstance`方法上加**`synchronized`**关键字。**缺陷：性能受到限制**

   ```java
   public class LazySimpleSingleton {
   
       private static LazySimpleSingleton instance;
   
       private LazySimpleSingleton() {}
   
       //解决线程安全问题
       public synchronized static LazySimpleSingleton getInstance() {
           if (instance == null) {
               instance = new LazySimpleSingleton();
           }
           return instance;
       }
   
   }
   ```

   

2. **双重检查**。性能提升并解决了线程安全问题；`volatile`关键字：解决指令重排序问题。**缺陷：程序可读性降低**

   ```java
   public class LazyDoubleCheckSingleton {
   
       //解决指令重排序的问题
       private volatile static LazyDoubleCheckSingleton instance;
   
       private LazyDoubleCheckSingleton() {
       }
   
       public static LazyDoubleCheckSingleton getInstance() {
           //检查是否要阻塞
           if (instance == null) {
               synchronized (LazyDoubleCheckSingleton.class) {
                   //检查是否要重新创建实例
                   if (instance == null) {
                       instance = new LazyDoubleCheckSingleton();
                   }
               }
           }
           return instance;
       }
   
   }
   ```

3. **静态内部类**。静态内部类与静态属性不同，静态成员变量是加载时分配空间，静态内部类是使用时才分配内存空间。优点：写法优雅；利用了Java本身的语法特点；性能高；避免内存浪费。**缺陷：能够被反射破坏**

   ```java
   public class LazyStaticInnerClassSingleton {
   
       private LazyStaticInnerClassSingleton() {
         //通过判断INSTANCE是否为null来检查是否使用反射来破坏单例了，如果不为null，那么证明非法访问。因为如果用反射来获取这个类的构造方法时，也会加载LazyHolder从而INSTANCE得到初始化，那么这时判断INSTANCE是否为null即可判断是否非法访问。因为正常访问是不能够也不会去访问构造方法，只会去访问getInstance方法
       }
   
       public LazyStaticInnerClassSingleton getInstance() {
           return LazyHolder.INSTANCE;
       }
   
       private static class LazyHolder {
           private static final LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
       }
   
   }
   ```

##### 反射破坏单例模式

1. 获取class对象
2. 通过`class.getDeclaredConstructor()`方法获取私有构造方法
3. 通过`class.setAccessible(true)`方法访问私有构造方法
4. 通过`constructor.newInstance()`方法调用私有构造方法

**解决方案**：在构造方法中加入限制

#### 注册式单例

**将每一个实例都缓存到统一的容器中，使用唯一标识获取实例**

##### 枚举式单例

```java
public enum EnumSingleton {
    INSTANCE;

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }
}
```

**优点**：

1. 无法使用反射来破坏单例的特性：枚举类比较特殊，**jdk规定了无法使用反射来创建枚举类的对象**
2. 不存在线程安全的问题：枚举类在加载时已经创建好对象并放入容器`Map<String, T> enumConstantDirectory`中，类似饿汉式单例

**缺点**：由于类似饿汉式单例，所以如果系统中存在大量的注册式单例类的话，会对内存带来一定负担。**序列化/反序列化时单例被破坏**

##### 容器式单例(Spring中IoC容器使用的单例模式)

```java
public class ContainerSingleton {

    private ContainerSingleton() {
    }

    private static Map<String, Object> ioc = new ConcurrentHashMap<>();

    public static Object getInstance(String className) {
        if (ioc.containsKey(className)) {
            Object instance = null;
            try {
                instance = Class.forName(className);
                ioc.put(className, instance);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return instance;
        } else {
            return ioc.get(className);
        }
    }

}
```

**缺点**：**存在线程安全问题**

##### 序列化/反序列化破坏单例模式

对象A序列化并持久化后，再重新读取到内存时反序列化生成的对象B，对象A和对象B的地址值不一致

**解决方案**：在类中加入以下方法

```java
public Object readResolve() {return INSTANCE;}
```

因为在ObjectInputStream类中有`readObject`方法，这个方法会去检查类是否有`readResolve`方法，如果有则调用这个方法，**直接返回这个方法的结果，而不创建新的对象**

#### ThreadLocal单例

**保证线程内单例，得益于ThreadLocal，天生线程安全**

```java
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    private ThreadLocalSingleton() {
    }

    public static ThreadLocalSingleton getInstance() {
        return threadLocalInstance.get();
    }
}
```

ThreadLocal中的Map以线程为key，对象为value存储，所以保证线程隔离

#### 破坏单例的情况

##### 多线程破坏单例

1. 两个线程执行完结果一致
   1. 正常结果，两个结果一致
   2. 线程1执行到返回语句时，线程2执行了实例化语句，导致线程2覆盖了线程1而得出两个相同对象的现象
2. 两个线程执行完结果不一致：线程1、线程2实例化了两个对象

### 原型模式

**定义**：原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数。**把复制的过程封装起来**

**核心**：**拷贝**。不通过new关键字（构造方法）创建对象，而是通过拷贝的方式创建对象

**组成**：

1. 接口：抽象原型（可以做一个泛型），必须要有一个clone方法，返回该类型对应的对象
2. 实现类：正常的实体类，并实现clone方法

**使用场景**：

1. 类初始化消耗资源较多
2. new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
3. 构造方法比较复杂（字段多）
4. 循环体中生产大量对象

## 结构型

## 行为型

# 作业

## 工厂模式

**工厂类一定需要将构造方法私有化吗，为什么？**

答：一般情况下与单例模式结合使用，单例模式的特点是将构造方法私有化。不一定，只有工厂需要变成单例时，才需要将构造方法私有化

---

**用工厂模式设计支付业务场景，包含跨境支付，支付宝，微信，银联支付，并画出类图**（需结合策略模式）

## 单例模式

**如何解决容器式单例的线程安全问题**

答：从Spring源码着手，getInstance中加锁synchronized和双重检测。Spring锁的是一个容器



# Spring中用到的设计模式

- 工厂模式：BeanFactory
- 装饰器模式：BeanWrapper
- 代理模式：AopProxy
- 单例模式：ApplicationContext
- 委派模式：DispatcherServlet
- 策略模式：HandlerMapping
- 适配器模式：HandlerAdapter
- 模板方法模式：JdbcTemplate
- 观察者模式：ContextLoaderListener