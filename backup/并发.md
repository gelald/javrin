# 并发编程

## 基本概念

### 程序/进程/线程

- 程序：程序是数据和指令的集合（代码），是一个静态的概念，能长时间保存在硬盘中
- 进程：进程是程序运行的过程，是一个动态的概念，具有生命周期，会随着程序的终止而销毁。它是**资源分配的最小单位**
- 线程：线程是操作系统能够进行**程序执行的最小单位**，是进程中的实际运作单位
- 进程之间的交互通过TCP/IP+端口实现
- 线程之间的交互通过共享的内存空间来进行交互



### 串行/并行/并发

- 串行：一个程序完整运行完之后再运行下一个

  ![串行模式图](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210818113802.png)

- 并行：在一个时间段内，多个CPU同时执行多个程序

  ![并行模式图](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210818113917.png)

- 并发：在一个时间段内，一个CPU在多个程序之间来回切换执行多个程序

  ![并发模式图](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210818114124.png)
  
- 并发数：系统同时能处理的请求数量，同样反应了系统的负载能力



### 同步/异步

- 同步/异步 关注的是**消息通信机制**

- 同步：在发出一个调用时，在没有得到结果之前， 该调用就不返回

  ```java
  public static void main() {
      int result = doSomeThing();
  }
  ```

- 异步：在一个调用发出后，这个调用就结束了，先不返回结果，使用回调函数的方式返回结果

  ```java
  public static void main() {
      new Thread(() -> {
          int result = doSomeThing();    
      })
  }
  ```

阻塞/非阻塞

- 阻塞/非阻塞 关注的是程序在**等待调用结果时的状态**

- 阻塞：在调用结果返回之前，当前线程会被挂起。当前线程只有在得到结果之后才能继续干其他事情

  ```java
  public void int read(byte[] buffer) {
      while(磁盘未就绪) {
          将当前线程挂起并让出 CPU;
      }
      // 此时磁盘已就绪
      真正去读数据到 buffer 中
      return 读到的字节数;
  }
  ```

- 非阻塞：在不能得到结果之前，该调用不会阻塞当前线程，该线程可以转向干其他事情

  ```java
  public void int read(byte[] buffer) {
      if(磁盘未就绪) {
          // 立刻返回
          return -1;
      }
      真正去读数据到 buffer 中
      return 读到的字节数;
  }
  ```

自己理解的 「同步、异步、阻塞、非阻塞」

- 同步/异步 关心的重点在于调用者需不需要等待结果返回，有结果才返回(同步)；先不返回结果，等回调函数来返回(异步)
- 阻塞/非阻塞 关心的重点在于调用者发起调用后的行为，需要将线程挂起等待当前结果后才能干其他事情(阻塞)，不需要等待结果，立刻返回一个未就绪等信息然后进行下一步操作(非阻塞)
- **至于这个函数被调用者用同步还是异步的方式调用，都不影响这个函数本身是阻塞还是非阻塞的性质**

![老张喝茶的例子](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/image-20200924161447432.png)

![解释例子中的同步、异步、阻塞、非阻塞](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/image-20200924161525136.png)

![解释例子中的同步、异步、阻塞、非阻塞](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/image-20200924161347691.png)



### QPS/TPS

- QPS： `Queries Per Second` 每秒查询率。是**一台服务器**每秒能够响应的**查询**次数，是对一个特定的查询服务器**在规定时间内**所处理流量多少的衡量标准，即每秒的响应请求数，也即是最大吞吐能力
- TPS：`Transactions Per Second` 每秒事务数。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数
- QPS和TPS的不同点：QPS类似TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入QPS之中



### PV

- PV：`Page View` 页面访问量。页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到



## 并发编程的问题

### 上下文切换

任务执行完一个时间片会切换下一个任务，切换时会保存上一个任务的状态，以便于下一次切换回来，**一个任务从保存状态到再加载的过程**就是一次上下文切换

上下文切换有开销，并发量小，串行的时间会比并行的时间还短

#### 减少上下文切换的方法

1. 无锁并发编程
   - 如：不同线程处理不同范围的数据，可以有效避开锁的问题
2. CAS算法
3. 使用最少线程
   - 大量线程执行少量任务会导致大量线程处于等待状态
4. 使用协程
   - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

### 死锁

#### 避免死锁的常见方法

1. 避免一个线程同时获取多个锁
2. 避免一个线程在锁内同时占用多个资源，**尽量保证每个锁只占用一个资源**
3. 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制
4. 对于**数据库锁**，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

### 资源限制

在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接 数和socket连接数等

例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资 源，下载速度不会变成10Mb/s

并发因为受限于资源，仍然会在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间

#### 解决资源限制的问题

1. 对于硬件资源限制，可以考虑使用服务器集群并行执行程序
2. 对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket 连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接
3. 根据不同的资源限制调整 程序的并发度

## 底层实现原理
