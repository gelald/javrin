# 基础知识

概念：redis是一款高效的**NoSQL**(Not Only SQL)系列的**非关系型**数据库

关系型数据库和非关系型数据库的区别：

- 关系型数据库：
  1. 数据之间有关联关系（外键）
  2. 数据存储在硬盘上（查询速度相对慢）
- 非关系型数据库
  1. 数据之间没有关联关系。key-value形式
  2. 数据存储在内存中（查询速度相对快）
- 一般会将数据存储到关系型数据库中，在nosql数据库中备份存储关系型数据库中的数据

## 数据类型

- redis存储的是key，value形式，其中key都是字符串，value有5种不同的数据结构
- 字符串类型 string
  - 存储：`set key value`。如果key同名，则覆盖
  - 获取：`get key`。如果key不存在，返回`(nil)`
  - 删除：`del key`
- 哈希类型 hash（Map格式）
  - 存储一个键值对：`hset key field value`
  - 获取指定field对应的值：`hget key field`。如果key不存在，返回`(nil)`
  - 获取所有的field和value：`hgetall key`。如果key不存在，返回`(empty list or set)`
  - 删除：`hdel key field`
- 列表类型 list（LinkedList格式）可以添加一个元素到列表的头部或尾部
  - 将元素添加到列表左边：`lpush key value`
  - 将元素添加到列表右边：`rpush key value`
  - 范围获取：`lrange key start end`
  - 获取所有：`lrange key 0 -1`
  - 删除列表最左边的元素，并将元素返回：`lpop key`
  - 删除列表最右边的元素，并将元素返回：`rpop key`
- 集合类型 set（不允许重复）（HashSet格式）
  - 存储：`sadd key value`。存储成功返回1，存储失败（重复）返回0
  - 获取set集合中所有元素：`smembers key`
  - 删除：`srem key value`
- 有序集合类型 sortedset（不允许重复且自动排序）
  - 存储数据及其对应的分数：`zdd key score value` 排序是按分数从小到大排
  - 覆盖元素分数：`zdd key score value`，返回0
  - 获取范围元素：`zrange key start end`
  - 获取所有元素：`zrange key 0 -1`
  - 获取时携带分数：`zrange key 0 -1 withscores`
  - 删除：`zrem key value`

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/007S8ZIlgy1gfsrojipmnj312q0tq4ha.jpg)

## 通用命令

- 查询所有键：`keys *` 后面使用正则表达式，*代表所有
- 查询键对应的value的类型：`type key`
- 删除指定的key，value：`del key`

## 持久化

redis是一个内存数据库，当redis服务器重启，数据会丢失，可以将redis内存中的数据持久化保存到硬盘文件中。

redis持久化机制：

1. RDB：默认方式。**在一定的时间间隔内，检测key的变化情况，然后持久化数据**。这种方式对性能的影响比较低。

   ```bash
   # 默认的配置：
   
   # after 900 sec (15 min) if at least 1 key changed
   # 900秒后如果有1个key被改变了 就持久化一次
   save 900 1
   # after 300 sec (5 min) if at least 10 keys changed
   # 300秒后如果有10个key被改变了 就持久化一次
   save 300 10
   # after 60 sec if at least 10000 keys changed
   # 60秒后如果有10000个key被改变了 就持久化一次
   save 60 10000
   
   
   # 修改配置文件后servet的启动方式：
   ./redis-server.sh redis.conf
   ```

   

2. AOF：日志记录方式，**可以记录每一条命令的操作。可以每一次命令操作后，进行持久化**。对性能影响较大。

   ```bash
   # 默认的配置
   # AOF默认关闭
   appendonly no
   # 需要改成yes才开启AOF
   
   # appendfsync always 每一次操作都进行持久化
   appendfsync everysec # 每隔一秒进行持久化（默认）
   # appendfsync no		 不进行持久化
   ```

## 应用场景

- 缓存（数据查询、短连接、新闻内容、商品内容等等）
- 聊天室在线好友列表
- 任务队列（秒杀、抢购）
- 数据过期处理
- 分布式集群架构中的session分离

# 高阶

## 缓存和数据库写入的先后顺序

### 旁路缓存策略(Cache Aside Pattern)

使用方式：

- 读：**先读缓存，缓存没有的话，再去读数据库，然后取出来放入缓存中，同时返回响应**

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317231719.png)

- 写：**先更新数据库，后删除缓存**

---

#### 为什么不在更新完数据库后，采取更新缓存的方案，而是将其删除？

- 频繁更新浪费资源。假如一个字段在一段时间内频繁进行更新，如果不删除缓存，那么要频繁去更新缓存，但是这个资源很可能只用了几次，所以造成了浪费
- 缓存数据计算复杂。假如缓存的数据是需要许多步骤(读取多张表)来计算出来，计算成本比较高，那么每修改一次，为了更新缓存还要再查询多张表来算一次
- 两种情况同时具备

在这种情况下，读请求过来的时候，发现 Redis 中没有数据，就会去数据库里读取，然后写入缓存中。

这也是一种懒加载方式，**只有缓存被需要的时候才会去计算**。这样可以避免大量计算及频繁更新。

---

#### 隐患：数据库更新成功，但缓存删除失败

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232454.png)

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232442.png)

![](https://gitee.com/ngwingbun/pic/raw/master/20210317232506.png)

1. 刚开始时数据库和缓存中的数据是一致的
2. 在写请求过来后，数据库更新成功，而缓存删除失败。这就导致数据库中的数据是最新的，但缓存中却依然存着旧数据。
3. 如果这时读请求过来，就会直接读取缓存中的旧数据返回了。



### 双写一致方案

- 先确保删除缓存，后更新数据库（**适用于并发量不高的业务场景**）

#### 假如更新数据库失败

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232949.png)

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210317232957.png)

![](https://gitee.com/ngwingbun/pic/raw/master/20210317233006.png)

如果你的项目并发量很低的话，那这么用没毛病，很少情况下才会出现数据不一致的问题。

#### 隐患：同时有一个读请求和写请求

写请求先删除Redis中的数据，然后去数据库进行更新操作。

读请求判断Redis中有没有数据，没有数据时去请求数据库，拿到数据后写入缓存中。

**但是写请求此时并没有更新成功，或者执行了一个事务还没有成功。**

**这样的话，读请求拿到未修改的旧数据写入缓存。过了一会儿，写请求将数据库更新成功了，那么此时缓存与库中的数据就不一致了。**

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234534.png)

- 缓存延时双删策略

**写请求过来先把 Redis缓存删掉，等数据库更新成功后，异步等待一段时间再次把缓存删掉。**

第二次删除redis缓存是保证更新数据库成功后redis缓存能在下一次数据查询中正确设置数据

这种方案读取速度快，但是会出现短时间的脏数据。

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210318234740.png)

## 缓存穿透

> 一个女孩子去门店买口红，到了门店之后被告知她想要的那个色号已经没有了。于是她要求店员去问总部还有没有货。总部发现这个色号也没有了，于是女孩子就离开了。
>
> 过了一会另一个女孩子又来了，也想要购买同一个色号，店员就又总部问了一次。如此反复。
>
> 女孩子买口红不仅需要门店帮忙查询，还需要总部也进行盘货。类似这种情况，在缓存领域有一个类似的概念叫做**缓存穿透**

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412215026.png)

**缓存穿透**是指缓存服务器中没有缓存数据，数据库中也没有符合条件的数据，导致业务系统每次都绕过缓存服务器查询下游的数据库，缓存服务器完全失去了其应有的作用

### 解决方案

#### 缓存空值

> 解决多次询问总部的方法比较简单，如果口红门店在帮第一个女孩子查询之后，就记录下来这个色号已经没有了，下次其他女孩再来问这个色号的时候，直接告诉她没货了。

在缓存中，之所以会发生穿透，就是因为缓存没有对那些不存在的值得Key缓存下来，从而导致每次查询都要请求到数据库。

那么我们就**可以为这些key对应的值设置为null并放到缓存中，这样再出现查询这个key 的请求的时候，直接返回null即可 。**

但是还需要注意的就是需要有一个**失效时间**，因为如果不设置失效的话，如果哪天总部有货了，门店还是当做没货的话，就会影响销量了。

#### Bloom Filter（常用）

> 比如如果有一群人经常来门店问一些根本不存在的色号，比如五彩斑斓的黑，这些色号该品牌根本没生产过的话，店员就可以直接告诉顾客不存在就行了，也不需要惊动总部。

很多时候，缓存穿透是因为有很多**恶意流量的请求**，这些请求可能随机生成很多Key来请求查询，这些**肯定在缓存和数据库中都没有**，那就很容易导致缓存穿透。针对类似的情况，可以使用在缓存穿透防治上常用的**布隆过滤器**。

布隆过滤器是一种比较巧妙的概率性数据结构，它可以告诉你数据一定不存在或可能存在，相比Map、Set、List等传统数据结构它占用**内存少**、**结构更高效**

## 缓存击穿

> 有一种比较特殊的情况，那就是如果某一个热门色号的口红刚好卖完了，这时候有很多顾客同时来咨询要购买这个色号，那么门店内的多个售货员可能分别给总部打电话咨询是否有存货。
>
> 或者如果有多家门店同时卖完了，那么总部接收到的咨询量就会剧增。类似这种情况，在缓存领域有一个类似的概念叫做**缓存击穿**

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220154.png)

**缓存击穿**是指当某一key的缓存过期时大并发量的请求同时访问此key，瞬间击穿缓存服务器直接访问数据库，让数据库处于负载的情况

场景：秒杀、大促等

### 解决方案

#### 异步定时更新

> 如果提前知道某一个色号比较畅销的话，那就可以定时的咨询总部是否还有存货，定时的更新库存情况就可以避免上面这种情况了。

**某一个热点数据的过期时间是1小时，那么每59分钟，通过定时任务去更新这个热点key，并重新设置其过期时间**

#### 互斥锁（常用）

> 还有一种解决办法，那就是如果很多顾客咨询的是同一个色号的口红，那么就先处理第一个用户的咨询，其他同样请求的顾客先排队等待。一直到店员从总部那里获取到最新的库存信息后，就可以安排其他人继续购买了。

**当Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则先阻塞**。缺点：吞吐量降低

## 缓存雪崩

> 如果门店内的多个色号的口红同时售罄了，并且门店在这个时间点刚好也不知道总部有没有库存了，这时候如果有大量顾客来到门店购物的话，就会有更多的咨询电话打到总部那里。
>
> 或者是门店突然出现问题了，不能提供服务了，很多顾客就可能自己打电话到总部咨询库存情况。类似这种情况，在缓存领域有一个类似的概念叫做**缓存雪崩**

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20210412220622.png)

**缓存雪崩**是指当大量缓存同时过期或缓存服务宕机，**所有请求的都直接访问数据库**，造成数据库高负载，影响性能，甚至数据库宕机。

场景：微博热搜

### 解决方案

#### 不同的过期时间

> 为了避免缓存雪崩，门店可以考虑给不同的色号的口红预留不同的库存，并且采用不同的频率咨询总部库存情况，更新到门店中。这样就可以避免突然同一个时间点所有色号都售罄。

**为了避免大量的缓存在同一时间过期，可以把不同的key过期时间设置成不同的， 并且通过定时刷新的方式更新过期时间**

#### 集群（常用）

> 为了避免门店出问题导致大量顾客直接打电话到总部，可以考虑开更多的门店，将用户分流到多个店铺中

**在缓存雪崩问题防治上面，一个比较典型的技术就是采用集群方式部署，使用集群可以避免服务单点故障**

