# 并发编程的问题

### 上下文切换

任务执行完一个时间片会切换下一个任务，切换时会保存上一个任务的状态，以便于下一次切换回来，**一个任务从保存状态到再加载的过程**就是一次上下文切换

上下文切换有开销，并发量小，串行的时间会比并行的时间还短

##### 减少上下文切换的方法

1. 无锁并发编程
   - 如：不同线程处理不同范围的数据，可以有效避开锁的问题
2. CAS算法
3. 使用最少线程
   - 大量线程执行少量任务会导致大量线程处于等待状态
4. 使用协程
   - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换 

### 死锁

##### 避免死锁的常见方法

1. 避免一个线程同时获取多个锁 
2. 避免一个线程在锁内同时占用多个资源，**尽量保证每个锁只占用一个资源** 
3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制 
4. 对于**数据库锁**，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 

### 资源限制

在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接 数和socket连接数等 

例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资 源，下载速度不会变成10Mb/s 

并发因为受限于资源，仍然会在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间 

##### 解决资源限制的问题

1. 对于硬件资源限制，可以考虑使用服务器集群并行执行程序 
2. 对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket 连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接 
3. 根据不同的资源限制调整 程序的并发度 



# 底层实现原理 



# 概念

多进程/多线程

并行/并发

同步/异步

- 同步/异步 关注的是**消息通信机制**
- 同步：在发出一个调用时，在没有得到结果之前， 该调用就不返回
- 异步：在一个调用发出后，这个调用就结束了，先不返回结果，使用回调函数的方式返回结果

阻塞/非阻塞

- 阻塞/非阻塞 关注的是程序在**等待调用结果时的状态**
- 阻塞：在调用结果返回之前，当前线程会被挂起。当前线程只有在得到结果之后才能继续干其他事情
- 非阻塞：在不能得到结果之前，该调用不会阻塞当前线程，该线程可以转向干其他事情。

自己理解的 「同步、异步、阻塞、非阻塞」

- 同步/异步 关心的重点在于被调用者的结果返回，有结果才返回(同步)；先不返回结果，等回调函数来返回(异步)
- 阻塞/非阻塞 关心的重点在于调用者发起调用后的行为，需要等待当前结果才能干其他事情(阻塞)，不需要等待结果进行下一步(非阻塞)

<img src="https://gitee.com/ngyb/pic/raw/master/image-20200924161447432.png" alt="image-20200924161447432" style="zoom:50%;" />

<img src="https://gitee.com/ngyb/pic/raw/master/image-20200924161525136.png" alt="image-20200924161525136" style="zoom:50%;" />

<img src="https://gitee.com/ngyb/pic/raw/master/image-20200924161347691.png" alt="image-20200924161347691" style="zoom:50%;" />

