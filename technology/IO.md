# 系统调用函数

## recvfrom

Linux系统提供给用户用于接收网络IO的系统接口。从套接字上接收一个消息

如果此系统调用返回值<0，并且 errno为EWOULDBLOCK或EAGAIN（套接字已标记为非阻塞，而接收操作被阻塞或者接收超时 ）时，连接正常，**阻塞**接收数据（这很关键，前4种IO模型都设计此系统调用）

## select

系统调用允许程序同时在多个底层文件描述符上，等待输入的到达或输出的完成。以**数组**形式存储文件描述符，64位机器默认**2048**个。当有数据准备好时，无法感知具体是哪个流OK了，所以需要一个一个的遍历，函数的时间复杂度为**O(n)**

## poll

以**链表**形式存储文件描述符，没有长度限制。本质与select相同，函数的时间复杂度也为**O(n)**

## epoll

基于事件驱动的，如果某个流准备好了，会以事件通知，知道具体是哪个流，因此不需要遍历，函数的时间复杂度为**O(1)**。

## sigaction

用于设置对信号的处理方式，也可检验对某信号的预设处理方式。Linux使用**SIGIO信号**来实现IO异步通知机制



# IO模型

不管是网络IO还是磁盘IO，对于读操作，都需要等待网络的某个数据分组到达后/准备好，**将数据拷贝到内核空间的缓冲区中，再从内核空间拷贝到用户空间的缓冲区**

## 阻塞IO模型

> 此时我已饥渴难耐，全程**盯着**后厨，等待着一分一秒，终于全家桶做好了，在此期间虽然什么事也没干，但是最后能吃到全家桶，我很幸福。此处需要一个清新的脑回路，我就是程序，我想要全家桶，于是**发起了系统调用**，而后厨加工的过程就是在做**数据准备和拷贝**工作。全家桶最终到手，数据终于从内核空间拷贝到了用户空间。

![](https://gitee.com/ngyb/pic/raw/master/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png)

阻塞IO的执行过程是进程进行**系统调用**，**等待内核**将数据准备好并复制到用户态缓冲区后，进程**放弃使用CPU**并**一直阻塞**在此，知道数据准备好

## 非阻塞IO模型

> 此时我**每隔5分钟**询问全家桶好了没，在数次盘问后，终于出炉了。在每一次盘问之前，对于程序来说是**非阻塞的**，**占用CPU资源**，可以做其他事情。

![](https://gitee.com/ngyb/pic/raw/master/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png)

每次应用程序**询问内核**是否有数据准备好。如果就绪，就进行拷贝操作；如果未就绪，就**不阻塞程序**，内核直接返回未就绪的返回值，等待用户程序下一轮轮询

非阻塞IO的执行过程经历两个阶段

- **等待数据阶段**：未阻塞，用户进程需要不停地去**轮询内核**
- **数据复制阶段**：阻塞，此时进行**数据复制**

## IO多路复用模型

> 排了很长的队，终于轮到我支付后，拿到了一张小票，上面有**号次**。当全家桶出炉后，会喊相应的号次来取。KFC营业员小姐姐打小票出号次的动作相当于操作系统**多开了个线程**，专门接收客户端的连接。我只关注叫到的是不是我的号，因此程序还需在服务端**注册我想监听的事件**类型。

![](https://gitee.com/ngyb/pic/raw/master/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png)

IO多路复用**一般用于网络IO**，服务端和多个客户端建立连接

IO多路复用的执行过程：

- 应用进程调用select/poll/epoll函数。select函数会不断轮询自己所负责的文件描述符/套接字的到达状态。**select负责轮询等待**
- 当某个套接字就绪时，就对这个套接字进行处理。**recvfrom负责拷贝数据**

对于**客户端**来说，一般**感受不到阻塞**，因为请求来了，可以用放到线程池里执行；但对于执行select的**操作系统**而言，是**阻塞**的，需要阻塞地**等待某个套接字变为可读**。

IO多路复用其实是阻塞在select，poll，epoll这类系统调用上的，**复用的是执行select，poll，epoll的线程**

## 信号驱动IO模型

> 跑KFC嫌麻烦，刚好有个会员，直接点份外卖，美滋滋。当外卖送达时，会收到取餐电话（信号）。在收到取餐电话之前，我可以愉快地吃鸡或者学习。

![](https://gitee.com/ngyb/pic/raw/master/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.png)

信号驱动IO模型执行分为两个阶段：

- **数据准备阶段**：未阻塞，当数据准备完成之后，会主动地通知用户进程数据已经准备完成，对用户进程做一个回调
- **数据拷贝阶段**：阻塞用户进程，等待数据拷贝

与非阻塞IO模型的区别在于第一阶段，非阻塞IO模型是轮询结果，信号驱动IO模型是等待信号

## 异步IO模型

> 此时科技的发展已经超乎想象了，外卖机器人将全家桶自动送达并**转换成营养**快速注入我的体内，同时还能得到口感的满足。注入结束后，机器人会提醒我注入完毕。在这个期间我可以放心大胆的玩，甚至注射的时候也**不需要停下来**！

![](https://gitee.com/ngyb/pic/raw/master/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png)

用户进程发起系统调用后，立刻就可以开始去做其他的事情，然后直到I/O**数据准备好并复制完成后**，内核会给用户进程**发送通知**，告诉用户进程操作**已经完成**了。

特点：

- 异步IO执行的**两个阶段都不会阻塞**读写操作，由内核完成
- 完成后内核将数据放到指定的缓冲区，**通知**应用程序来取

## 总结

- 从效率上看：阻塞IO<非阻塞IO<多路复用IO<信号驱动IO<异步IO
- 从同步/异步看：只有异步IO模型是异步的，其他均为同步

# BIO - 同步阻塞

## 实现过程

1. 在服务端启动一个ServerSocket来**监听网络请求**
2. 客户端启动Socket发起网络请求
3. 默认情况下ServerSocket会**建立一个线程**来处理此请求，如果服务端没有线程可用，客户端则会**阻塞等待**或遭到**拒绝**，**并发效率比较低**

## 实现原理

**一个连接一个线程**，若有客户端有连接请求服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的**线程开销**。可以通过线程池机制改善

## 适用场景

连接数目比较小且固定的架构，对服务器资源要求高，并发局限于应用中

# NIO - 同步非阻塞

## 实现原理

**一个请求一个通道**，即客户端发送的连接请求都会**注册到多路复用器**上，多路复用器轮询到连接**有 I/O 请求时才启动**一个线程进行处

## 适用场景

连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中

## 重要角色

### 缓冲区Buffer

所有数据都是用**缓冲区（用户空间缓冲区）处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。缓冲区实际上是一个数组，并提供了对数据的结构化访问**以及**维护读写位置**等信息

#### 写操作

1. clear()
2. put() -> 写操作
3. flip() -> 重置游标
4. SocketChannel.write(buffer) -> 将缓存数据发送到网络的另一端
5. clear()

读操作

1. clear()
2. SocketChannel.read(buffer) -> 从网络中读取数据
3. buffer.flip()
4. buffer.get() -> 读取数据
5. buffer.clear()

### 通道Channel

nio中对数据的读取和写入要通过Channel，它就像**水管一样**，是一个通道。通道不同于流的地方就是通道是**双向**的，可以用于读、写和同时读写操作。

### 多路复用器Selector

用于注册通道。客户端发送的连接请求都会注册到多路复用器上，**多路复用器轮询到连接有I/O请求时才启动一个线程进行处理**

# AIO - 异步非阻塞

## 实现原理

进行读写操作时，只需直接调用api的read或write方法即可。**一个有效请求对应一个线程**，客户端的IO请求都是**操作系统先完成了再通知服务器**应用去启动线程进行处理

## 适用场景

连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作