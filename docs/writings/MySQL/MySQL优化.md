# MySQL优化

> 这一节我们来看 MySQL 优化。一谈到 MySQL 优化，我们往往第一时间就想到了加索引，加索引确实是优化的其中一个手段，但是也要加「对」索引，更重要的是还有其他有效但少有提及的做法。
>
> 快速的查询，不光光是体验的友好，更是技术的彰显。

## 索引

显而易见地，在数据量不是很大的情况下，用索引往往可以提升查询的效率，而大多慢查询也和索引不合理产生。

### 组合索引

有些时候我们会尽可能地去建一些组合索引，能有效提升查询的效率，我们希望出现这两种情况：

索引下推：如果查询条件包含在了组合索引中，比如存在组合索引（a,b)，查询到满足 a 的记录后会直接在索引内部判断 b 是否满足，减少回表次数。

覆盖索引：如果查询的列恰好包含在组合索引中，就无需回表。

### 索引失效

加索引可以提高查询效率，但是往往会出现加了索引查询还是慢的情况。原因多半还是索引失效（未命中索引），是否使用上索引可以通过 `explain` 关键字进行分析。

索引失效原因可以看这篇文章：[为什么加了索引，查询还是慢？](MySQL索引失效场景.md)

## select \* 惹的祸

很多时候为了图方便，就直接使用 `select *` 一次性查出表中所有的列，无论是否用上。

实际上在真正的业务场景下，需要的可能只是其中某几列，查了很多数据，实际上白白浪费了宝贵的内存和 CPU 资源，查询出来的数据 进行 IO 传输时也会**消耗更多时间**，这就是慢的原因！

此外，使用 `select *` 也就无法达到覆盖索引的条件，会造成**大量回表操作**，导致性能很低！

> 所以在开发的时候需要严格遵循需要什么列就查什么列的规则。

## union 和 union all

在 MySQL 中，`union` 和 `union all` 都可以实现取并集的功能，只不过两者有一些小区别

- 对重复结果的处理：`union` 会进行去重操作，而 `union all` 只是简单地合并两个结果集
- 对结果排序的处理：`union` 会根据字段进行排序，而 `union all` 只是简单地合并两个结果集

从以上来看，`union` 显然不是简单地完成并集的工作，还包含了筛选和排序，换言之效率要比 `union all` 要低。

> 所以除非是特殊的场景，不允许有重复值，那么尽量使用 `union all` 进行合并结果集。

## 分页优化

t 表中包含 100w 条数据，现在按每页 20 条数据分页查询 serllerid 为 100 的第 10w 页数据，索引是 serllerid。

普通做法：`limit M, N`

```mysql
select * from t where serllerid = 100 limit 100000, 20;

!-- 20 rows in set(90 sec)
```

可以看到时间成本巨大，在普通的 `limit M, N` 翻页写法，往往在越往后翻页的过程中速度越慢，原因是MySQL会读取表中的前 M+N 条数据，M 越大，性能越差。



优化做法：先查询翻页中需要的 N 条数据的主键，再根据 id 回表查询所需要的N条数据。查询 N 条数据的主键在索引中完成的，所以速度更快。

```mysql
select * from t t1, (select id from t where serllerid = 100 limit 100000, 20) t2 where t1.id = t2.id;
!-- 20 rows in set(4.25 sec)
```

可以看到由于走了索引后再回表，速度大大提升。
