---
title: RocketMQ 入门
icon: article
category:

- 干货
- 消息队列

tag:

- 基础
- RocketMQ

---

# RocketMQ 入门

## 为什么使用消息中间件

- 异步：把非必要的业务逻辑以异步的方式运行，提高响应速度。

- 流量削峰：当并发量很大，比如每秒 5000，但是 MySQL 能处理的并发量可能只有 200，会导致系统崩溃。消费者系统按照数据库能处理的并发量从消息队列中拉取消息消费，这个短暂的高峰期积压是允许的。

- 解耦：如果 A 系统直接调用多个系统的接口，那修改其他系统需要修改 A 系统代码；如果 A 系统使用中间件来调用多个系统的接口，那么当其他系统修改时 A 系统不需要做任何修改。

### 什么情况下的异步操作需要使用消息队列而不是多线程

- 消息队列和多线程两者并不冲突，多线程可以作为队列的生产者和消费者。在使用外部的消息队列时，可以提高应用的稳定性，当程序宕机后，已经写入外部消息队列的数据依旧是保存下来的。
- 用线程的话，会占用主服务器资源；消息队列的话，可以放到其他机器上运行，让主服务器更纯粹地处理请求。如果用户不急着知道结果的操作，可以用消息队列，否则再考虑多线程。
- 消息队列是在架构层面解决问题；多线程是在编程语言层面解决问题。消息队列解耦更充分，架构更合理。

## RocketMQ 角色介绍

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220617221818.png)

### NameServer
可以理解为是一个注册中心，支持 Broker 的动态注册与发现，提供给生产者和消费者查找 Broker 信息，从而进行消息的发送/消费。

### Broker
主要负责消息的存储、投递以及服务高可用的保证，有以下子模块：

  - Remoting Module：这是 Broker 的入口模块，负责处理所有来自客户端的请求。
  - Client Manager：负责管理所有的生产者消费者客户端，并维护消费者和 Topic 的订阅信息。
  - Store Service：提供把消息存储到物理磁盘和查询消息的功能。
  - HA Service：高可用服务，提供 master 节点和 slave 节点之间的关系。

### Producer
消息生产者，通过 NameServer 获取 Broker 的地址并发送消息。

### Customer
消息消费者，支持 `push`、`pull` 两种模式对消息进行消费，同时也支持集群方式和广播形式的消费。

## RocketMQ 基本概念

### Topic（主题）

用于标识一类消息。

### Tag

同一类消息可以再细分二级分类，方便消费者进行消息的过滤。Topic：手机；Tag：苹果、小米、华为。

### Group（分组）

一般生产者的分组**主要作用于事务消息**，因为 RocketMQ 有事务回查机制，当一个生产者挂了，事务回查的时候还可以找到同一个组内的其他生产者实例进行事务回查。体现了 RocketMQ 高可用的特性。

**一个消费者组中的多个消费者只能订阅一类消息**，消费进度与消费者组关联，体现了 RocketMQ 具有负载均衡的特性。如果多个消费者组订阅同一类消息，那么两组的消费是互不影响的。

### Message Queue（消息队列）

用于传递消息的组件，一个 Queue 只能被一个消费者消费，但是一个消费者可以消费多个 Queue 的消息。如果消费者组中的消费者数量与 Queue 数量相同，那么一般来说会一个消费者对应消费一个 Queue，因为消费者有自己的业务逻辑，往往没有生产者生产消息快，使用 Queue 后可以实现多个消费者消费一个生产者生产的消息，体现了 RocketMQ 高性能的特性。

### Offset（偏移量）

一般是指某一个队列中消费者消费的偏移量，可以简单理解成消费者消费了多少个消息。

另外还有队列中消息的偏移量，可以简单理解成队列中存储了多少消息。
