---
title: RocketMQ 原理分析(上)
icon: article
category:

- 干货
- 消息队列

tag:

- 原理
- RocketMQ

---

# RocketMQ 原理分析(上)

## RocketMQ 中顺序消息的问题

如果要严格控制消息的顺序，那么生产者、queue、消费者最好都是一对一的关系，但是这样的设计，会导致消息并发度不够，容易成为系统性能瓶颈。

但是 RocketMQ 不打算解决这个问题，理由如下：
1. 乱序的应用实际上大量存在，系统中一般极少数情况需要对消息做严格的顺序；
2. 队列中无序，不代表最终消息无序，可以使用其他手段来控制顺序。

## RocketMQ 中消息重复的问题

在 RocketMQ 中，造成消息重复的根本原因是网络波动，会导致消费者收到两条一样的消息。

RocketMQ 不保证消息不重复，如果要严格确保不重复，需要在业务端去重，可以使用如下手段：
1. 消费端处理消息的业务逻辑保持幂等性；
2. 确保每一条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。

## 顺序消费和并发消费的区别
### MessageListenerOrderly 和只设置一个线程的 MessageListenerConcurrently 的区别

## RocketMQ 延时消息

### `SCHEDULE_TOPIC_XXXX` 介绍

`SCHEDULE_TOPIC_XXXX` 是 RocketMQ 一个系统类型的 Topic，用于标识延时消息。

这个 Topic 有 18 个队列，分别唯一对应着 RocketMQ 的 18 个延时等级，对应关系为：**queueId = delayTimeLevel – 1**。

### `ScheduleMessageService` 介绍

这是 Broker 中的一个延时服务，专门消费 Topic 为 `SCHEDULE_TOPIC_XXXX` 的延时消息，并将其投递到目标 Topic 中。

`ScheduleMessageService` 在启动时，会创建一个定时器 Timer，并根据延迟级别的个数，启动对应数量的 TimerTask，每个 TimerTask 负责一个延迟级别的消费与投递。

### 延时消息在 Broker 的流转过程

生产者发送延时消息到 Broker，再到消费者消费的过程，消息将经过以下流转：

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220830160040.png)

1. Broker 把消息的 Topic 修改成`SCHEDULE_TOPIC_XXX`，然后根据本次消息的延时等级计算需要投递到的具体队列。同时还要把消息原来的 Topic 及其队列信息存储到消息的属性中，方便后面正确投递。
2. 在从 CommitLog 把消息转发到 queue 的过程中，会计算这个延时消息需要在什么时候进行投递，**投递时间=消息存储时间+延时等级对应的事件**。其中对于延时消息 ConsumeQueue 中的 Message Tag HashCode 记录的是这个投递时间的时间戳，Java 时间戳的数据超出 int 数据类型的数据范围 (-2^32 ~ 2^32 -1)，所以这个值需要设计成 8 个字节。
3. 延时消费服务 `ScheduleMessageService` 消费这个延时消息。
4. 从消息属性中取出并设置原来消息的 Topic 和队列信息，存储到 CommitLog. 此时这个消息已经完成延时，和普通消息没有区别，所以 ConsumeQueue 中的 Message Tag HashCode 需要重新计算消息 Tag 的哈希值再存储。
5. 由于消息的 Topic 已经修改为原来的 Topic，所以直接投递到对应的队列中。
6. 消费者消费这条消息。

## RocketMQ 事务消息

### 实现事务消息核心

- 两阶段提交：第一阶段生产者发送 Half 消息到 Broker 来测试 RocketMQ 是否正常；Broker 只有在收到第二阶段的消息时，消费者才能对消息进行消费。
- 事务补偿机制：当 Broker 收到状态为 `unknown` 的消息或者由于网络波动、生产者宕机导致长时间没有收到第二阶段的提交时，Broker 会调用生产者接口来回查本次事务的状态。

这两个核心是实现分布式事务最终一致性的关键。

### 事务消息的实现原理

>以支付订单后奖励积分为例，此时生产者是订单系统，消费者是积分系统，当积分系统收到订单系统传来订单支付成功，那么就给用户提供积分的奖励

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220830164439.png)

- 订单系统会发送一条 Half 消息到 RocketMQ 中，这个 Half 消息其实是一个代表订单成功支付的消息，只不过目前这个状态积分系统是无法感知这个消息的存在的。
- 如果发送 Half 消息后没有收到 MQ 的响应，那么可以认定 MQ 此时有问题，那么就在订单系统中回滚这笔订单，例如订单关闭或者发起退款。
- 如果收到 MQ 的响应，那么可以认定 MQ 是正常的，订单系统可以执行自己的本地事务，比如更新订单状态。
- 如果在处理自己系统的业务时，本地事务发生异常了，那么就发送一个 rollback 请求到 MQ 中，让 MQ 删除之前发送的 Half 消息；如果业务逻辑成功执行、本地事务成功提交，那么就发送一个 commit 请求到 MQ 中，MQ 收到 commit 请求后，之前的 Half 消息也就对积分系统可见了；如果业务逻辑的事务状态为 unknown ，那么 MQ 就会发起回查，回查生产者本地事务的状态。
- 假设由于网络波动、生产者重启导致事务消息的二次确认丢失，MQ 也有补偿措施，它会去扫描自己处于 Half 状态的消息，如果这个 MQ 一直没有接收到对这个 Half 消息的第二阶段的提交，会回调一个接口，让订单系统查询这个订单的状态，进而进行第二阶段的提交。所以这个回查的接口非常重要，要保证提交 commit 或者 rollback。

## 死信队列原理

> 死信队列用于处理无法被正常消费的消息，即死信消息。

### 死信消息的产生

当一条消息在消费失败时，RocketMQ 消费者会自动对消息进行重试消费；当重试失败次数达到最大值依然是失败时，那么可以认为消费者在正常情况下是无法消费这个消息的。此时，RocketMQ 并不会立刻丢弃这个消息，而是将其发送到消费者对应的死信队列中。

死信消息放到死信队列中后不会再被原来的消费者消费，此时他的 Topic 变成了 `%DLQ%消费者组` ，需要使用另外的消费者来订阅消费这些死信消息，这些消息和普通的消息一样，3 天后会被自动删除。

死信消息可以助于我们统计异常数据并做后续的数据修复处理。

### 死信队列的特点

一个死信队列对应一个消费者组，不对应某一个消费者实例或 Topic
