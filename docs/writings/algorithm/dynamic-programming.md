# 动态规划


动态规划的的四个解题步骤：

- 定义参数化的子问题
- 写出子问题的递推关系
- 确定 DP 数组的计算顺序
- 空间优化（可选）

## leetcode 53.最大子数组和

## leetcode 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> 示例 1：
> 
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。

> 示例 2：
> 
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

> 示例 3：
>
> 输入：[2,1,1,2]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 2)，偷窃 4 号房屋 (金额 = 2)。
>      偷窃到的最高金额 = 2 + 2 = 4 。

### 定义参数化的子问题

原问题是：从全部(n 间)房子中偷窃出最高的金额

那么子问题：从 k 间房子中偷窃出最高的金额，把原问题参数化，能得到子问题，子问题的参数是 k。并且当 k = n 时，子问题又能求出原问题的解


### 子问题的递推关系

从特殊到一般情况推导，同时确定边界条件


#### 边界条件

- 如果只有 1 间房子，那么能偷窃的最大金额就是第 1 间房子的金额: f(1) = nums[0]
- 如果只有 2 间房子，那么能偷窃的最大金额就是第 1 间房子和第 2 间房子的金额中的最大值: f(2) = Math.max(nums[0], nums[1])


#### 递推关系推导

条件：**不能偷相邻的房子**

- 如果有 3 间房子，那么偷窃最大金额的搭配是 [偷第 1 间 + 最后 1 间] 或 [偷第 2 间]: f(3) = Math.max(f(1) + nums[2], f(2))
- 如果有 4 间房子，那么偷窃最大金额的搭配是 [偷前 2 间房子的最大值 + 第 4 间] 或 [偷前 3 间房子的最大值]: f(4) = Math.max(f(2) + nums[3], f(3))
- 如果有 10 间房子，那么偷窃最大金额的搭配是 [偷前 8 间房子的最大值 + 第 10 间] 或 [偷前 9 间房子的最大值]: f(10) = Math.max(f(8) + nums[9], f(9))

从列举的这些例子也能大概推导出递推关系：$f(k) = Math.max(f(k-2) + nums[k-1], f(k-1))$


### 定义 DP 数组

DP 数组用于存储每一轮遍历的结果，dp[k] 对应子问题 f(k)，同时 dp[k] 会依赖 dp[k-1] 和 dp[k-2]，所以计算的顺序是从小到大遍历


### 问题解法

```java
    public int rob(int[] nums) {
        int length = nums.length;
        // 数组只有一个元素的话不进入后面的循环，直接返回
        if (length == 1) {
            return nums[0];
        }
        // 存储每一个子问题的结果
        // 当去到最后一个问题的时候，这个子问题就是总问题
        int[] dp = new int[length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[length - 1];
    }
```


### 空间优化解法

每次使用 dp 数组都是用 i-1 和 i-2 索引，可以使用局部变量来代替，每一轮遍历都更新这两个局部变量

这样就能省去一个数组的空间

```java
    public int rob(int[] nums) {
        // 用临时变量代替 dp 数组
        // 因为每次用到 dp 数组都是前两个和前一个结果

        int length = nums.length;
        if (length == 1) {
            return nums[0];
        }

        // 当前结果，初始值：第 2 轮结果
        int currentResult = Math.max(nums[0], nums[1]);
        // 前一轮结果，初始值：第 1 轮结果
        int previousResult = nums[0];

        for (int i = 2; i < length; i++) {
            // 第 3 轮结果 = max(第 1 轮结果 + 第 3 个元素, 第 2 轮结果)
            // 计算后，当前结果：第 3 轮结果；前一轮结果：第 2 轮结果
            // 第 4 轮结果 = max(第 2 轮结果 + 第 4 个元素, 第 3 轮结果)
            // 计算后，当前结果：第 4 轮结果；前一轮结果：第 3 轮结果
            int temp = currentResult;
            currentResult = Math.max(previousResult + nums[i], currentResult);
            previousResult = temp;
        }

        return currentResult;
    }
```


## leetcode 121.买卖股票的最佳时机
