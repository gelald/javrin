---
title: ConcurrentHashMap
icon: article
category: Javaé›†åˆ
---

# ConcurrentHashMap ä»‹ç»

## å¼•å…¥

HashMap æ˜¯æœ€å¸¸ç”¨çš„ Map é›†åˆä¹‹ä¸€ï¼ŒJDK1.8 ä¹‹åå…¶åº•å±‚çš„æ•°ç»„+é“¾è¡¨/çº¢é»‘æ ‘çš„ç»“æ„ä½¿å¾—è¯»å†™æ•ˆç‡éƒ½éå¸¸é«˜ï¼Œç„¶è€Œå®ƒå¹¶ä¸æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„é›†åˆï¼Œå¦‚æœä¸åŠ ä»¥åŒæ­¥æ§åˆ¶ï¼Œåœ¨å¹¶å‘çš„ç¯å¢ƒä¸‹ï¼Œå¯èƒ½ä¼šå¯¼è‡´ HashMap å­˜åœ¨çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚


### HashMap çº¿ç¨‹ä¸å®‰å…¨

HashMap çš„ `put()`ã€`resize()` æ–¹æ³•éƒ½æ²¡æœ‰ä»»ä½•åŒæ­¥æªæ–½ï¼Œæ¯”å¦‚ `synchronized` æˆ– CAS æœºåˆ¶ï¼Œå½“å¤šä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œåŒä¸€ä¸ª HashMap æ—¶ï¼Œè¿™äº›æ“ä½œä¸æ˜¯åŸå­æ€§çš„ï¼Œå®¹æ˜“å‡ºç°ç«æ€æ¡ä»¶ã€‚

å¦‚æœä¸¤ä¸ªçº¿ç¨‹ Aã€B åŒæ—¶å†™å…¥ä¸åŒçš„æ•°æ®ï¼Œå½“å‘ç”Ÿä¸åŒæ•°æ® hash å†²çªæ—¶ï¼Œä»–ä»¬å¯èƒ½ä¼šåŒæ—¶è¯»å–å¯¹åº”ç´¢å¼•çš„å“ˆå¸Œæ¡¶å¤´èŠ‚ç‚¹ï¼Œå„è‡ªåˆ›å»ºæ–°èŠ‚ç‚¹å¹¶è¿”å›ï¼Œæœ€ç»ˆä¼šå¯¼è‡´èŠ‚ç‚¹**æ•°æ®è¦†ç›–**çš„é—®é¢˜ã€‚å¹¶ä¸” size å±æ€§çš„æ›´æ–°ä¹Ÿå¹¶éåŸå­æ“ä½œï¼ˆå†™å…¥æ•°æ®åé‡‡ç”¨ `++size` çš„æ–¹å¼æ›´æ–°ï¼‰


### çº¿ç¨‹å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ

æ­£å› ä¸º HashMap æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œæ‰€ä»¥éœ€è¦å¯»æ‰¾çº¿ç¨‹å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ

- `HashTable`ï¼šæ‰€æœ‰æ–¹æ³•éƒ½ä½¿ç”¨ `synchronized` ä¿®é¥°ï¼Œä½¿ç”¨å…¨å±€é”ï¼Œæ€§èƒ½ä¸é«˜
- `Collections.synchronizedMap(new HashMap<>())`ï¼šæŠŠ HashMap åŒ…è£…ä¸º SynchronizedMapï¼Œæ‰€æœ‰æ–¹æ³•çš„é€»è¾‘éƒ½è¢« `synchronized` ä»£ç å—åŒ…è£¹ï¼Œä¸ HashTable ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ä½¿ç”¨å…¨å±€é”ï¼Œæ€§èƒ½ä¸é«˜
- `ConcurrentHashMap`ï¼šé‡‡ç”¨æ›´ç²¾ç»†åŒ–çš„é”æ§åˆ¶ï¼ŒJDK 1.7 ä½¿ç”¨**åˆ†æ®µé”**ï¼ŒJDK 1.8 ä½¿ç”¨ **CAS + `synchronized`**


## JDK 1.8 ConcurrentHashMap

> åœ¨ JDK 1.8 ä¸­ï¼ŒConcurrentHashMap åœ¨ä¿è¯çº¿ç¨‹å®‰å…¨çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡**æ— é”åŒ–**ã€**ç»†é¢—ç²’åº¦é”**ã€**å¤šçº¿ç¨‹åä½œ**ï¼Œæœ€å¤§åŒ–å¹¶å‘æ€§èƒ½


### åº•å±‚ç»“æ„

åœ¨ JDK 1.8 ä¸­ï¼ŒConcurrentHashMap çš„å­˜å‚¨ç»“æ„æ˜¯ç”± Nodeæ•°ç»„ + é“¾è¡¨/çº¢é»‘æ ‘ ç»„æˆï¼Œå½“ hash å†²çªé“¾è¡¨è¾¾åˆ°ä¸€å®šé•¿åº¦åï¼Œé“¾è¡¨ä¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼Œä¸ HashMap ç±»ä¼¼


### åˆå§‹åŒ–

- ConcurrentHashMap çš„åˆå§‹åŒ–æ˜¯ä¸€ä¸ªæ‡’åŠ è½½çš„è¡Œä¸ºï¼Œæ„é€ æ—¶åªè®°å½•å®¹é‡ï¼Œé¦–æ¬¡å†™æ“ä½œæ‰åˆå§‹åŒ– `table`ï¼Œé¿å…æ— ç”¨å¼€é”€
- `sizeCtl` è¢« `volatile` ä¿®é¥°ï¼Œä½¿å¾—å¯¹å®ƒçš„ä¿®æ”¹èƒ½è®©å…¶ä»–çº¿ç¨‹åŠæ—¶æ„ŸçŸ¥åˆ°
- ç”¨ CAS çš„æ–¹å¼æ¥ä¿®æ”¹ `sizeCtl`ï¼Œå…¶ä»–çº¿ç¨‹æ„ŸçŸ¥åˆ° `sizeCtl` å°äº 0 å°±æ‰§è¡Œ `yield()` è®©å‡º CPU å¹¶è¿›è¡Œè‡ªæ—‹ç­‰å¾…ï¼Œä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è¿›è¡Œåˆå§‹åŒ–
- ç»è¿‡ CAS åè¿›è¡Œå¤šä¸€æ¬¡çš„ `table` æ£€æŸ¥ï¼ŒåŒé‡æ£€æŸ¥é¿å…é‡å¤åˆå§‹åŒ–
- ConcurrentHashMap ä½¿ç”¨ CAS å’Œ `volatile` å®ç°äº†æ— é”åˆå§‹åŒ–ï¼Œé¿å…äº†ç›´æ¥ä½¿ç”¨ `synchronized` çš„æ€§èƒ½æŸè€—

> å…³äº yield() çš„ä»‹ç»ğŸ‘‰: [yieldå­¦ä¹ ](../concurrency/yield.md)

```java
    // å®¹å™¨åˆå§‹åŒ–å’Œè°ƒæ•´å¤§å°çš„ç©ºé—´
    // æ„é€ æ—¶ï¼ŒsizeCtlè¡¨ç¤ºå®¹é‡ï¼ˆå¦‚æœæœ‰æŒ‡å®šåˆå§‹å®¹é‡ï¼‰
    // åˆå§‹åŒ–æ—¶ï¼ŒsizeCtlè¢«è®¾ç½®ä¸º-1ä½œä¸ºæ­£åœ¨åˆå§‹åŒ–çš„æ ‡å¿—ä½
    // åˆå§‹åŒ–å®Œæˆåï¼ŒsizeCtlè¡¨ç¤ºæ‰©å®¹é˜ˆå€¼
    // æ‰©å®¹æ—¶ï¼ŒsizeCtlè¢«è®¾ç½®ä¸º-Nï¼ˆé«˜16ä½è¡¨ç¤ºæ‰©å®¹çš„æ ‡è¯†ï¼Œä½16ä½å‡1ä¸ºæ­£åœ¨æ‰©å®¹çº¿ç¨‹æ•°ï¼‰
    private transient volatile int sizeCtl;

    /**
     * Initializes table, using the size recorded in sizeCtl.
     */
    private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            // å¦‚æœsizeCtlå°äº0ï¼Œæ­¤æ—¶æœ‰å…¶ä»–çº¿ç¨‹æ­£åœ¨æ‰§è¡ŒinitTable
            if ((sc = sizeCtl) < 0)
                // è®©å‡ºCPUä½¿ç”¨æƒï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½åˆå§‹åŒ–ï¼Œå…¶ä»–çº¿ç¨‹è‡ªæ—‹ç­‰å¾…ï¼Œç›´åˆ°åˆå§‹åŒ–å®Œæˆ
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {
                // çº¿ç¨‹ CAS æˆåŠŸæŠŠsizeCtlæ”¹æˆ-1ï¼ŒæŠ¢åˆ°initTableæ‰§è¡Œæƒ
                try {
                    // CAS åè¿›è¡ŒåŒé‡æ£€æŸ¥ï¼Œé¿å…é‡å¤åˆå§‹åŒ–
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        // åˆå§‹åŒ– table
                        table = tab = nt;
                        // è®¡ç®—æ‰©å®¹é˜ˆå€¼
                        sc = n - (n >>> 2);
                    }
                } finally {
                    // åˆå§‹åŒ–å®Œæˆï¼ŒæŠŠsizeCtlè®¾ç½®ä¸ºæ‰©å®¹é˜ˆå€¼
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
```


### æ‰©å®¹

å’Œ HashMap ä¸€æ ·ï¼Œå½“å“ˆå¸Œæ¡¶è¿‡äºæ‹¥æŒ¤æ—¶ï¼ŒæŸ¥è¯¢æ•ˆç‡ä¼šä» O(1) é€€åŒ–æˆ O(n) (é“¾è¡¨å˜é•¿) æˆ–è€… O(log n) (çº¢é»‘æ ‘)ï¼Œå°½ç®¡é“¾è¡¨è¶…è¿‡ä¸€å®šé˜ˆå€¼åä¹Ÿä¼šè½¬æ¢æˆçº¢é»‘æ ‘æ¥æå‡æŸ¥è¯¢æ•ˆç‡ï¼Œä½†æ˜¯å“ˆå¸Œæ¡¶æ‰©å®¹ä¹Ÿæ˜¯èƒ½å¤§å¤§æå‡æŸ¥è¯¢æ•ˆç‡çš„ã€‚

å½“å…ƒç´ æ•°é‡ > sizeCtl(åˆå§‹åŒ–å®Œæˆåï¼Œå®ƒä½œä¸ºæ‰©å®¹é˜ˆå€¼) æ—¶ï¼ŒConcurrentHashMap ä¼šæŠŠåº•å±‚æ•°ç»„çš„å®¹é‡æ‰©å®¹ä¸ºåŸæ¥çš„ 2 å€ï¼Œè®©å…ƒç´ é‡æ–°åˆ†å¸ƒï¼Œé™ä½å†²çªã€‚

- è§¦å‘æ—¶æœºï¼š
    - `put()` æˆåŠŸæ’å…¥ä¸€ä¸ªå…ƒç´ åï¼Œè°ƒç”¨ `addCount()` æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹ï¼Œæ£€æŸ¥å…ƒç´ æ•°é‡æ˜¯å¦è¶…è¿‡é˜ˆå€¼ `sizeCtl`
    - åœ¨å“ˆå¸Œæ¡¶å®Œæˆè¿ç§»ä¹‹åï¼Œå“ˆå¸Œæ¡¶çš„å¤´èŠ‚ç‚¹ä¼šè½¬æ¢ä¸ºç‰¹æ®ŠèŠ‚ç‚¹ `ForwardingNode` (hash = -1)

- æ‰©å®¹æœŸé—´çš„è¯»å†™æ“ä½œï¼Œå†™æ“ä½œåŠ é”æˆ–CASï¼Œè¯»æ“ä½œä¾é  `volatile` ä¿è¯å¯è§æ€§
    - æ‰©å®¹æœŸé—´è¯»æ“ä½œï¼šè¯»å–æ•°æ®çš„è¿‡ç¨‹å®Œå…¨ä¸åŠ é”ï¼Œé  `volatile` å’Œ `ForwardingNode` ä¿è¯çº¿ç¨‹å®‰å…¨
    - æ‰©å®¹æœŸé—´å†™æ“ä½œï¼šå†™å…¥æ•°æ®æ—¶å‘ç°å¯¹åº”çš„å“ˆå¸Œæ¡¶å·²è¿ç§»ï¼Œåˆ™å»æ–°æ•°ç»„è¿›è¡Œæ’å…¥ï¼›å¦‚æœæœªè¿ç§»ï¼Œé‚£ä¹ˆå…ˆååŠ©è¿ç§»æ¡¶ï¼Œå†å†™å…¥
    - å†™æ“ä½œå’Œè¿ç§»æ¡¶å‰éƒ½ä»…ä¼šå¯¹æŸä¸€ä¸ªå“ˆå¸Œæ¡¶åŠ é”ï¼Œæ—¢ä¿è¯è¿ç§»å’Œå†™æ“ä½œäº’æ–¥ï¼Œåˆé™ä½é”çš„é¢—ç²’åº¦ï¼Œæœ€å¤§ç¨‹åº¦å‡å°‘ç«äº‰

- åä½œæ‰©å®¹ï¼šConcurrentHashMap çš„æ‰©å®¹ä¸æ˜¯ä¸€è¹´è€Œå°±ï¼Œè€Œæ˜¯å……åˆ†åˆ©ç”¨å¤šæ ¸CPUï¼Œå¤šä¸ªçº¿ç¨‹å‚ä¸åˆä½œ
    - ç¬¬ä¸€ä¸ªå‘ç°éœ€è¦æ‰©å®¹çš„çº¿ç¨‹ä¼šåˆå§‹åŒ–ä¸€ä¸ªæ–°çš„æ•°ç»„ `nextTable`ï¼Œå¹¶å¼€å§‹è¿ç§»ç¬¬ä¸€ä½å…ƒç´ 
    - åç»­è°ƒç”¨ `put()` çš„çº¿ç¨‹ï¼Œå¦‚æœå‘ç°æ­£åœ¨æ‰©å®¹ï¼ˆæ£€æŸ¥åˆ°å“ˆå¸Œæ¡¶ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `ForwardingNode`ï¼‰ï¼Œä¹Ÿä¼šå¸®å¿™è¿ç§»
    - æ¯ä¸ªå‚ä¸æ‰©å®¹çš„çº¿ç¨‹**é€šè¿‡ CAS ç”³è¯·ä¸€æ®µåŒºé—´ï¼ˆå¦‚æœ[0~15]ï¼‰**æ¥è¿ç§»é¿å…é‡å¤è¿ç§»

- æ‰©å®¹ç»“æŸï¼šå½“æ‰€æœ‰å“ˆå¸Œæ¡¶éƒ½è¿ç§»å®Œæˆæ—¶ï¼Œæœ€åä¸€ä¸ªçº¿ç¨‹ä¼šï¼š
    - æŠŠ `table` æŒ‡å‘ `nextTable` å¹¶æ¸…ç©º `nextTable`
    - é‡æ–°è®¡ç®—æ–°çš„ `sizeCtl` = è´Ÿè½½å› å­ï¼ˆé»˜è®¤æ˜¯0.75ï¼‰ * æ–°å®¹é‡


#### è¿ç§»é€»è¾‘

```java
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;
    // è®¡ç®—æ¯ä¸ªçº¿ç¨‹è´Ÿè´£çš„æ­¥é•¿ï¼ˆstrideï¼‰

    // ... åˆå§‹åŒ– nextTabï¼ˆå¦‚æœç¬¬ä¸€ä¸ªçº¿ç¨‹ï¼‰

    for (int i = 0, bound = 0;;) {
        Node<K,V> f = tabAt(tab, i);
        if (f == null)
            advance = casTabAt(tab, i, null, fwd); // æ¡¶ä¸ºç©ºï¼Œç›´æ¥ CAS è®¾ç½®ä¸º ForwardingNode
        else if ((fh = f.hash) == MOVED)
            continue; // å·²ç»æ˜¯ ForwardingNodeï¼Œè·³è¿‡
        else {
            synchronized (f) { // å¯¹å“ˆå¸Œæ¡¶å¤´åŠ é”ï¼Œä¿è¯è¿ç§»å’Œå†™æ“ä½œäº’æ–¥
                if (tabAt(tab, i) == f) { // åŒé‡æ£€æŸ¥
                    Node<K,V> ln = null, hn = null;
                    // ... éå†é“¾è¡¨ï¼ŒæŒ‰ hash & oldCap åˆ†æˆ low/high ä¸¤ç»„
                    setTabAt(nextTab, i, ln);        // ä½ä½é“¾
                    setTabAt(nextTab, i + n, hn);    // é«˜ä½é“¾ï¼ˆåç§» nï¼‰
                    setTabAt(tab, i, fwd);           // è¿ç§»å®Œæˆåï¼Œå°†æ—§æ¡¶è®¾ä¸º ForwardingNode
                    // ...
                }
            }
        }
    }
}
```


#### å…¶ä»–çº¿ç¨‹ååŠ©è¿ç§»é€»è¾‘

```java
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable && table == tab &&
               (sc = sizeCtl) < 0) {
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS)
                break;
            if (transferIndex <= 0)
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                transfer(tab, nextTab); // ååŠ©è¿ç§»
                break;
            }
        }
        // putVal()æ–¹æ³•å‘ç°ç´¢å¼•è½åœ¨äº†å·²è¿ç§»çš„å“ˆå¸Œæ¡¶ï¼Œé‚£ä¹ˆéœ€è¦å»æ–°è¡¨æ’å…¥
        // å…·ä½“çš„è¡Œä¸ºæ˜¯è¿”å› nextTabï¼Œåœ¨ä¸‹ä¸€è½®çš„å¾ªç¯ä¸­æ“ä½œ nextTab
        return nextTab; // è¿”å›æ–°è¡¨
    }
    return table;
}
```


#### æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹çš„é€»è¾‘

```java
private final void addCount(long x, int check) {
    if (check >= 0) {
        Node<K,V>[] tab, nt; int n, sc;
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
            (n = tab.length) < MAXIMUM_CAPACITY) {
            // ...
            if (sc < 0) { // sizeCtlå°äº0ï¼Œè¡¨ç¤ºæ­£åœ¨æ‰©å®¹
                // ä½¿ç”¨ CAS çš„æ–¹å¼å¯¹ sizeCtl å¢åŠ 1ï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹éœ€è¦åŠ å…¥æ‰©å®¹æ“ä½œ
                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))
                    // ä¸»åŠ¨å‚ä¸æ‰©å®¹
                    transfer(tab, nt);
            }
        }
    }
}
```


### put

put æ“ä½œæµç¨‹ï¼š

- `spread()` æ–¹æ³•è®¡ç®— key çš„ hash å€¼
- å¦‚æœå‘ç° `table` æ˜¯ `null`ï¼Œé‚£ä¹ˆè°ƒç”¨ `initTable()` æ¥å®Œæˆæ•°ç»„åˆå§‹åŒ–ï¼Œé€šè¿‡ CAS çš„æ–¹å¼ç¡®ä¿åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è¿›å…¥åˆå§‹åŒ–æµç¨‹
- å¦‚æœå‘ç°å¯¹åº”çš„å“ˆå¸Œæ¡¶æ˜¯ä¸€ä¸ªç©ºæ¡¶ï¼Œé‚£ä¹ˆä½¿ç”¨ CAS çš„æ–¹å¼æ’å…¥æ•°æ®
- å¦‚æœå‘ç°å¯¹åº”çš„å“ˆå¸Œæ¡¶æœ‰æ•°æ®ï¼Œé‚£ä¹ˆéœ€è¦ä½¿ç”¨ `synchronized` é”ä½å“ˆå¸Œæ¡¶ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ¥å®Œæˆé“¾è¡¨æˆ–çº¢é»‘æ ‘çš„æ’å…¥
- å®Œæˆæ’å…¥æ•°æ®çš„å·¥ä½œåï¼Œè°ƒç”¨ `addCount()` æ–¹æ³•æ¥è¿›è¡Œæ‰©å®¹æ£€æŸ¥ï¼Œå¦‚æœéœ€è¦æ‰©å®¹ï¼Œé‚£ä¹ˆå‚ä¸æ‰©å®¹å·¥ä½œ

> ConcurrentHashMap putæ–¹æ³•é‡‡ç”¨åˆ†æ®µé”æ€æƒ³ï¼šåªæœ‰åœ¨å¿…è¦æ—¶é’ˆå¯¹å•ä¸ªæ¡¶åŠ é”ï¼Œå…¶ä»–æƒ…å†µä½¿ç”¨ CAS æˆ–è€…æ— é”æ“ä½œï¼Œæœ€å¤§åŒ–å‡å°‘é”ç«äº‰çš„å¼€é”€

```java
    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        // è®¡ç®—å“ˆå¸Œå€¼
        // ä¸ HashMap ç±»ä¼¼ï¼Œé‡‡ç”¨äº†é«˜16ä½å’Œä½16ä½å¼‚æˆ–çš„æ–¹å¼æ¥é™ä½å“ˆå¸Œå†²çª
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh; K fk; V fv;
            if (tab == null || (n = tab.length) == 0)
                // åº•å±‚ table æœªåˆå§‹åŒ–æ—¶ï¼Œæ‰§è¡Œåˆå§‹åŒ–
                // ä½¿ç”¨ CAS ç¡®ä¿åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥åˆå§‹åŒ–ï¼Œå…¶ä»– CAS å¤±è´¥çš„çº¿ç¨‹æ‰§è¡Œ yield è¿›è¡Œè‡ªæ—‹
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                // é€šè¿‡ CAS çš„æ–¹å¼è¿›è¡Œç©ºæ¡¶æ’å…¥
                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                // å‘ç°å…ƒç´ è½åœ¨å·²è¿ç§»çš„å“ˆå¸Œæ¡¶
                // ååŠ©è¿ç§»è¿‡ç¨‹ï¼Œæœ€åè¿”å›nextTabï¼Œåœ¨ä¸‹ä¸€è½®å¾ªç¯ä¸­å®Œæˆæ•°æ®æ’å…¥
                tab = helpTransfer(tab, f);
            else if (onlyIfAbsent // check first node without acquiring lock
                     && fh == hash
                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))
                     && (fv = f.val) != null)
                return fv;
            else {
                V oldVal = null;
                // å“ˆå¸Œæ¡¶å·²ç»æœ‰æ•°æ®ï¼Œéœ€è¦é”ä½æ¡¶å¤´é¿å…å…¶ä»–çº¿ç¨‹çš„å†™å…¥æˆ–æ‰©å®¹å½±å“
                synchronized (f) {
                    // åŒé‡æ£€æŸ¥ï¼Œé˜²æ­¢åœ¨ç­‰å¾…é”æœŸé—´ï¼Œè¯¥æ¡¶è¢«æ‰©å®¹ï¼ˆå˜ä¸º ForwardingNodeï¼‰
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            // é“¾è¡¨çš„æ–¹å¼æ’å…¥
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key, value);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            // çº¢é»‘æ ‘çš„æ–¹å¼æ’å…¥
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                        else if (f instanceof ReservationNode)
                            throw new IllegalStateException("Recursive update");
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        // æ›´æ–°å…ƒç´ æ•°é‡ï¼Œå¦‚æœè¶…å‡ºsizeCtlï¼Œå°±éœ€è¦æ‰©å®¹
        addCount(1L, binCount);
        return null;
    }

```


### get

- ConcurrentHashMap ä¸­æœ‰ä¸€äº›ç‰¹æ®Šçš„ hash å€¼ï¼Œ-1 ä»£è¡¨æ­£åœ¨æ‰©å®¹ï¼Œ-2 ä»£è¡¨çº¢é»‘æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œç¢°ä¸Šè¿™ä¸¤ç§æƒ…å†µæ—¶éœ€è¦ç‰¹æ®Šå¤„ç†
- `get()` æ–¹æ³•è¯»å–æ•°æ®ä¸éœ€è¦åŠ é”
    - åº•å±‚çš„ table ç”¨ `volatile` ä¿®é¥°ï¼Œä¸€æ—¦æ‰©å®¹å®Œæˆï¼Œå°±èƒ½ç«‹åˆ»è¯»å–åˆ°æ–° table
    - è·å–å…ƒç´ æ—¶ï¼Œä½¿ç”¨çš„ `tabAt` æ–¹æ³•åº•å±‚ä½¿ç”¨ `UnSafe` çš„ `getReferenceVolatile` å®ç°ï¼Œä»¥ `volatile` è¯­ä¹‰ä¿è¯è¯»å–æ•°ç»„å…ƒç´ çš„å¯è§æ€§
    - Node çš„ val å’Œ next éƒ½ç”¨ `volatile` ä¿®é¥°ï¼Œä¿è¯æ•°æ®çš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹å¯è§


```java
    public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        // è®¡ç®—keyå¯¹åº”çš„ç´¢å¼•
        int h = spread(key.hashCode());
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (e = tabAt(tab, (n - 1) & h)) != null) {
            // å’Œå“ˆå¸Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„hashå€¼ç›¸åŒ
            if ((eh = e.hash) == h) {
                // ç›´æ¥å‘½ä¸­å“ˆå¸Œæ•°ç»„ä¸Šçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            else if (eh < 0)
                // hashå€¼å°äº0ï¼Œè¯´æ˜æ­£åœ¨æ‰©å®¹æˆ–è€…æ˜¯çº¢é»‘æ ‘ï¼Œå¦‚æœæ˜¯ ForwardingNodeï¼Œä¼šå»nextTabä¸­å¯»æ‰¾
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) {
                // æ— æ³•å‘½ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”hashå€¼æ­£å¸¸ï¼Œå¹¶ä¸”å‘ç°è¿˜æœ‰åç»­èŠ‚ç‚¹ï¼Œè¯´æ˜å½“å‰æ˜¯é“¾è¡¨ç»“æ„ï¼ŒæŒ‰ç…§é“¾è¡¨çš„æ–¹å¼æŸ¥è¯¢
                if (e.hash == h &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
```


## JDK 1.7 ConcurrentHashMap

> å¯¹äº JDK 1.7 çš„ ConcurrentHashMapï¼Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨å’Œ JDK 1.8 çš„åŒºåˆ«


### æ ¸å¿ƒæœºåˆ¶

| æœºåˆ¶ | JDK 1.7 å®ç°è¦ç‚¹ |
| ---- | --------------- |
| åº•å±‚ç»“æ„ | Segmentæ•°ç»„ (åˆ†æ®µé”) <br> æ¯ä¸ª Segment æ˜¯ HashEntryæ•°ç»„ + é“¾è¡¨çš„ç»“æ„ |
| åˆå§‹åŒ– | æ„é€ æ—¶ä¸€æ¬¡æ€§åˆ›å»ºæ‰€æœ‰ Segmentæ•°ç»„ï¼Œå¯¹äº HashEntryæ•°ç»„åˆ™æ˜¯æ‡’åŠ è½½ (ç¬¬ä¸€æ¬¡putæ—¶åˆå§‹åŒ–) |
| put | 1. æ ¹æ®å“ˆå¸Œç¡®å®šç”¨å“ªä¸€ä¸ª Segemnt <br> 2. Segment å†…éƒ¨ä½¿ç”¨ ReentrantLock è¿›è¡ŒåŠ é” <br> 3. åœ¨ Segment å†…éƒ¨åƒ HashMap ä¸€æ · put |
| get | æ— é”æ“ä½œï¼Œä¾èµ– volatile ä¿è¯ HashEntry.val/next çš„æ•°æ®å¯è§æ€§ |
| æ‰©å®¹ | æ¯ä¸ª Segment ç‹¬ç«‹æ‰©å®¹ <br> åªé”å½“å‰ Segmentï¼Œä¸å½±å“å…¶ä»– Segment |
| ä¿è¯å¹¶å‘æ€§èƒ½ | Segment ä»£è¡¨ä¸€ä¸ª HashMapï¼Œç”¨ 16 ä¸ªï¼ˆé»˜è®¤ï¼‰ReentrantLock ä¿æŠ¤ 16 ä¸ªç‹¬ç«‹çš„å° HashMapï¼Œå®ç°å¹¶å‘ |


### åº•å±‚ç»“æ„å¯¹æ¯”

| å¯¹æ¯”ç»´åº¦ | JDK 1.7 | JDK 1.8 |
| ------- | -------- | ------- |
| ç»“æ„ | åº•å±‚ç»“æ„ Segment[] + HashEntry[] | åº•å±‚ç»“æ„æ˜¯ Node[] |
| å†…å­˜å¼€é”€ | æ¯ä¸ª Segment æœ‰ ReentrantLockã€table å­—æ®µï¼Œå†…å­˜å¼€é”€å¤§ | çœå» Segment ç»“æ„ï¼Œä¸å•ç‹¬ç»´æŠ¤ ReentrantLockï¼Œæ›´è½»é‡åŒ– |


### é”ç²’åº¦å¯¹æ¯”

| å¯¹æ¯”ç»´åº¦ | JDK 1.7 | JDK 1.8 |
| ------- | -------- | ------- |
| é”å•ä½ | åŠ é”æ—¶ä¼šé”ä½ä¸€æ•´ä¸ª Segment | åŠ é”æ—¶é”ä½å•ä¸ªå“ˆå¸Œæ¡¶ |
| å¹¶å‘åº¦ | å› ä¸ºåŠ é”ä¼šé”ä½ Segmentï¼Œæ‰€ä»¥å¹¶å‘åº¦ = Segment | å› ä¸ºåŠ é”åªé”ä½ä¸€ä¸ªå“ˆå¸Œæ¡¶ <br> æ‰€ä»¥ç†è®ºå¹¶å‘åº¦ = å“ˆå¸Œæ¡¶æ•°é‡ |
| é”ç«äº‰ | å› ä¸º Segment å†…å­˜å¼€é”€è¾ƒå¤§ï¼ŒSegment æ•°é‡ä¸ä¼šå¤ªå¤š <br> å¹¶ä¸” Segment[] ä¹Ÿä¸ä¼šæ‰©å®¹ï¼Œæ‰€ä»¥é”çš„ç«äº‰ä¼šæ›´å¤š | ConcurrentHashMap ä¼šæ‰©å®¹ <br> å› æ­¤å“ˆå¸Œæ¡¶ä¼šå˜å¤šï¼Œé”ç«äº‰æ›´å°‘ |


### æ‰©å®¹æœºåˆ¶

| å¯¹æ¯”ç»´åº¦ | JDK 1.7 | JDK 1.8 |
| ------- | -------- | ------- |
| æ‰©å®¹å•ä½ | æ¯ä¸ª Segment ç‹¬ç«‹æ‰©å®¹ | æ•´ä¸ª table æ‰©å®¹ |
| æ‰©å®¹æ•ˆç‡ | æ‰©å®¹åªèƒ½ä¸€ä¸ªçº¿ç¨‹å®Œæˆ <br> å½“ Segment è¾ƒå¤§æ—¶æ‰©å®¹é€Ÿåº¦ä¼šä¸‹é™ | å……åˆ†åˆ©ç”¨å¤šæ ¸ CPU å¤šçº¿ç¨‹åä½œæ‰©å®¹ <br> å¤§è¡¨æ‰©å®¹æ—¶ï¼Œå‚ä¸çš„çº¿ç¨‹è¶Šå¤šæ‰©å®¹è¶Šå¿« | 


## å…³é”®é¢è¯•é—®é¢˜


### ConcurrentHashMap å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨

ConcurrentHashMap ä¿è¯çº¿ç¨‹å®‰å…¨åœ¨ä»¥ä¸‹å„ä¸ªæ–¹é¢ï¼š

- åˆå§‹åŒ–ï¼šé€šè¿‡ CAS ä¿®æ”¹ `sizeCtl` å’ŒåŒé‡æ£€æŸ¥ `table` çš„æ–¹å¼**ä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è¿›å…¥åˆå§‹åŒ–å·¥ä½œ**ï¼Œå…¶ä»–çº¿ç¨‹è°ƒç”¨ `yield()` è‡ªæ—‹ç­‰å¾…
- put æ“ä½œï¼š
    - ç©ºå“ˆå¸Œæ¡¶ï¼šCAS æ— é”æ’å…¥
    - æœ‰æ•°æ®çš„å“ˆå¸Œæ¡¶ï¼šä½¿ç”¨ `synchronized` åªé”ä½å“ˆå¸Œæ¡¶ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œé”ç²’åº¦æ›´ç²¾ç»†
    - é‡åˆ°æ‰©å®¹ï¼šè·³è½¬æ–°è¡¨ï¼Œä¸‹ä¸€è½®å¾ªç¯åœ¨æ–°è¡¨æ’å…¥
- get æ“ä½œï¼šè¯»æ“ä½œä¸åŠ é”ï¼Œä¾èµ– `volatile` å­—æ®µï¼ˆ`val`, `next`ï¼‰å’Œ `tabAt()`ï¼ˆvolatile è¯»ï¼‰ä¿è¯å¯è§æ€§
- æ‰©å®¹æ“ä½œï¼šå¤šçº¿ç¨‹åä½œï¼Œ**é€šè¿‡ `ForwardingNode` ç¡®ä¿è¯»å†™æ“ä½œåœ¨æ–°æ—§è¡¨ä¸­åˆ‡æ¢**


### ä¸ºä»€ä¹ˆ ConcurrentHashMap çš„è¯»æ“ä½œä¸éœ€è¦åŠ é”

- `Node` çš„ `val` å’Œ `next` å­—æ®µéƒ½ä½¿ç”¨ `volatile` ä¿®é¥°ï¼Œæ‰€æœ‰ä¿®æ”¹èƒ½**ä¿è¯å¯è§æ€§**
- è·å–å…ƒç´ æ—¶ä½¿ç”¨ `tabAt()` æ–¹æ³•ï¼Œåº•å±‚é€šè¿‡ `UnSafe` ç±»çš„ `getReferenceVolatile` å®ç°ï¼Œ**ä»¥ volatile è¯­ä¹‰ä¿è¯è¯»å–å…ƒç´ æ“ä½œçš„å¯è§æ€§**
- é‡ä¸Šæ‰©å®¹å¹¶ä¸”å“ˆå¸Œæ¡¶æ­£åœ¨è¢«è¿ç§»æ—¶ï¼Œå½“å‰èŠ‚ç‚¹ä¼šå˜æˆ `ForwardingNode`ï¼Œè‡ªåŠ¨è·³è½¬æ–°è¡¨æŸ¥æ‰¾å…ƒç´ 


### ConcurrentHashMap æ‰©å®¹æ—¶ï¼Œä¸ºä»€ä¹ˆget/putæ“ä½œéƒ½ä¸é˜»å¡

- get æ“ä½œï¼šæŸ¥è¯¢å…ƒç´ æ—¶ç¢°ä¸Š `ForwardingNode` (hash=-1)ï¼Œä¼šè°ƒç”¨ `find()` è‡ªåŠ¨å»æ–°è¡¨æŸ¥è¯¢
- put æ“ä½œï¼š
    - å¦‚æœæ­£åœ¨æ‰©å®¹ä½†æ˜¯å½“å‰å“ˆå¸Œæ¡¶è¿˜æ²¡è¿ç§»ï¼Œé‚£ä¹ˆåœ¨æ—§è¡¨ä¸­å®Œæˆæ’å…¥æ•°æ®ï¼Œåç»­æ—§è¡¨ä¼šè¢«è¿ç§»åˆ°æ–°è¡¨
    - å¦‚æœæ­£åœ¨æ‰©å®¹ä½†æ˜¯å½“å‰å“ˆå¸Œæ¡¶æ­£åœ¨è¿ç§»ï¼Œä¼šå› ä¸ºè·å–å“ˆå¸Œæ¡¶å¤´é”è€ŒçŸ­æš‚ç­‰å¾…ï¼Œä½†æ˜¯æ‹¿åˆ°é”åä¼šå‘ç°å½“å‰èŠ‚ç‚¹å·²ç»å˜æˆ `ForwardingNode`ï¼Œ ä¼šè·³è½¬åˆ°æ–°è¡¨æ¥ç»§ç»­å®Œæˆæ’å…¥æ•°æ®
    - å¦‚æœæ‰©å®¹å·²ç»å®Œæˆäº†ï¼Œç”±äº `table` è¢« `volatile` ä¿®é¥°ï¼Œé‚£ä¹ˆç›´æ¥åœ¨æ–°è¡¨ä¸­æ’å…¥æ•°æ®


### sizeCtl çš„ä½œç”¨

sizeCtl å…¶å®è•´å«äº†ä¸€äº›çŠ¶æ€æœºæ€ç»´

- `sizeCtl > 0`ï¼šåœ¨æ„é€ é˜¶æ®µï¼Œå®ƒä»£è¡¨äº†åˆå§‹å®¹é‡ï¼›åœ¨åˆå§‹åŒ–å®Œæˆåï¼Œå®ƒä»£è¡¨äº†æ‰©å®¹é˜ˆå€¼
- `sizeCtl = -1`ï¼šè¡¨ç¤ºæ­£åœ¨åˆå§‹åŒ–
- `sizeCtl < -1`ï¼šè¡¨ç¤ºæ­£åœ¨æ‰©å®¹ï¼Œä½16ä½æ˜¯å‚ä¸æ‰©å®¹çš„çº¿ç¨‹æ•°

é€šè¿‡ volatile ä¿®é¥°å’Œ CAS æ“ä½œï¼Œå®ç°äº† `sizeCtl` çš„æ— é”åŒ–è½¬æ¢


### ConcurrentHashMap åœ¨ JDK 1.8 å’Œ JDK 1.7 ä¸­çš„å¯¹æ¯”

ä»ä»¥ä¸‹å‡ ä¸ªç»´åº¦åˆ†æä»–ä»¬çš„å·®å¼‚ï¼š
- å­˜å‚¨ç»“æ„ï¼šJDK 1.7 ä¸­ ConcurrentHashMap çš„ç»“æ„æ˜¯ Segment æ•°ç»„ + HashEntry æ•°ç»„ + é“¾è¡¨çš„ç»“æ„ï¼Œæ¯ä¸€ä¸ª Segment ç›¸å½“äºä¸€ä¸ª HashMapï¼›JDK 1.8 ä¸­ ConcurrentHashMap æ˜¯ Node æ•°ç»„ + é“¾è¡¨/çº¢é»‘æ ‘çš„ç»“æ„
- é”é¢—ç²’åº¦ï¼šJDK 1.7 ä¸­ ConcurrentHashMap åœ¨æ’å…¥æ•°æ®æ—¶ä¼šé”ä½æ•´ä¸ª Segmentï¼Œç›¸å½“äºé”ä½å•ä¸ª HashMapï¼Œå¯¹äºåŒä¸€ä¸ª Segment çš„ä¿®æ”¹æ“ä½œéƒ½è¦é˜»å¡ç­‰å¾…ï¼›JDK 1.8 ä¸­ ConcurrentHashMap åœ¨æ’å…¥/æ‰©å®¹æ—¶ä¼šé”ä½å•ä¸ª Nodeï¼ˆå“ˆå¸Œæ¡¶ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œå…¶ä»–å“ˆå¸Œæ¡¶å¯ä»¥æ­£å¸¸æ“ä½œï¼Œé”é¢—ç²’åº¦æ›´å°
- æ‰©å®¹æœºåˆ¶ï¼šJDK 1.7 ä¸­ ConcurrentHashMap æ¯ä¸€ä¸ª Segment ç‹¬ç«‹æ‰©å®¹ï¼›JDK 1.8 ä¸­ ConcurrentHashMap å…¨è¡¨æ‰©å®¹ï¼Œä½†æ˜¯å¯ä»¥å¤šçº¿ç¨‹åä½œ


### ConcurrentHashMap åœ¨ JDK 1.8 ä¸­æ”¾å¼ƒ Segment çš„åŸå› 

ä¸»è¦æœ‰ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒåŸå› ï¼š
- é”é¢—ç²’åº¦å¤ªç²—ï¼ŒJDK 1.7 ä¸­å¯¹æ•´ä¸ª Segment åŠ é”ï¼Œé»˜è®¤åªæœ‰ 16 ä¸ª Segmentï¼Œå¹¶å‘åº¦ä¸é«˜ï¼›JDK 1.8 å¯¹å•ä¸ªå“ˆå¸Œæ¡¶åŠ é”ï¼Œé¢—ç²’åº¦æ›´å°
- å†…å­˜å¼€é”€å¤ªå¤§ï¼šJDK 1.7 ä¸­ Segment æ•°ç»„å³ä½¿æ²¡æœ‰ç”¨åˆ°ï¼Œéƒ½è¦åˆå§‹åŒ–ï¼Œå¹¶ä¸” Segment ä¸­å„è‡ªç»´æŠ¤ ReentrantLock å’Œ table å­—æ®µ
- å¤§è¡¨æ‰©å®¹æ•ˆç‡ä¸é«˜ï¼šSegment å†…éƒ¨æ‰©å®¹æ— æ³•å……åˆ†åˆ©ç”¨å¤šçº¿ç¨‹åä½œçš„èƒ½åŠ›ï¼Œå½“ Segment å˜å¤§ï¼Œæ‰©å®¹ã€è¿ç§»çš„æ•ˆç‡ä¼šä¸‹é™
