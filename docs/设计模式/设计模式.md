# 设计模式

**最重要的目的：解耦**。开发时区分开，运行时合并用

## 创建型

简单来说目的就是new对象的

对类的实例化进行了抽象，能够使软件模块做到与对象的创建和代码组织无关

### 工厂模式

#### 简单工厂模式（产品的工厂）

**定义**：由一个工厂对象决定创建出哪一种产品类的实例。但他**不属于 GOF 23种设计模式之一**

**理解**：不主动地调用经常需要创建的对象的构造方法，而是使用一个工厂来调用其方法帮助我们创建这个需要创建的对象

**适用场景**：**创建对象较少且数量确定的场景**。例如：`Calendar`，明确地知道所有子类且逻辑与数目不会被改变

**优点**：只需传入一个正确的参数或不传入也可以，就可以获取所需对象，无须知道创建细节

**缺点**：增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则，不易于扩展过于复杂的产品结构

#### 工厂方法模式（工厂的工厂）

**定义**：定义一个创建对象的工厂**接口**（定义所有工厂的规范，一般不会用抽象类），让实现这个工厂接口的工厂实现类来决定实例化哪个类。工厂方法模式让类的实例化推迟到工厂实现类中进行

**理解**：不同的类由不同的工厂来创建，这些工厂都实现了原始的工厂接口。

**适用场景**：创建对象需要大量重复的代码。客户端不依赖于产品类实例如何被创建、实现等细节。**一个类通过其子类来指定创建哪个对象**。解决产品扩展的问题（简单工厂模式当新增产品时需要修改工厂类的逻辑，而工厂方法模式只需新增工厂）

**优点**：用户只需要关系所需产品对应的工厂，无须关心创建细节。且新加入产品符合开闭原则，提高系统的可扩展性（加入新的工厂即可，无须修改原有工厂）

**缺点**：类的个数容易过多（新加一个对象，需要新加一个类和一个负责创建它的工厂类），增加代码结构复杂度，增加系统的抽象性和理解难度

#### 抽象工厂模式（复杂产品的工厂）

**定义**：提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类

**理解**：抽象的工厂，创建抽象的对象；具体的工厂继承抽象的工厂，创建的对象实现抽象的对象。相当于定义一个**具有标准**的产品制作的标准，不同的工厂创建不同的产品。例如：格力公司制作格力冰箱、格力空调；美的公司制作美的冰箱、美的空调 --> I工厂制作I冰箱、I空调。**不光需要实现工厂，也需要实现具体产品**

**适用场景**：客户端不依赖于产品类实例如何被创建、实现的细节。强调一系列属于同一产品族的产品对象一起使用创建对象需要大量重复的代码。**提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现**

**优点**：具体产品在应用层代码隔离，无须关心创建细节。将一个系列的产品族统一到一起创建。

**缺点**：规定了所有的被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。类非常多，增加系统的理解难度

**抽象工厂模式和工厂方法模式的区别**：

- 工厂方法是一个实现标准的具体工厂定义一个实现标准的具体产品；抽象工厂是一个实现标准的具体工厂定义一系列实现标准的具体产品（生态）

- 抽象工厂的顶层工厂可以是接口，也可以是包含一部分前置后置逻辑的抽象类

**Spring中的抽象工厂**：`AbstractFactory` --> `AnnotationApplicationContext`、`XmlApplicationContext`

### 单例模式

**定义**：

- 确保一个类在任何情况下都绝对只有一个实例
- 并提供一个全局访问点（如：`getInstance()`）
- 隐藏其所有的构造方法（私有构造方法）

**适用场景**：确保任何情况下都绝对只有一个实例。例：`ServletContext`、`ApplicationContext`

**常见写法**：

1. 饿汉式单例
2. 懒汉式单例
3. 注册式单例
4. ThreadLocal单例

**例子**：

1. Spring中的`AbstractFactoryBean`类中的`getObject`方法，检查这个bean是否单例，如果是单例则继续判断是否已初始化，如果已经初始化，那么就返回这个单例对象，否则再创建这个对象
2. MyBatis中的`ErrorContext`类中的`instance`方法，先通过ThreadLocal对象来get获取对象，然后判断这个对象是否为null，如果是null，就实例化且存入ThreadLocal对象中，否则直接返回。隔离了每一个线程的错误信息

**优点**：

1. 在内存中只有一个实例，减少内存开销
2. 可以避免对资源的多重占用
3. 设置全局访问点，严格控制访问

**缺点**：没有接口，扩展困难，只能修改源代码

#### 重点知识点

1. 私有化构造方法
2. 保证线程安全（参考懒汉式单例）
3. 延迟加载（目的是为了避免大量单例对象在系统初始化时一并创建给内存带来巨大的压力）
4. 防止序列化和反序列化破坏单例（编写readResolve方法）
5. 防止反射破坏单例（参考枚举式单例）

#### 饿汉式单例

**在单例类首次加载时就创建实例**

```java
public class HungrySingleton {

    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton() {}

    public static HungrySingleton getInstance() { return hungrySingleton; }
}
```

**优点**：执行效率高，没有任何锁

**缺点**：在类加载的时候就创建对象，在某些情况下（系统中存在大量饿汉式单例类），**可能会造成内存浪费**

**例子**：Spring中IoC容器中作用域为singleton的bean

#### 懒汉式单例

**被外部类调用时才创建单例**



简单写法

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {}

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

**优点**：节省了内存空间

**缺点**：线程不安全

结果：

- 两个线程返回相同的结果
  - 两个线程按顺序执行完了`getInstance()`方法
  - A线程执行到创建实例语句时被B线程抢占CPU，B线程创建完实例后被A线程抢占CPU，导致B创建的实例被A创建的实例覆盖，所以返回了相同的结果
- 两个线程返回不同的结果
  - A线程执行到创建实例语句时被B线程抢占CPU，B线程创建完实例后返回了结果，CPU轮到A线程，A线程也正常返回结果
- 可以看到：**无论两个线程返回的结果是否相同，都有线程不安全的隐患**



加锁写法

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {}

    //解决线程安全问题
    public synchronized static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }

}
```









---

```java
public class LazySimpleSingleton {

    private static LazySimpleSingleton instance;

    private LazySimpleSingleton() {}

    public static LazySimpleSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}
```

**优点**：调用时才创建，节省了内存

**缺点**：可能造成线程不安全的问题。**有可能**多个线程同时抢占到资源，进入了`getInstance`方法，通过判断条件，**同时创建了多个实例**

**解决方案**：

1. 在`getInstance`方法上加**`synchronized`**关键字。**缺陷：性能受到限制**

   ```java
   public class LazySimpleSingleton {
   
       private static LazySimpleSingleton instance;
   
       private LazySimpleSingleton() {}
   
       //解决线程安全问题
       public synchronized static LazySimpleSingleton getInstance() {
           if (instance == null) {
               instance = new LazySimpleSingleton();
           }
           return instance;
       }
   
   }
   ```

   

2. **双重检查**。性能提升并解决了线程安全问题；`volatile`关键字：解决指令重排序问题。**缺陷：程序可读性降低**

   ```java
   public class LazyDoubleCheckSingleton {
   
       //解决指令重排序的问题
       private volatile static LazyDoubleCheckSingleton instance;
   
       private LazyDoubleCheckSingleton() {
       }
   
       public static LazyDoubleCheckSingleton getInstance() {
           //检查是否要阻塞
           if (instance == null) {
               synchronized (LazyDoubleCheckSingleton.class) {
                   //检查是否要重新创建实例
                   if (instance == null) {
                       instance = new LazyDoubleCheckSingleton();
                   }
               }
           }
           return instance;
       }
   
   }
   ```

3. **静态内部类**。静态内部类与静态属性不同，静态成员变量是加载时分配空间，静态内部类是使用时才分配内存空间。优点：写法优雅；利用了Java本身的语法特点；性能高；避免内存浪费。**缺陷：能够被反射破坏**

   ```java
   public class LazyStaticInnerClassSingleton {
   
       private LazyStaticInnerClassSingleton() {
         //通过判断INSTANCE是否为null来检查是否使用反射来破坏单例了，如果不为null，那么证明非法访问。因为如果用反射来获取这个类的构造方法时，也会加载LazyHolder从而INSTANCE得到初始化，那么这时判断INSTANCE是否为null即可判断是否非法访问。因为正常访问是不能够也不会去访问构造方法，只会去访问getInstance方法
       }
   
       public LazyStaticInnerClassSingleton getInstance() {
           return LazyHolder.INSTANCE;
       }
   
       private static class LazyHolder {
           private static final LazyStaticInnerClassSingleton INSTANCE = new LazyStaticInnerClassSingleton();
       }
   
   }
   ```

##### 反射破坏单例模式

1. 获取class对象
2. 通过`class.getDeclaredConstructor()`方法获取私有构造方法
3. 通过`class.setAccessible(true)`方法访问私有构造方法
4. 通过`constructor.newInstance()`方法调用私有构造方法

**解决方案**：在构造方法中加入限制

#### 注册式单例

**将每一个实例都缓存到统一的容器中，使用唯一标识获取实例**

##### 枚举式单例

```java
public enum EnumSingleton {
    INSTANCE;

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }
}
```

**优点**：

1. 无法使用反射来破坏单例的特性：枚举类比较特殊，**jdk规定了无法使用反射来创建枚举类的对象**
2. 不存在线程安全的问题：枚举类在加载时已经创建好对象并放入容器`Map<String, T> enumConstantDirectory`中，类似饿汉式单例

**缺点**：由于类似饿汉式单例，所以如果系统中存在大量的注册式单例类的话，会对内存带来一定负担。**序列化/反序列化时单例被破坏**

##### 容器式单例(Spring中IoC容器使用的单例模式)

```java
public class ContainerSingleton {

    private ContainerSingleton() {
    }

    private static Map<String, Object> ioc = new ConcurrentHashMap<>();

    public static Object getInstance(String className) {
        if (ioc.containsKey(className)) {
            Object instance = null;
            try {
                instance = Class.forName(className);
                ioc.put(className, instance);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return instance;
        } else {
            return ioc.get(className);
        }
    }

}
```

**缺点**：**存在线程安全问题**

##### 序列化/反序列化破坏单例模式

对象A序列化并持久化后，再重新读取到内存时反序列化生成的对象B，对象A和对象B的地址值不一致

**解决方案**：在类中加入以下方法

```java
public Object readResolve() {return INSTANCE;}
```

因为在ObjectInputStream类中有`readObject`方法，这个方法会去检查类是否有`readResolve`方法，如果有则调用这个方法，**直接返回这个方法的结果，而不创建新的对象**

#### ThreadLocal单例

**保证线程内单例，得益于ThreadLocal，天生线程安全**

```java
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    private ThreadLocalSingleton() {
    }

    public static ThreadLocalSingleton getInstance() {
        return threadLocalInstance.get();
    }
}
```

ThreadLocal中的Map以线程为key，对象为value存储，所以保证线程隔离

#### 破坏单例的情况

##### 多线程破坏单例

1. 两个线程执行完结果一致
   1. 正常结果，两个结果一致
   2. 线程1执行到返回语句时，线程2执行了实例化语句，导致线程2覆盖了线程1而得出两个相同对象的现象
2. 两个线程执行完结果不一致：线程1、线程2实例化了两个对象

### 原型模式

**定义**：原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数。**把复制的过程封装起来**

**核心**：**拷贝**。不通过new关键字（构造方法）创建对象，而是通过拷贝的方式创建对象

**组成**：

1. 接口：抽象原型（可以做一个泛型），必须要有一个clone方法，返回该类型对应的对象
2. 实现类：正常的实体类，并实现clone方法

**使用场景**：

1. 类初始化消耗资源较多
2. new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
3. 构造方法比较复杂（字段多）
4. 循环体中生产大量对象

## 结构型

简单来说是用于控制代码组成结构的、代码的表现形式

描述类和对象之间如何进行有效的组织，以形成良好的软件体系结构，主要的方式是使用继承方式来组织各个类

## 行为型

简单来说是用于控制逻辑的

描述类和对象之间如何交互以及如何分配职责	

# 作业

## 工厂模式

**工厂类一定需要将构造方法私有化吗，为什么？**

答：一般情况下与单例模式结合使用，单例模式的特点是将构造方法私有化。不一定，只有工厂需要变成单例时，才需要将构造方法私有化

---

**用工厂模式设计支付业务场景，包含跨境支付，支付宝，微信，银联支付，并画出类图**（需结合策略模式）

## 单例模式

**如何解决容器式单例的线程安全问题**

答：从Spring源码着手，getInstance中加锁synchronized和双重检测。Spring锁的是一个容器



# Spring中用到的设计模式

- 工厂模式：BeanFactory
- 装饰器模式：BeanWrapper
- 代理模式：AopProxy
- 单例模式：ApplicationContext
- 委派模式：DispatcherServlet
- 策略模式：HandlerMapping
- 适配器模式：HandlerAdapter
- 模板方法模式：JdbcTemplate
- 观察者模式：ContextLoaderListener



## 总结

|   设计模式   |         目的         |     案例     |                   框架源码                    |           一句话归纳           |
| :----------: | :------------------: | :----------: | :-------------------------------------------: | :----------------------------: |
|   工厂模式   |     封装创建细节     |   实体工厂   |        LoggerFactory<br />BeanFactory         |     产品标准化，生产更高效     |
|   单例模式   |    保证实例唯一性    |  CEO、太阳   |             Calendar<br />Runtime             |         保证实例唯一性         |
|   原型模式   |     高效创建对象     |     克隆     |         ArrayList<br />PrototypeBean          |     避免用构造方法创建对象     |
|  建造者模式  |   开放个性配置步骤   |     选配     |   StringBuilder<br />BeanDefinitionBuilder    |           个性化配置           |
|   代理模式   |       增强职责       |     媒婆     |      CglibAopProxy<br />ProxyFactoryBean      |               -                |
|   门面模式   |     统一访问入口     |     前台     |         JdbcUtils<br />RequestFacade          |     打开一扇门，走向全世界     |
|  装饰器模式  |  灵活扩展，同宗同源  |     奶茶     |         BufferReader<br />InputStream         |               -                |
|   享元模式   |      共享资源池      |    线程池    |        String、Integer<br />ObjectPool        |   优化资源配置，减少重复浪费   |
|   组合模式   |    统一整体和个体    |  组织架构树  |             HashMap<br />SqlNode              |               -                |
|  适配器模式  |  兼容互换，求同存异  |  电源适配器  |      AdvisorAdapter<br />HandlerAdapter       |         亡羊补牢的手段         |
|   桥接模式   |    不允许使用继承    |      桥      |                 DriverManager                 |          约定优于配置          |
|   委派模式   |     只对结果负责     |   项目经理   | ClassLoader<br />BeanDefinitionParserDelegate | 这个需求很简单，怎么实现我不管 |
| 模板方法模式 |       逻辑复用       |      -       |         JdbcTemplate<br />HttpServlet         | 流程全部标准化，需要微调请覆盖 |
|   策略模式   |   把选择权交给用户   | 选择支付方式 |     Comparator<br />InstantiationStrategy     | 条条大路通罗马，具体哪条你决定 |
|  责任链模式  |     解耦处理逻辑     |    踢皮球    |                  FilterChain                  | 各人自扫门前雪，不管他人瓦上霜 |
|  迭代器模式  | 统一对集合的访问方式 |      -       |                   Iterator                    |               -                |
|   命令模式   |    解耦请求和处理    |    遥控器    |                   Runnable                    |               -                |
|   状态模式   |    绑定状态与行为    | 订单状态跟踪 |                   Lifecycle                   |   状态驱动行为，行为决定状态   |
|  备忘录模式  |         备份         |    草稿箱    |                       -                       |          后悔药、快照          |
|  中介者模式  |   统一管理网状资源   |    朋友圈    |                     Timer                     |   由一个对象统一维护所有关系   |
|  解释器模式  |   实现特定语法解析   |   摩斯密码   |                    Pattern                    |       一切解释权归我所有       |
|  观察者模式  | 解耦观察者与被观察者 |     闹钟     |             ContextLoaderListener             |          到点就通知我          |
|  访问者模式  |  解耦数据结构与操作  |   KPI考核    |             BeanDefinitionVisitor             |               -                |





策略模式 v 委派模式

共同点：行为型模式

不同点：策略模式关注的是能否相互替换，委派模式关注的是分发和调度的过程



工厂方法模式 v 抽象工厂模式

共同点：创建型模式

不同点：工厂方法模式单维度扩展，抽象工厂可以实现产品等级、产品族多维度扩展



中介者模式 v 桥接模式

共同点：具备将两个对象建立联系

不同点：中介者行为型 桥接模式结构型。中介者模式将多维度网状结构的对象建立联系；桥接模式将抽象、具象两个维度对象建立联系



委派模式 v 代理模式

共同点：保护目标对象

不同点：委派模式行为型 代理模式结构型。委派模式是一种全权静态代理，不对目标类的功能增强；代理模式会对目标类进行功能增强



代理模式 v 中介者模式

共同点：保护目标对象

不同点：代理模式结构型 中介者模式行为型。代理模式建立目标对象和代理对象的联系还要做功能增强；中介者模式只做建立联系的牵线搭桥工作，不参与具体过程



桥接模式 v 适配器模式

共同点：结构型

不同点：适配器模式希望已有代码是稳定的；桥接模式希望已有代码是可扩展的

桥接模式不推荐使用继承，适配器模式会采用继承



建造者模式 v 工厂模式

共同点：创建型，封装创建产品的细节

不同点：工厂模式希望封装细节创建标准产品，建造者模式希望创建定制化产品

工厂模式产品复杂程度比建造者模式的要复杂，建造者模式产品颗粒度更细

工厂模式一般是单例的，建造者模式一般是多例的



代理模式 v 适配器模式

共同点：结构型 保护目标对象的作用

不同点：代理模式为了功能增强，适配器模式为了解决兼容问题



适配器模式 v 装饰器模式

共同点：结构型模式

不同点：代码结构不同，装饰器同宗同源，适配器不需要同宗同源

适配器为了解决兼容问题，装饰器为了不改变原有功能的基础上增强



桥接模式 v 组合模式

共同点：行为型模式

不同点：桥接模式目的是将具象和抽象两个维度的继承体系建立联系，组合模式的目的是为了统一的API



策略模式 v 模板方法模式

共同点：行为型模式，可以将底层和应用层代码的某些细节分离

不同点：策略模式可以提供策略给用户选择，模板方法模式是在一个标准化的流程中开放某些微调的操作给用户



====



```
策略模式 VS 委派模式
```

 

```
共同点：行为型模式
不同点：策略模式能否相互替换，委派模式分发和调度的过程
关联：切换的上下文
```

 

 

```
工厂方法模式 VS 抽象工厂模式
共同点：1、创建型模式；2、职责相同
不同点：创建出来的产品扩展程度不一样，
    ``工厂方法单维度扩展，抽象工厂可以实现多维度扩展
关联：工厂方法很多情况下会作为抽象工厂的子类
```

 

 

```
策略模式vs代理模式
不同：策略行为型、代理是结构型
```

 

 

 

```
中介模式VS桥接模式
共同点：具备两个对象建立联系
不同点：1、行为型VS结构型
    ``2、中介者将多维度网状结构的对象建立联系；
      ``桥接模式将两个维度（抽象和具象）
关联：中介者是更复杂的桥
```

 

 

 

```
代理模式VS委派模式
共同点：都有保护目标对象的特性
不同点：1、结构型VS行为型
    ``2、职责不同，委派模式不对目标的功能做增强
           ``代理是一定要干活的
关联：委派就是全权静态代理，没有增强的代理就是委派
```

 

 

 

 

```
代理模式vs中介者模式
共同点：都有保护目标对象的特性
不同点：1、结构型VS行为型
    ``2、干预程度不同，代理是“媒婆”，中介者是“不负责任的媒婆”
    ``3、代理参与其中的过程，中介者只做牵线搭桥，不参与过程
关联：中介者是一种面向更加复杂的对象关系的全权静态代理（委派）
```

 

 

```
桥接模式 VS 适配器模式
共同点：1、都是结构型   
    ``2、都存在对象的间接引用关系
不同点：1、使用场景不同，适配器希望已有代码稳定的，桥接希望已有代码是扩展的
    ``2、原则不同：桥接不推荐使用继承的，适配器会采用继承
```

 

 

```
建造者VS工厂模式
共同点：1、都属于创建型
    ``2、职责相同，都是将创建产品的细节封装起来
不同点：1、目的不同：工厂模式希望创建标品（标准产品）、建造者希望创建个性化产品（定制化）
    ``2、产品复杂程度不一样：工厂模式产品相对单一，建造者产品粒度更细
关联：工厂一般会设置为单例，而建造者一般是多例
```

 

 

```
代理模式VS适配器模式
共同点：1、结构型模式
    ``2、包装器模式的实现
    ``3、都起到了隐藏和保护目标对象的作用
不同点：目的不同，代理为了功能增强、适配器为了解决兼容问题
关联：对象适配器其实就是静态代理的一种实现
```

 

 

```
Wrapper（包装器模式）
```

 

```
适配器VS装饰器
共同点：1、都属于结构型模式
    ``2、包装器模式的一种
不同点：1、装饰器同宗同源，适配器纯属伪装
    ``2、目的不同：适配器是为兼容（转换）、装饰器是为增强（不改变原有功能）
关联：结构上有点类似
```

 

 

```
桥接模式VS组合模式
共同点：都属于行为型模式
不同点：桥接模式的目的是将两个继承体系建立联系，组合模式的目的不是为了建立连接，而是统一的API
关联：关联性不大
```

 

 

```
策略模式VS模板方法模式
共同点：1、都属于行为型模式
    ``2、可以将底层和应用代码的某些细节分离
不同点：1、开放程度不一样：策略模式只允许用户选，模板模式允许微调
关联：混合使用
```