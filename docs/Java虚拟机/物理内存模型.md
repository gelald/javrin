# Java物理内存模型

> 本文从堆栈角度引入JMM，然后介绍JMM和物理内存之间的关系



## JMM 引入

> JMM：Java Memory Modal

### 堆栈的内容

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220406100824.png)

Heap （堆）包含了程序中创建的所有对象。无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上，其次对象上的成员变量，无论是基本类型还是引用类型也是存储在堆上。静态类变量也与类定义一起存储在堆上。

Thread Stack（线程栈）包含了每个方法的所有局部变量。基本类型的局部变量完全存储在线程栈中，一个线程可以将一个基本类型变量的**副本传递**给另一个线程，但它不能共享原始局部变量本身。引用类型的局部变量，引用存储在线程栈中，指向的对象存储在堆上。



## JMM 与硬件内存结构关系

### 硬件内存结构简介

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220411162526.png)

- CPU：现代计算机通常有 2 个或更多的 CPU（其中一些 CPU 有可能有多个内核），可以同时运行多个线程，支持多线程程序。
  - CPU 寄存器：每个 CPU 基本上包含一组在 CPU 内存中的寄存器，CPU 在这些寄存器上的操作比在主存储器的操作要更快。
- CPU 高速缓存存储器：CPU 可以碧主存储器更快地访问其告诉缓存存储器
- 主存储器：当 CPU 需要访问主存储器时，它会将部分数据读取到其 CPU 缓存；当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。



### JMM 与硬件内存连接

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413162651.png)

硬件架构是不区分线程栈和堆的，线程栈和堆都位于主存储器中，有一部分可能会位于 CPU 高速缓存和 CPU 内部寄存器中

当对象和变量可以存储在不同的存储区域中，可能会引发某些问题：

- Visibility of thread updates(writes) to shared variables.
- Race conditions when reading, checking and writing shared variables.

以下分别解释这两个问题



### 对象共享后的可见性

> 如果多个线程共享一个对象，那么其中一个线程对这个对象的更新可能对其他线程不可见。

共享对象最初是放在了主存储器中，然后在 CPU 上运行的线程把共享对象读入到其 CPU 高速缓存中，然后对其进行了修改。只要 CPU 高速缓存还没更新到主存储器中，这个对象的改动对其他线程是不可见的，每一个线程都拥有了这个共享对象副本，每个副本都位于不同的 CPU 高速缓存中

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413163651.png)

> 上图中，第一个线程对共享对象 obj 的 count 属性修改为 2，但其 CPU 高速缓存并未刷到主存储器中，导致另一个线程无法感知这个改动

解决方案：**使用 `volatile` 关键字来声明这个对象**。这个关键字可以保证直接从主内存器读取给定变量，**并在更新时始终写回主内存**



### 竞态条件

> 如果多个线程共享一个对象，并且多个线程更新该共享对象中的变量，可能会出现竞态

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220413165751.png)

> 上图中，假设 A 线程把共享对象 obj 读入自己的 CPU 高速缓存中并对 obj 的 count 属性 +1，并且 B 线程也在做同样的事情
>
> 如果这个加法操作有序进行了，那么这个属性最终写入到主存储器中应该是要 +2 的
>
> 但是这两个加法操作没有做到同步的控制，无论哪一个线程把自己 CPU 高速缓存中的对象写入到主存储器中时，最终这个属性也只是相较原来 +1

解决方案：**使用 `synchronized` 关键字包含这个加法操作**。被 `synchronized` 包住的代码块可以保证在同一时间只能有一个线程进入代码块中，**保证了代码块中的变量都从主存中读取**，并且不管变量是否被 `volatile` 修饰，**所有更新都始终写入到主存储器中**