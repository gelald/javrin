# 由串行到并行的故事

## 需求引入

现在需要设计一个复合了多个查询的接口

1. 查询订单信息
2. 查询司机信息
3. 查询车辆信息

这三个信息需要在一个查询接口中同时返回



## 串行实现

在设计一个复合了多个查询信息的接口时，一般情况下很容易想到串行的实现方式

```java
public void test1() throws InterruptedException {
    // 查询订单信息
    System.out.println("===== 正在查询订单信息 =====");
    TimeUnit.MILLISECONDS.sleep(200);
    // 查询司机信息
    System.out.println("===== 正在查询司机信息 =====");
    TimeUnit.MILLISECONDS.sleep(100);
    // 查询车辆信息
    System.out.println("===== 正在查询车辆信息 =====");
    TimeUnit.MILLISECONDS.sleep(200);
}
```

假设查询订单信息、司机信息、车辆信息分别需要 200ms、100ms、200ms，那么串行实现方式总体需要消耗的是500ms 的时间

串行实现的方式接口响应总时间是所有查询所需时间的总和，在某些查询需要花费比较长时间的情况下，接口容易导致超时



## 并行实现

当资源足以支撑并行方式实现的情况下，为了提升性能，可以采用并行的实现方式

```java
public void test2() {
    // 创建固定线程的线程池
    ExecutorService executor = Executors.newFixedThreadPool(10);
    // 创建CompletionService
    CompletionService<String> completionService = new ExecutorCompletionService<>(executor);

    // 定义查询订单信息任务
    Callable<String> orderCallableTask = () -> {
        System.out.println("===== 正在查询订单信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "order";
    };
    // 定义查询司机信息任务
    Callable<String> driverCallableTask = () -> {
        System.out.println("===== 正在查询司机信息 =====");
        TimeUnit.MILLISECONDS.sleep(100);
        return "driver";
    };
    // 定义查询车辆信息任务
    Callable<String> carCallableTask = () -> {
        System.out.println("===== 正在查询车辆信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "car";
    };

    // 提交查询订单信息任务
    completionService.submit(orderCallableTask);
    // 提交查询司机信息任务
    completionService.submit(driverCallableTask);
    // 提交查询车辆信息任务
    completionService.submit(carCallableTask);

    for (int i = 0; i < 3; i++) {
        try {
            // 等待1秒内如果获取不了数据则超时
            Future<String> future = completionService.poll(1, TimeUnit.SECONDS);
            String s = future.get();
            if ("order".equals(s)) {
                System.out.println("查询订单信息成功");
            } else if ("driver".equals(s)) {
                System.out.println("查询司机信息成功");
            } else if ("car".equals(s)) {
                System.out.println("查询车辆信息成功");
            }
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```



