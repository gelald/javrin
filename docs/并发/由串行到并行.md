# 由串行到并行的故事

## 需求引入

现在需要设计一个复合了多个查询的接口

1. 查询订单信息
2. 查询司机信息
3. 查询车辆信息

这三个信息需要在一个查询接口中同时返回



## 串行实现

在设计一个复合了多个查询信息的接口时，一般情况下很容易想到串行的实现方式

```java
public void test1() throws InterruptedException {
    // 查询订单信息
    System.out.println("===== 正在查询订单信息 =====");
    TimeUnit.MILLISECONDS.sleep(200);
    System.out.println("***** 查询订单信息成功 *****");
    // 查询司机信息
    System.out.println("===== 正在查询司机信息 =====");
    TimeUnit.MILLISECONDS.sleep(100);
    System.out.println("***** 查询司机信息成功 *****");
    // 查询车辆信息
    System.out.println("===== 正在查询车辆信息 =====");
    TimeUnit.MILLISECONDS.sleep(200);
    System.out.println("***** 查询车辆信息成功 *****");
}
```

假设查询订单信息、司机信息、车辆信息分别需要 200ms、100ms、200ms，那么串行实现方式总体需要消耗的是500ms 的时间

串行实现的方式接口响应总时间是所有查询所需时间的总和，在某些查询需要花费比较长时间的情况下，接口容易导致超时



## Runnable/Callable + Future 实现并行调用

当资源足以支撑并行方式实现的情况下，为了提升性能，可以采用并行的实现方式

### 开启子线程的方式有三种

- 继承 Thread 类

  - 重写 run 方法

  - 执行：

    ```java
    new Thread().start();
    ```

    

- 实现 Runnable 接口

  - 实现 run 方法

  - 执行：

    ```java
    new Thread(runnable).start();
    // 或者使用这种做法
    // 但是这种做法不常用，因为 Runnable 一般用于不需要返回结果的场景
    FutureTask<?> future = new FutureTask<>(runnable, result);
    new Thread(future).start();
    Object result = future.get();
    ```

    

- 实现 Callable 接口

  - 实现 call 方法

  - 执行：

    ```java
    FutureTask<?> future = new FutureTask<>(callable);
    new Thread(future).start();
    Object result = future.get();
    ```



----

Runnable 和 Callable 区别

- Runnable 的任务没有返回值；Callable 的任务有返回值
- Runnable 的任务不能抛出异常；Callable 的任务可以抛出异常



### Future 和 FutureTask

- Future 是一个接口，代表了一个异步计算的结果，提供检查是否计算完成、是否取消、获取计算结果的方法
- get 方法可以用于获取结果，一旦调用**会阻塞主线程**一直等待结果返回
- cancel 方法可以取消这个任务
- FutureTask 实现了 Future 接口，一般用于包装 Callable 对象提交给线程池执行



### 实现

```java
public void test2() throws ExecutionException, InterruptedException {
    // 定义查询订单信息任务
    Callable<String> orderCallable = () -> {
        System.out.println("===== 正在查询订单信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询订单信息成功 *****";
    };
    FutureTask<String> orderFuture = new FutureTask<>(orderCallable);
    // 定义查询司机信息任务
    Callable<String> driverCallable = () -> {
        System.out.println("===== 正在查询司机信息 =====");
        TimeUnit.MILLISECONDS.sleep(100);
        return "***** 查询司机信息成功 *****";
    };
    FutureTask<String> driverFuture = new FutureTask<>(driverCallable);
    // 定义查询车辆信息任务
    Callable<String> carCallable = () -> {
        System.out.println("===== 正在查询车辆信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询车辆信息成功 *****";
    };
    FutureTask<String> carFuture = new FutureTask<>(carCallable);
    // 启动查询订单信息任务
    new Thread(orderFuture).start();
    // 启动查询司机信息任务
    new Thread(driverFuture).start();
    // 启动查询车辆信息任务
    new Thread(carFuture).start();
    // 获取订单结果
    System.out.println(orderFuture.get());
    // 获取司机结果
    System.out.println(driverFuture.get());
    // 获取车辆结果
    System.out.println(carFuture.get());
}
```

这种方式总体上来说是实现了多个任务并行执行，任务总时间接近最耗时的任务

但是这种做法还存在一定的问题：每一个任务的线程都手动创建并启动，在实际开发中，线程的创建和销毁都比较消耗资源，不推荐手动创建线程，需要借助线程池来执行任务



## ExecutorService 实现并行调用

在实际开发中，并发编程往往会使用线程池来调度各线程任务，因为有时候一些线程执行的时间很短，但是频繁创建、销毁线程容易导致开销远大于实际的业务代码执行的开销

### ExecutorService

ExecutorService 是一个线程池的接口，提供了任务并行的方法

### ThreadPoolExecutor

ThreadPoolExecutor 实现了 ExecutorService 接口，是常用的线程池对象，其中包含不同的构造方法来创建不同类型的线程池

### Executors

Executors 提供了许多创建不同类型线程池的静态方法，但还是推荐使用线程池对象自己的构造方法来创建线程池（测试除外），因为使用 Executors 的静态方法容易导致 OOM 

更多关于线程池的资料可以点击这里：[线程池](docs/并发/线程池.md)

### 实现

```java
public void test3() throws ExecutionException, InterruptedException {
    // 定义线程池
    ExecutorService executorService = Executors.newFixedThreadPool(10);
    // 定义查询订单信息任务
    Callable<String> orderCallable = () -> {
        System.out.println("===== 正在查询订单信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询订单信息成功 *****";
    };
    // 定义查询司机信息任务
    Callable<String> driverCallable = () -> {
        System.out.println("===== 正在查询司机信息 =====");
        TimeUnit.MILLISECONDS.sleep(100);
        return "***** 查询司机信息成功 *****";
    };
    // 定义查询车辆信息任务
    Callable<String> carCallable = () -> {
        System.out.println("===== 正在查询车辆信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询车辆信息成功 *****";
    };
    // 提交查询订单信息任务
    Future<String> orderFuture = executorService.submit(orderCallable);
    // 提交查询司机信息任务
    Future<String> driverFuture = executorService.submit(driverCallable);
    // 提交查询车辆信息任务
    Future<String> carFuture = executorService.submit(carCallable);
    // 获取订单结果
    System.out.println(orderFuture.get());
    // 获取司机结果
    System.out.println(driverFuture.get());
    // 获取车辆结果
    System.out.println(carFuture.get());
    // 销毁线程池
    executorService.shutdown();
}
```

现在这种方式并行、线程池都满足了

但是还是存在一个问题：查询订单这个任务，需要 200ms；查询司机这个任务，也就需要100ms。按理来说应该先返回司机信息的结果，再返回订单信息的结果。

由于 `future.get()` 会阻塞主线程，形成了排队等待的情况，所以这种方式就存在一定的缺陷了



## CompletionService 实现并行调用

### CompletionService

CompletionService 对 ExecutorService 进行了包装，内部通过 FutureTask + 阻塞队列实现了先完成的任务可以先获取到

但是需要注意的是，由于是维护了一个队列，获取结果时需要先让结果出队列后获取，否则如果线程池一直不销毁，这个已完成的任务就一直在队列中，**最终会有 OOM 的风险**

### 实现

```java
public void test4() throws InterruptedException, ExecutionException {
    // 创建固定线程的线程池
    ExecutorService executor = Executors.newFixedThreadPool(10);
    // 创建CompletionService
    CompletionService<String> completionService = new ExecutorCompletionService<>(executor);

    // 定义查询订单信息任务
    Callable<String> orderCallableTask = () -> {
        System.out.println("===== 正在查询订单信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询订单信息成功 *****";
    };
    // 定义查询司机信息任务
    Callable<String> driverCallableTask = () -> {
        System.out.println("===== 正在查询司机信息 =====");
        TimeUnit.MILLISECONDS.sleep(100);
        return "***** 查询司机信息成功 *****";
    };
    // 定义查询车辆信息任务
    Callable<String> carCallableTask = () -> {
        System.out.println("===== 正在查询车辆信息 =====");
        TimeUnit.MILLISECONDS.sleep(200);
        return "***** 查询车辆信息成功 *****";
    };

    // 提交查询订单信息任务
    completionService.submit(orderCallableTask);
    // 提交查询司机信息任务
    completionService.submit(driverCallableTask);
    // 提交查询车辆信息任务
    completionService.submit(carCallableTask);

    for (int i = 0; i < 3; i++) {
        // 等待1秒内如果获取不了数据则超时
        Future<String> future = completionService.poll(1, TimeUnit.SECONDS);
        // 获取结果
        String result = future.get();
        System.out.println(result);
    }
    // 销毁线程池
    executor.shutdown();
}
```

至此，这个做法实现了并行、线程池、先完成先获取结果的目标

最后获取结果处需要特别留意一下，除了上面提到的需要优先执行 `poll` 方法让结果出队列外，获取结果时需要自己做逻辑判断，判断这个结果是属于哪一个任务的



CompletableFuture
