# 网络设备

## 网线

大刘的电脑 A 和小美电脑 B 可以通过**网线**连接起来，组成一个网络，于是这两台电脑可以互相传输接收数据

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228142159.png)

## 交换机

没过多久，隔壁老王的电脑 C 、阿丽的电脑 D 和 敏敏的电脑 E 也要加入到上面的网络中，参与数据传输接收的过程，显然只使用网线是不现实的，因为如果要实现5个电脑两两之间可以传输数据，需要 5 * 5 = 25 条网线，且电脑不一定有这么多网线接口。那么搞不定的问题就用分层的办法处理

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228142653.png)

于是出现了二层网络设备——**交换机**，交换机提供了网络互联的功能

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228142849.png)

> 既然交换机可以接入多台电脑，那么它是怎么识别不同的电脑的呢？又是如何进行数据转发的呢？

每个电脑的网卡的 **MAC 地址**都是不一样的，MAC 地址是烧录到电脑的网卡上的，也叫硬件地址，可以标识某一台设备。电脑在发送数据时，数据头部携带了网卡的 MAC 地址，交换机就可以识别数据的 MAC 地址来区分不同的电脑

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228143922.png)

但是交换机除了能识别不同的电脑外，还需要找到电脑连接的**交换机端口**，才能顺利地把数据从相应端口发送出去。交换机通过**自学机制**，把学习到的 MAC 地址和交换机端口号维护成一份 **MAC 地址表**，数据传输时就根据 MAC 地址表进行转发

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228144424.png)



## 路由器

随着韩国棒棒的电脑 F 、美国山姆的电脑 G 和印度三三的电脑 H 等陆续加入这个网络，网络中的上网设备变得越来越多，交换机需要记录的 MAC 地址也变得越来越多。但是交换机的容量和性能有限，一方面，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号（一台交换机上的端口也是有限的）；另一方面，MAC 地址表中的数据量过多也容易导致无法快速查找到对应的 MAC 地址表项

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228145549.png)

交换机搞不定的问题，就继续用分层的办法处理。

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228145715.png)

于是出现了第三层的网络设备——**路由器**，路由器可以把全世界的网络连接起来。局域网内的网络可以通过交换机进行数据交换，例如一个公司内部的网络通过交换机相互连接。不同区域的局域网互联使用路由器来完成

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228151935.png)

> 那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？

MAC 地址可以标识某一台设备，但无法用来标识某一个网络区域，为了区分不同的网络区域，IP 地址出现了。IP 地址由网络号和主机号组成，网络号用于标识网络区域，网络号相同的主机位于同一个网络中；主机号用于标识同一个网段中的不同主机，不允许同网段中出现重复的主机号。在整个网络中通过设置网络号和主机号，来保证每台主机 IP 地址的唯一性

路由器有多个端口，分别连接不同的网络地址，不同的网络区域 IP 地址网络号不同，它通过识别目的 IP 地址的网络号，再根据**路由表**进行数据转发

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228160156.png)



# IP地址

## 形式

IP地址是**一个32位的二进制数**，通常被**分割成4个8位二进制数**（4个字节）；同时通常用**点分十进制的表示形式**（a.b.c.d）其中abcd都是0~255的十进制数

## 分类

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20201223232827.png)

![](https://gitee.com/ngwingbun/pic/raw/master/20210321210746.png)

### A类地址

A 类地址第一位以 0 开头，可变化的网络位有 7 位，即 128 个 A 类地址。其中 0 和 127 属于**特殊地址**，可用的 A 类地址就是 128 - 2 = `126` 个。

可变化的主机位有 24 位，即 16777216 个主机地址。其中主机位全为 0 和主机位全为 1 分别为**网段地址**和**广播地址**，不能分配给主机使用，每个 A 类地址可用的主机地址就是 16777216 - 2 = `16777214` 个。

A 类地址的范围是 `1.0.0.0 ~ 126.255.255.255` 。

A 类地址子网掩码是 `255.0.0.0` ，也可写作 `/8` 。

A 类地址的私有地址区域：`10.0.0.0 ~ 10.255.255.255`

一般用于大型网络

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228165630.png)

### B类地址

B 类地址前两位以 10 开头，可变化的网络位有 14 位，即 16384 个 B 类地址。其中 128.0 和 191.255 属于**特殊地址**，可用的 B 类地址就是 16384 - 2 = `16382` 个。

可变化的主机位有 16 位，即 65536 个主机地址。其中主机位全为 0 和主机位全为 1 分别为**网段地址**和**广播地址**，不能分配给主机使用，每个 B 类地址可用的主机地址就是 65536 - 2 = `65534` 个。

B 类地址的范围是 `128.0.0.0 ~ 191.255.255.255` 。

B 类地址子网掩码是 `255.255.0.0` ，也可写作 `/16` 。

B 类地址私有地址区域：`172.16.0.0 ~ 172.31.255.255`

一般用于中等规模网络

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228171822.png)

### C类地址

C 类地址前三位以 110 开头，可变化的网络位有 21 位，即 2097152 个 C 类地址。其中 192.0.0 和 223.255.255 属于**特殊地址**，可用的 C 类地址就是 2097152 - 2 = `2097150` 个。

可变化的主机位有 8 位，即 256 个主机地址。其中主机位全为 0 和主机位全为 1 分别为**网段地址**和**广播地址**，不能分配给主机使用，每个 C 类地址可用的主机地址就是 256 - 2 = `254` 个。

每一个网段可用主机地址：假定这个网段的主机部分位数为n，那么可用的主机地址个数为2^n - 2个 IP 地址可用（除去网关地址、广播地址）

C 类地址的范围是 `192.0.0.0 ~ 223.255.255.255` 。

C 类地址子网掩码是 `255.255.255.0` ，也可写作 `/24` 。

C 类地址私有地址区域：192.168.0.0-192.168.255.255

一般用于小型网络

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228173140.png)

### D类地址

- 多播地址
- **该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间**
- 一般用于多路广播用户



### E类地址

- 保留地址
- **该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间**



### 无类地址

经过子网划分或超网合并的网段地址，不再是固定的网络位数，这种网络位数可变的网段地址就叫无类地址

无类地址只能通过子网掩码来计算出网络号



### 特殊IP地址

| 网络部分 | 主机部分 | 地址类型 | 用途                                                         |
| -------- | -------- | -------- | ------------------------------------------------------------ |
| Any      | 全0      | 网络地址 | 代表一个网段<br />网段地址 192.168.10.0/24 表示的是网络号为 192.168.10 的所有地址 |
| Any      | 全1      | 广播地址 | 特定网段的所有节点<br />网段地址 192.168.10.0/24 的广播地址是 192.168.10.255 。 |
| 127      | 0.1      | 环回地址 | 环回测试                                                     |
| 全0      | 全0      | 所有网络 | 默认路由                                                     |
| 全1      | 全1      | 广播地址 | 本网段所有节点                                               |



### 公有地址和私有地址

在A、B、C类地址中，划分了一部分作为私有IP地址，另一部分为公有IP地址。**公有IP它是由NIC（网络信息中心）或者ISP（网络服务提供商）分配的地址作为公网IP，私有IP地址是预留给各企业内部网自由支配的IP地址**。


#### 私有地址不能直接访问互联网

公网上没有针对私有地址的路由，会产生地址冲突问题，当访问互联网时，需要利用网络地址转换（NAT，Network Address Translation）技术，把私有IP地址转换为互联网可识别的公共IP地址



## 子网掩码

子网掩码也是由32位二进制数组成，网络位为1，主机位为0。子网掩码和 IP 地址进行 `&` 运算，来决定 IP 地址中网络号部分和主机号部分

缺省状态下，如果没有进行子网划分，各类网络有默认的子网掩码

- A类网络：255.0.0.0，前8位为网络部分，后24位为主机部分
- B类网络：255.255.0.0，前16位为网络部分，后16位为主机部分
- C类网络：255.255.255.0，前24位为网络部分，后8位为主机部分

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210329214138.png)

### 子网掩码另一种表示方式

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210329214523.png)

### 无子网编址

不对网段进行细分，使用默认的子网掩码。但是在实际使用网络时，需要的 IP 地址数量却是各不相同

> 例子一：一个公司有 500 台电脑，需要分配 500 个 IP 地址。如果分配一个 C 类地址，一个 C 类地址的可用 IP 地址数量是 254 个，可用地址不够使用。如果分配一个 B 类地址，一个 B 类地址的可用 IP 地址数量是 65534 个，会造成大量的 IP 地址浪费。

> 例子二：一个家庭有 2 台电脑需要上网，如果分配一个 C 类地址也很浪费，但是没有比 C 类范围更小的地址。

为了解决 IP 地址浪费的问题，可以结合使用 CIDR （无类域间路由）和 VLSM （可变长子网掩码）技术



### VLSM

VLSM 可以对 A 、 B 、 C 类地址进行划分，划分成各种类型大小的网络，可用主机地址数量可以灵活地缩放，划分地址的过程也叫**子网划分**

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228193252.png)



### CIDR

CIDR 可以把多个分类地址汇聚到一起，生成一个更大的网段，以减少路由器中路由条目的数量，减轻路由器的负担。分类地址合并的过程也叫**超网合并**

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20211228194044.png)





### 带子网编址

从地址分配的角度看，子网是对网段地址的扩充。网络管理员根据组织的扩张来决定每一个子网的大小

利用子网，网络地址的使用会更为有效。对外，仍然是一个网络，对内，则分为不同子网

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210329220722.png)



## 子网划分





# HTTP

## 概念

HTTP：超文本 传输 协议

- 协议
  - 协：两个以上的参与者
  - 议：行为约定和规范
- 传输：两点之间双向传输
- 超文本：不仅包括文本，还包括图片、视频、压缩包等

## 状态码

- 1xx，1xx类状态码属于**提示信息**，是一种中间状态，还需要后续的操作
- 2xx，2xx类状态码表示服务器**成功处理**了客户端的请求
  - 200 - OK：成功状态码，只要不是HEAD请求，服务器返回的响应头都会**有body数据**
  - 204 - No Content：成功状态码，与200基本相同，但是响应头**没有body数据**
  - 206 - Partial Content：表示响应返回的**body数据只是资源的一部分**，应用于**分块下载**或**断点续传**
- 3xx，3xx类状态码表示客户端请求的资源**发生了变动**，需要客户端用新的URL重新发送请求获取资源，也就是**重定向**
  - 301 - Moved Permanently：**永久重定向**，说明请求的资源已经不存在，需要用新的URL再次访问
  - 302 - Moved Temporarily：**临时重定向**，请求的资源还在，但暂时需要用另一个URL来访问
  - 304 - Not Modified：**资源未修改**，重定向已存在的缓存文件
  - 301、302都会在响应头里使用字段`Location`，指明后续要跳转的URL，浏览器会自动重定向新的URL
- 4xx，4xx类状态码表示客户端发送的请求报文有误，服务器无法处理
  - 400 - Bad Request：客户端请求的报文有错误，但只是个**笼统的错误**，可能是请求的参数类型不对等
  - 401 - Unauthorized：客户端**没有访问权限**，需要进行身份认证
  - 403 - Forbidden：服务器**禁止访问资源**，并不是客户端的请求出错
  - 404 - Not Found：请求的**资源在服务器上不存在或未找到**
- 5xx，5xx类状态码表示客户端请求的报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码
  - 500 - Internal Server Error：服务端发生了错误，与400类似，是一个**笼统的错误**
  - 502 - Bad Gateway：通常是服务器**作为网关或代理时**返回的错误码，表示服务器自身工作正常，访问下游服务器发生了错误
  - 503 - Service Unavailable：表示服务器当前很忙，**暂时无法响应**服务器

## 请求安全、幂等

在 HTTP 协议里，所谓的「安全」是指请求方法**不会「破坏」**服务器上的资源

所谓的「幂等」，意思是多次执行相同的操作，**结果**都是**「相同」**的

Get方法就是安全且幂等的，因为它是**只读**操作

Post方法是不安全而且不幂等的，因为是新增或提交数据，会修改服务器上的资源

## HTTP无状态特性

### 优点

因为服务器不去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，能有效减轻服务器的负担，能把更多CPU和内存来对外提供服务

### 缺点

没有记忆能力，所以在完成有关联性的操作时会非常麻烦

>  例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

## HTTP不安全性

### 窃听风险

**明文传输**的优点：方便阅读，为调试工作提供极大的便利性；缺点：在信息传输的过程中，内容毫无隐私可言，容易被窃取

### 冒充风险

有可能遭遇伪装，如：伪装的淘宝等软件

### 篡改风险

无法证明报文的完整性，所以有可能已遭篡改，如：网页被恶意植入广告

## HTTP1.1 HTTP2 HTTP3演变

**HTTP1.1和HTTP1.0相比，性能上的改进**

- 使用TCP长连接的方式改善了HTTP1.0短链接造成的性能开销
- 支持管道网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

**HTTP1.1的性能瓶颈**

- 请求和响应的头部未经压缩就发送，头部信息越多，延迟越大。**只支持压缩Body部分**
- 发送冗长的头部，每次互相发送相同的头部造成的浪费较多
- 服务器是**按请求顺序响应**的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是**队头阻塞**
- 请求只能从客户端开始，服务器只能被动响应

---

**HTTP2针对HTTP1.1性能瓶颈做的优化**

- 头部压缩

  如果同时发送多个请求，相似或相同的头部，协议会消除重复的部分。使用的是**HPack**算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成索引号，在发送消息的时候就不发送同样的字段，只发送索引号，这样可以提高速度

- 二进制格式

  HTTP2报文全面采用二进制格式，统称为帧。计算机无需再将明文转成二进制，增加了数据传输的效率

  ![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210429160627.png)

- 数据流

  HTTP2的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，因此必须要进行标记，指出他属于哪个回应。每个请求或回应的所有数据包，称为一个**数据流(Stream)**

  客户端还可以指定数据流的优先级，优先级高的请求，服务器应该优先处理

  ![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210429162743.png)

- 多路复用

  HTTP2可以在一个连接中并发多个请求或响应，而不用按照顺序一一对应。**降低了延迟，大幅度提高了连接的利用率**

  ![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210429162951.png)

- 服务器推送

  HTTP2中服务器不再被动地响应，还可以主动向客户端发送消息

  举例：在浏览器刚请求HTML的时候，服务器可以提前把用到的CSS、JS等静态文件主动发送给客户端，**减少延迟等待**

**HTTP2的缺陷**

- 基于TCP协议的错误触发的重传机制

  **多个HTTP请求在复用一个TCP连接，下层的TCP协议不知道有多少个HTTP请求**，一旦发生丢包，就会触发TCP重传机制，这样在一个TCP连接中所有的HTTP请求都必须等待这个丢了的包重新传回去

---

**HTTP3针对HTTP2的缺陷做的优化**

- QUIC协议

  HTTP1.1和HTTP2的传输层都是使用TCP协议的，一旦发生丢包，会触发TCP重传机制

  - HTTP1.1中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
  - HTTP2多个HTTP请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求

  所以HTTP3把HTTP下层的TCP协议改成了UDP，UDP协议不管顺序，不管丢包问题

  **HTTP3使用的是基于UDP的QUIC协议，可以实现类似TCP的可靠性传输**

  - 当某个流发生丢包，**只会阻塞这个流，其他流不会收到影响**
  - TLS升级成TLS1.3版本，头部压缩算法升级成了**QPack**
  - 以往HTTPS要建立连接的话，需要TCP的3次握手+TLS的3次握手，**HTTP3把6次握手合并成了3次握手**

  ![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210429165128.png)

  ![](https://gitee.com/ngwingbun/pic/raw/master/20210429165415.png)

  **总结：QUIC是一个在UDP上的伪TCP+TLS+HTTP2的多路复用协议**

  

# HTTPS

## HTTP与HTTPS区别

1. HTTP的信息是明文传输，存在安全性问题；HTTPS则在TCP和HTTP之间加入SSL/TLS安全协议，使得报文能加密传输
2. HTTP连接建立相对简单，TCP三次握手后就可以进行HTTP报文传输，而HTTPS则需要在TCP三次握手后，还需要进行SSL/TLS的握手过程，才可以进行密文传输
3. HTTP协议端口是80，HTTPS协议端口是443
4. HTTPS需要向CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的

## HTTPS解决的问题

### 信息加密

传输过程经过加密，交互信息无法被窃取。**混合加密**的方式，解决了窃听风险。

**混合加密**

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210428174959.png)

- 在通信建立前使用**非对称加密**的方式交换**会话密钥**，后续就不再使用非对称加密
- 在通信过程中使用**会话密钥**使用**对称加密**的方式加密明文数据

**使用混合加密的原因**

- 对称加密只使用一个密钥，运算速度快，**但是密钥必须保密**
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题，但是速度较慢

### 身份证书

证明淘宝是真的淘宝网。将服务器公钥放入到**数字证书**中，解决了冒充风险。

**数字证书**

**解决客户端向服务器索要公钥时的安全问题**，保证公钥不被篡改，这样客户端使用服务器的公钥加密数据，服务器使用自己的私钥进行数据解密

**数字证书认证机构(CA)**

只要证书是可信的，那么公钥就是可信的

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/640)



### 校验机制

无法篡改通信内容，篡改了就不能正常显示。**摘要算法**的方式来实现**完整性**，它**能够为数据生成独一无二的「指纹」**，指纹用于校验数据的完整性，解决了篡改风险。

**摘要算法**

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210428175609.png)

- 客户端在发送明文之前通过摘要算法计算出明文的「指纹」

- 发送时把「指纹 + 明文」一同加密成密文后，发送给服务器
- 服务器解密后，用相同的摘要算法算出接受到的明文的「指纹」
- 然后把计算出来的「指纹」和接受到的「指纹」进行比对，如果「指纹」相同，那么说明数据是完整的

## TLS/SSL

### SSL

Secure Socket Layer，安全套接字层，位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。

### TLS

Transport Layer Security，传输层安全协议，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

## HTTPS建立连接

**SSL/TLS 协议基本流程**

- 客户端向服务器索要并验证服务器的公钥
- 双方协商生成**会话密钥**，用公钥加密会话密钥
- 双方采用会话密钥进行加密通信

**流程图**

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20210429100559.png)

**具体握手流程**

1. **ClientHello**

   客户端向服务器发起加密通信请求，请求的内容包含：

   1. 客户端支持的SSL/TLS协议版本，如TLS1.2版本
   2. 客户端生成随机数(Client Random)，后面用于生成**会话密钥**
   3. 客户端支持的密码套件列表，如RSA加密算法

2. **ServerHello**

   服务器回应客户端的加密通信请求，响应的内容包含：

   1. 确认使用的SSL/TLS协议版本，**如果浏览器不支持的话，则关闭这个加密通信**
   2. 服务器生成随机数(Server Random)，后面用于生成**会话密钥**
   3. 确认使用的密码套件列表
   4. 服务器的数字证书

3. **客户端回应**

   CA的公钥会内置在浏览器或操作系统中，所以客户端收到服务器发过来的数字证书后，使用CA的公钥进行确认其有效性并解密，解密后就得到服务器的公钥，然后用它加密报文，向服务器发送以下内容：

   1. 随机数(pre-master key)，该随机数会被服务器的公钥进行加密。此时双方都有**Client Random**、**Server Random**、**pre-master key**三个随机数，可以各自生成本次通信的**会话密钥**
   2. 加密通信算法改变通知，表示随后的信息都将使用**会话密钥加密通信**
   3. 客户端握手结束通知，这一项同时把之前所有内容产生的数据做摘要，用来供服务器校验

4. **服务器的最后回应**

   服务器收到客户端的第三个随机数(pre-master key)后，通过前面协商好的加密算法，用Client Random、Server Random、pre-master key生成本次通信的**会话密钥**

   1. 加密通信算法改变通知，表示随后的信息都将使用**会话密钥加密通信**
   2. 服务器握手结束通知，这一项同时把之前所有内容产生的数据做摘要，用来供客户端校验
   
5. **加密通信，使用的是双方约定生成的会话密钥来加密**

