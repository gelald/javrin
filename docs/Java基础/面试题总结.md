## Java 语言有哪些特点

1. 面向对象（封装、继承、多态）
2. 跨平台（ Java 虚拟机实现了平台无关性）
3. 支持多线程

「一次编写，随处运行」这句口号非常经典，直到今天依然有很多人都认为 Java 的跨平台特性是其最大的优点，但其实现在跨平台技术也相当成熟了，比如通过 Docker 也可以轻松实现跨平台，因为有 Docker Engine 帮它实现了跨平台的特性，在我看来，Java 最大的优势是前期跨平台的优势而积累下来的强大的生态。



## 面向对象的三大特性

封装

继承

多态

## JVM JRE JDK 区别

- JVM：Java 虚拟机，Java 源代码编译后生成 Java 字节码文件，由 Java 虚拟机运行。字节码文件和不同操作系统上的JVM是实现跨平台特性的关键

- JRE：Java 运行环境，JRE 是运行 Java 程序所需内容的集合，包括 JVM 和 Java 类库等

- JDK：Java 开发工具包，能够创建、编译、运行程序。除了包含 JRE，还提供了一系列的开发工具，如编译器 javac、查看 Java 程序进程工具 jps、反编译工具 javap 等



## 什么是字节码，采用字节码的好处

Java 源代码经过 Java 编译器后就生成了 JVM 能理解的字节码

采用字节码的好处

- 实现跨平台特性：Java  源代码经过编译后生成的字节码是由不同操作系统的 JVM 来运行的，所以 Java  程序无须重新编译便可在多种不同操作系统的计算机上运行
- 编译和解释并存：Java 源代码经过 Java 编译器后生成字节码，运行时由 Java 解释器生成机器码（热点代码问题由 JIT 编译器处理），同时具备了编译型语言和解释型语言的特点，所以能同时保证开发和机器执行的速度



## 方法重写和方法重载的区别

方法重写和方法重载是 Java 多态性的不同表现

- 方法重写
  - 方法重写存在于**继承体系**中
  - 需要在**运行期**根据具体对象的类型才能确定使用的方法
  - 方法重写需要遵循【**两同两小一大**】的规则
    - 两同：方法名相同、参数列表相同
    - 两小：子类方法返回值要**小于等于**父类方法返回值类型、子类方法声明抛出的异常类型和比父类声明抛出的异常类型**应该相等或抛出更少、更具体的异常，甚至不抛出**
    - 一大：子类方法的访问权限要比父类方法的访问权限更大或相等

- 方法重载
  - 方法重载存在于同一个类中，也可以放生在继承体系中（重载父类的方法）
  - 在**编译期**根据参数列表就可以确定使用哪一个方法
  - 方法重载可以是参数类型不同、个数不同、顺序不同、声明抛出异常不同，但是**返回值类型必须相同**



## 包装类型与基本类型的区别

1. 从类型上来看：**包装类型可用于泛型，而基本类型不可以**。因为泛型在编译时会进行**类型擦除**，最后只保留**原始类型**，而原始类型只能是 **Object 类及其子类**。包装类型的都是Object的子类，而基本类型没有所谓的原始类型。

2. 从值来看：**包装类型可以为 null，基本类型不可以**。包装类型可以应用于 POJO 的属性类型，基本一般来说不太推荐。因为数据库的查询结果可能是 null，如果使用基本类型的话，就可能会抛出 `NullPointerException` 的异常。
3. 从比较环节来看：**基本类型使用 == 进行比较；包装类型需要使用 equals 方法进行比较，用 == 比较的是地址值**。此外，**包装类型和基本类型进行 == 比较的时候会自动拆箱。**
4. 总体上来说：**基本类型比包装类型更高效**。基本类型在栈中直接存储的具体数值，而包装类型在栈中存储的是堆中的引用。很显然，相比较于基本类型而言，**包装类型需要占用更多的内存空间**。



## 成员变量和局部变量的区别

1. 从语法上看：成员变量是定义在类里面的，并且有访问修饰符；局部变量是定义在方法或者代码块里面的，不能使用访问修饰符
2. 从存储位置来看：对象存储在堆中，所以成员变量也是存储在堆中；局部变量随着方法入栈而创建，所以局部变量存储在栈中
3. 从默认值来看：成员变量在定义时如果没有赋予初始值，则自动以类型的默认值进行复制；局部变量则不会自动赋值



## 接口和抽象类的共同点和区别



## 深拷贝和浅拷贝的区别



## String、StringBuffer、StringBuilder 的区别



## hashCode 方法与 equals 方法

hashCode 方法返回对象的哈希码

HashSet等容器会根据两个对象的 hashCode 是否相等来决定两个对象是否相同

但是两个对象 hashCode 相等，不一定代表两个对象相同，因为会存在【哈希冲突】，也就是说使用的哈希算法刚好让两个对象返回了相同的哈希码

如果两个对象 hashCode 相等会继续调用其 equals 方法来进一步判断，也就是说使用 hashCode 能帮助我们减少对比的成本



结论：

- 如果两个对象 hashCode 相等，那这两个对象不一定相等（存在哈希冲突）
- 如果两个对象 hashCode 相等，而且 equals 方法也返回 true，那么这两个对象可以认为是相等的
- 如果两个对象 hashCode 不相等，那么可以直接认为这个对象是不相等的



重写 equals 方法必须重写 hashCode 方法的原因

因为两个对象 equals 方法返回 true，那么它们的 hashCode 必须要相等