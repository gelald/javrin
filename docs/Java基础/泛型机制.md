# 泛型

> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

## 优点

适用于多种数据类型执行相同的代码，使用一个泛型封装所有相同的逻辑

```java
private static int add(int a, int b) {
    System.out.println(a + "+" + b + "=" + (a + b));
    return a + b;
}

private static float add(float a, float b) {
    System.out.println(a + "+" + b + "=" + (a + b));
    return a + b;
}

private static double add(double a, double b) {
    System.out.println(a + "+" + b + "=" + (a + b));
    return a + b;
}
```

可以看到，每一种类型都要写一份相同的代码，我们可以通过泛型进行逻辑封装

```java
private static <T extends Number> double add(T a, T b) {
    System.out.println(a + "+" + b + "=" + (a.doubleValue() + b.doubleValue()));
    return a.doubleValue() + b.doubleValue();
}
```



泛型中的类型在使用时指定，不需要强制类型转换（**类型安全**，编译器会**检查类型**）

```java
List list = new ArrayList();
list.add("xxString");
list.add(100d);
list.add(new Person());
```

可以看到集合中放了多种类型的数据，使用的时候很可能需要进行强制类型转换，甚至有转换失败的异常。如果我们在定义集合的时候就已经定义了这个集合中使用的类型，那么使用起来就方便许多，拿到集合中的元素可以直接使用 String 的方法

```java
List<String> list = new ArrayList<String>();
```



## 泛型的上下限

> 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。`<? extends A>`表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。

```java
public class A {
    
}
////////////////
public class B extends A {
    
}
///////////////
public class C {
    
}

///////////////

public static void fun1(List<? extends A> listA) {
    // ...          
}
public static void fun2(List<B> listB) {
    funC(listB); // OK
    // ...             
}

```



泛型上下限的用法

```java
<?> 无限制通配符
<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类
```



## 深入理解泛型

> 了解泛型基本用途以后，深入泛型背后的泛型擦除及相关问题来加深对泛型的理解