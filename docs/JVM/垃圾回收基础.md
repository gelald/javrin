# 垃圾回收基础

> 垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收



## 判断一个对象是否可以被回收



### 引用计数算法

实现原理：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

弊端：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```



### 可达性分析算法

实现原理：通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。**JVM 使用这种算法来判断对象是否可以被回收**。

GC Roots 一般包含以下内容：

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象



## 引用类型

> 无论使用哪种算法，判断对象是否可以被回收，都和引用有关。Java 中具有四种不同强度的引用类型。

### 强引用

使用 new 关键字创建对象的方式创建强引用

```java
Object obj = new Object();
```

被强引用关联的对象不会被回收



### 软引用

使用 `SoftReference` 类来创建软引用

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<>(obj);
obj = null; // 使对象只被软引用关联
```

被软引用关联的对象只有在内存不够的情况下才会被回收



### 弱引用

使用 `WeakReference` 类来创建弱引用

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<>(obj);
obj = null;
```

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前



### 虚引用

使用 `PhantomReference` 类来创建一个虚引用

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<>(obj);
obj = null;
```

一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。

为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。



## 垃圾回收算法

### 标记-清除

标记-清除算法原理：将存活的对象进行标记，然后清理掉未被标记的对象。

弊端：

- 标记和清除过程的效率都不高
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220323153938.png)



### 标记-整理

标记-整理算法原理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220323154032.png)



### 复制

复制算法原理：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理

弊端：只使用了内存的一半，无法充分利用

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220323154210.png)



### 具体落地

现在的虚拟机都采用分代收集算法，不同代采用不同的算法

- 新生代：采用复制算法，但不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 区和两块较小的 Survivor 区。每次使用 Eden 区和其中一块 Survivor 区，在回收时将还存活的对象复制到另一块 Survivor 区上，最后清理 Eden 区和原本使用的那块 Survivor 区。Eden 区和两块 Survivor 区大小比例默认是 `8:1:1`，这样保证了新生代内存的使用率为90%
- 老年代：采用标记-清除算法或者标记-整理算法



## 垃圾收集器

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220323155408.png)

以上是7个垃圾收集器，连线表示可以配合使用

重点关注 CMS 收集器和 G1 收集器



### CMS 收集器