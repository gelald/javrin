# Java 类加载机制



## 类的生命周期

类的生命周期总体上包括：加载、使用、卸载；而类的加载阶段总体上分为加载、连接、初始化，而连接阶段可以细分为验证、准备、解析。

类加载的这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。

另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段**通常都是互相交叉地混合进行的**，通常在一个阶段执行的过程中调用或激活另一个阶段。

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220317145818.png)



### 加载阶段

加载是类加载过程的第一个阶段，在加载阶段，JVM需要完成以下三件事

- 通过一个类的全限定类名获取其定义的**二进制字节流**
- 将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**
- 在**堆中生成一个代表这个类的 Class 对象**，作为对方法区中这些数据的访问入口

![](https://gitee.com/ngwingbun/picgo-image/raw/master/images/20220317153259.png)

其中加载阶段的获取类的二进制字节流的动作是可控性最强的，因为开发人员既可以使用JVM的类加载器来完成加载，也可以自定义自己的类加载器来完成加载

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个`java.lang.Class`类的对象，这样便可以通过该对象访问方法区中的这些数据。

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

加载 class 文件的方式

- 本地系统中加载
- 通过网络下载 class 文件（可能有安全性问题）
- 从 zip、jar 等压缩文件中提取 class 文件
- 将 java 源文件动态编译为 class 文件



### 连接

> 连接阶段可以细分为验证、准备、解析三个阶段

#### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作

- 文件格式验证：验证字节流是否符合class文件格式的规范，如是否以 `0xCAFEBABE` 开头等
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有除了 `java.lang.Object ` 之外的父类
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
- 符号引用验证：确保解析动作能正确执行

其中验证阶段是很重要但却不是必须的，因为它对程序运行没有影响。如果引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。



#### 准备

准备阶段会为静态变量分配内存并初始化为默认值，这些内存会分配在方法区中

- 这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

- 这里所设置的初始值通常情况下是数据类型**默认的零值**(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。

  假设一个类变量的定义为: `public static int value = 3`；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的指令是在程序编译后，存放于类构造器 `<init>()` 方法之中的，所以**把value赋值为3的动作将在初始化阶段才会执行**。

- 对于同时被 `static` 和 `final` 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 `final` 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。

- 对于同时被 `static` 和 `final` 修饰的常量，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为:  `public static final int value = 3;` 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为`static final`常量在编译期就将其结果放入了调用它的类的常量池中

