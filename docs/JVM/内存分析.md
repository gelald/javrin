# 内存分析

> 在排查 JVM 的相关问题中，内存分析是其中一个有效的手段

## 常见的内存溢出问题

### Java 堆内存溢出

Java 堆内存溢出的情况主要有两种

#### OutOfMemoryError: Java heap space

可以将 `-Xms(初始堆内存)`，`-Xmx(最大堆内存)` 设置为一样来禁止自动扩展堆内存。

当使用一个死循环来不断地在 Java 堆中创建对象，并且 `GC-Roots` 到对象之间存在引用链，JVM 不会回收对象，就会发生 `OutOfMemory`。

```java
public static void main(String[] args) {
    List<String> list = new ArrayList<>(10) ;
    for(;;) {
        list.add("1") ;
    }
}
```

```java
```



当出现 OOM 时可以通过工具来分析 `GC-Roots` ，查看对象和 `GC-Roots` 是如何进行关联的，是否存在对象的生命周期过长，或者是这些对象确实该在的，那就要考虑将堆内存调大了。

可以使用 `-XX:+HeapDumpOutofMemoryErorr` 配置，当发生 OOM 时会自动 dump 堆栈到文件中。



#### OutOfMemoryError: GC overhead limit exceeded

通过统计GC时间来预测是否要 OOM 了，提前抛出异常，防止真正的 OOM 发生。

Sun 官方对此的定义是：“并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。”

```java
public static void main(String[] args) {
	List<Map<String, Object>> mapList = new ArrayList<>();
	for (int i = 0; i < 1000000; i++) {
		Map<String, Object> map = new HashMap<>();
		for (int j = 0; j < i; j++) {
				map.put(String.valueOf(j), j);
		}
		mapList.add(map);
	}
}
```

```java
```

