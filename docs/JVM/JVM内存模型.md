# JVM 内存模型

> 本文从堆栈角度引入JMM，然后介绍JMM和物理内存之间的关系



## JMM 引入

### 堆栈的内容

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220406100824.png)

Heap （堆）包含了程序中创建的所有对象。无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上，其次对象上的成员变量，无论是基本类型还是引用类型也是存储在堆上。静态类变量也与类定义一起存储在堆上。

Thread Stack（线程栈）包含了每个方法的所有局部变量。基本类型的局部变量完全存储在线程栈中，一个线程可以将一个基本类型变量的**副本传递**给另一个线程，但它不能共享原始局部变量本身。引用类型的局部变量，引用存储在线程栈中，指向的对象存储在堆上。



## JMM 与硬件内存结构关系

### 硬件内存结构简介

![](https://wingbun-notes-image.oss-cn-guangzhou.aliyuncs.com/images/20220411162526.png)

- CPU：现代计算机通常有 2 个或更多的 CPU（其中一些 CPU 有可能有多个内核），可以同时运行多个线程，支持多线程程序。
  - CPU 寄存器：每个 CPU 基本上包含一组在 CPU 内存中的寄存器，CPU 在这些寄存器上的操作比在主存储区的操作要更快。
- CPU 高速缓存存储区：

现代计算机通常有2个或更多CPU。 其中一些CPU也可能有多个内核。 关键是，在具有2个或更多CPU的现代计算机上，可以同时运行多个线程。 每个CPU都能够在任何给定时间运行一个线程。 这意味着如果您的Java应用程序是多线程的，线程真的在可能同时运行.

每个CPU基本上都包含一组在CPU内存中的寄存器。 CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为CPU可以比访问主存储器更快地访问这些寄存器。

每个CPU还可以具有CPU高速缓存存储器层。 事实上，大多数现代CPU都有一些大小的缓存存储层。 CPU可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些CPU可能有多个缓存层(级别1和级别2)，但要了解Java内存模型如何与内存交互，这一点并不重要。 重要的是要知道CPU可以有某种缓存存储层。

计算机还包含主存储区(RAM)。 所有CPU都可以访问主内存。 主存储区通常比CPU的高速缓存存储器大得多。同时访问速度也就较慢.

通常，当CPU需要访问主存储器时，它会将部分主存储器读入其CPU缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。